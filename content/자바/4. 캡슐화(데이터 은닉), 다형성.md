
### 정보를 보호하기 위한 대책

- 변수는 private 접근으로 막는다. 
- 공개되는 메서드를 통한 접근 통로 마련 -> getter, setter 


### 다형성 
- 상속관계에 있을 떄 조상 클래스의 타입으로 자식 클래스 객체를 참조할 수 있다. 
- 무조껀 큰거에서 작은거를 참조 할 수 있는 것. 

### 다형성의 활용

- 다형성으로 다른 타입의 데이터를 하나의 배열로 관리할 수 있다. 

- Animal 이 최상위 객체일때.
```
public class Main {
    public static void main(String[] args) {
        // 다형성을 이용해 부모 타입 배열에 다양한 자식 객체 저장
        Animal[] animals = new Animal[3];
        animals[0] = new Dog();
        animals[1] = new Cat();
        animals[2] = new Dog();

        for (Animal a : animals) {
            a.sound();  // 실제 객체의 sound()가 호출됨
        }
    }
}
```

> [!note] 참고
> 그래서 보통 API 에서 파라미터로 Object 를 받는다는 것은 모든 객체를 처리한다는 말이다. 
> 
> 그래서 함수들 많이 만들 필요 없이 하나로 모든 자료형을 받을 수 있는것임. 

```
public void println(Object x) {
    String s = String.valueOf(x);
    synchronized (this) {
        print(s);
        newLine();
    }
}
```
- 그러면 질문? int 같은 기본 자료형들은 Object 의 자식들이 아닌데. 상속받지 않음.
- println 은 어떻게 쓰는거지? 
  -> 기본 자료형들은 Wapper Class 로 저절로 변환해준다고 함. 


### 객체의 형 변환

- 하위타입을 상위 타입으로 형 변환 -> 묵시적 캐스팅 가능
- 만약 상위타입을 하위타입으로 형 변환 ? -> 명시적 캐스팅 해야함. 

> [!important] 근데 여기서 혼동이 올 수 있는것.
>  객체를 참조하는거랑 형 변환하는거랑 다른것임.
>  
> 객체 참조 :
> 	 Person person = new SpiderMan();          가능 
> 	 SpiderMan spiderMan = new Person();    불가능
> 형 변환 : 
> 	SpiderMan spiderMan = (SpiderMan) person  가능 

## 업캐스팅 (Upcasting)

> **자식 → 부모 타입으로 형변환**하는 것  
> 명시적 형변환 없이 **자동으로** 일어남

```
class Animal {
    void speak() {
        System.out.println("동물이 소리를 낸다");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("멍멍");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Animal animal = dog;  // ✅ 업캐스팅 (자동)
        animal.speak();       // O: Animal의 메서드 사용 가능
        // animal.bark();     // ❌ 컴파일 오류: 부모 타입이므로 자식 메서드 못 씀
    }
}

```


## 다운캐스팅 (Downcasting)

> **부모 → 자식 타입으로 형변환**하는 것  
> 명시적으로 형변환을 해줘야 하며, **조심해서 사용해야** 함


```
Animal animal = new Dog();   // 업캐스팅
Dog dog = (Dog) animal;      // ✅ 다운캐스팅 (명시적)
dog.bark();                  // O


Animal animal = new Animal();
Dog dog = (Dog) animal;      // ❌ 런타임 오류(ClassCastException)
```

## 바인딩(Binding)이란?

> **어떤 메서드나 변수에 접근할지를 결정하는 시점**을 말해요.

## **정적 바인딩 (Static Binding)**

**= 컴파일 시점에 결정됨**

| 항목     | 설명                                                     |
| ------ | ------------------------------------------------------ |
| 결정 시점  | 컴파일 시점                                                 |
| 적용 대상  | - `private`, `static`, `final`, `생성자` 메서드 등- 필드(변수) 접근 |
| 바인딩 방식 | 선언된 타입을 기준으로 호출 대상이 결정됨                                |
| 성능     | 빠름 (미리 결정되기 때문)                                        |
## **동적 바인딩 (Dynamic Binding)**

**= 실행(runtime) 시점에 결정됨**

| 항목     | 설명                                 |
| ------ | ---------------------------------- |
| 결정 시점  | 실행 시점                              |
| 적용 대상  | 오버라이딩된 **인스턴스 메서드**                |
| 바인딩 방식 | **실제 객체 타입을 기준으로 호출**              |
| 장점     | 다형성 가능, 유연한 구조                     |
| 단점     | 성능은 정적 바인딩보다 약간 느릴 수 있음 (실행 시점 결정) |


### 추상 클래스 

- 사용하는 이유 
	- 자식은 abstract method 를 재정의할 책임이 생긴다. 
	- 구현의 강제를 통해서 프로그램의 안정성을 높인다. 

- abstract 클래스는 객체를 생성할 수 없다.


### 인터페이스 

- 최고 수준의 추상화 단계임 
- 일반 메서드는 모두 abstract 형태로 되어있다.
- 모든 멤버변수는 public static final 이며 생략이 가능하다. 
- 모든 메서드는 public abstract 이며 생략이 가능함. 

- 클래스와는 다르게 인터페이스는 다중 상속이 가능하다. 
- 헷갈릴 메서드 구현이 아예 없어서 가능함 ㅋㅋ
- 어짜피 밑에서 다 구현해야함. 

- 인터페이스의 필요성??
	- 핵심은 ➝ **구현(implementation)이 달라도 표준화된 방식으로 다룰 수 있게 해준다**는 것!

- 원래는 아무것도 안됐었는데
- Java 8부터 **인터페이스에 `static method`와 `default method`가 추가**되었어.  
- 9 이후에는 private method 가 생겼다고 함. 
- 그 이유는 **라이브러리나 API를 설계할 때 유틸리티성 기능을 인터페이스 안에 넣고, 별도 구현 없이 직접 쓰게 하려고**야.