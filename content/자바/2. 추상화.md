### 객체지향 언어의 특징

관련 개념: [[1. 자바 기본]], [[3. 상속]], [[4. 캡슐화(데이터 은닉), 다형성]], [[추상클래스 인터페이스 차이]], [[추상 메서드]]

#### OOP is APIE
- 추상화 : 불필요한 세부 사항을 감추고 핵지먹인 기능만 간추려내는 것.
- 다형성 : 오버라이딩, 오버로딩, 부모 객체에 자식 객체를 담으면서 유연함을 보여줌.
- 상속 : 상위 클래스의 특징을 하위가 물려받아 기존 기능을 수정하지 않으며 사용, 확장성 뛰어남.
- 캡슐화 : 객체의 상태와 행위를 하나의 단위로 묶음. 내부 구현은 숨겨 무결성 보호. 유지보수 뛰어남. 


### 추상화와 구체화

- 우리가 흔히 설계하는 Class 가 추상화.
- 그 클래스를 new 를 이용해서 생성하고 그 값을 채워나가는게 구체화 

### 클래스 변수, 인스턴스 변수

```
public class Dog {
    String name;            // 인스턴스 변수
    static int totalDogs;   // 클래스 변수

    public Dog(String name) {
        this.name = name;
        totalDogs++;        // 모든 객체가 공유
    }
}

```

| 구분       | 인스턴스 멤버 변수     | 클래스 멤버 변수 (`static`)         |
| -------- | -------------- | ---------------------------- |
| 키워드      | 없음             | `static` 붙음                  |
| 소속       | **객체(인스턴스)**   | **클래스 자체**                   |
| 메모리 위치   | Heap           | Method Area (클래스 영역)         |
| 생성 시점    | 객체 생성 시        | 클래스 로딩 시 (프로그램 시작 시)         |
| 접근 방법    | `obj.var`      | `ClassName.var` 또는 `obj.var` |
| 객체마다 독립성 | O (각 객체마다 개별값) | X (모든 객체가 공유)                |

- 클래스 변수에 접근하고싶을때 클래스 명으로 접근. 
- 변수에 접근할때 객체이름으로도 접근은 가능하나 지양.
### 생성자 

- 객체 생성시 실행돼야 하는 작업을 정리한다. 
- 메서드와 비슷하나 리턴타입이 없음! 
- 이름은 클래스 이름과 동일하다. 
- 생성자 코드가 없으면 컴파일러가 기본 생성자를 제공한다. 
- 만약에 생성자가 있다면 기본 생성자는 생성되지 않음. 

### this 키워드

- 객체 자신을 가리킨다. 
- 원래 인스턴스 변수에 그냥 접근할 수는 있는데 사용하는 이유는 이름을 같게 사용하기 위해서임. 

- 이름이 다르면 언제든지 써서 접근할 수 있음. 
```
public class Dog {
    String breed;

    public void setBreed(String b) {
        breed = b;   // this 없어도 breed(인스턴스 변수)에 접근됨
    }

    public String getBreed() {
        return breed;  // this 없이도 접근 가능
    }
}

```

```
public static void main(String[] args) {
    ThisPerson person = new ThisPerson("홍길동", 20, true);
    System.out.println(person.getPersonInfo());

    // Cannot use this in a static context
    System.out.println(this.name);
}

```
- `main` 메서드는 `static` 메서드라서,
- `this.name`처럼 특정 객체를 참조하는 `this`를 쓸 수 없어서 오류가 나.
- 대신, `person.name` 또는 `person.getPersonInfo()`처럼 객체 이름을 써서 접근해야 해.


```
OverloadConstructorPerson(String name) {
    this(name, 0); // ✅ OK: 첫 줄에서 호출
    // this.name = name; ❌ 여기에 있으면 에러!
}
```
- 이런식으로 this 를 이용하면 생성자 안에서 다른 생성자로 불러올 수 있음.
```
OverloadConstructorPerson(String name) {
    this.name = name;       // ❌ 이게 먼저 나오면
    this(name, 0);          // ❌ 여기서 오류 발생 ("Constructor call must be the first statement in a constructor")
}
```
- 근데 주의할점은 무조껀 첫줄에 수행되어야 가능. \

### 자바의 초기화 블록

자바에는 필드를 초기화하는 방법이 3가지가 있어:

1. **static 초기화 블록 (static initializer block)**
    - 클래스가 처음 로드될 때 **딱 1번 실행**됨
    - `static { ... }` 형태
    - **static 변수 초기화**에 주로 사용됨
        
2. **인스턴스 초기화 블록 (instance initializer block)**
    - 객체가 생성될 때 **생성자보다 먼저 실행됨**
    - `{ ... }` 형태 (static 없이)
    - **생성자 중복 코드를 줄이기 위한 용도**로 사용
        
3. **생성자 (Constructor)**
    - 객체 생성 시 실행됨


```
public class LoadingSequenceTest {
    static int SIZE;
    static int[] sArray = new int[SIZE];  // (1)
    int[] iArray = new int[SIZE];         // (2)

    static { SIZE = 10; }                 // (3)
    { SIZE = 2; }                         // (4)
    public LoadingSequenceTest() { SIZE = 1; }  // (5)

    public static void main(String[] args) {
        System.out.println("SIZE: %d".formatted(SIZE));
        LoadingSequenceTest lst = new LoadingSequenceTest();
        System.out.println("sArray 길이: %d".formatted(sArray.length));
        System.out.println("SIZE: %d".formatted(SIZE));
        System.out.println("iArray 길이: %d".formatted(lst.iArray.length));
    }
}

```

- 순서
	- 클래스 맴버변수 -> 클래스 초기화 블록 - > 인스턴스 맴버변수 -> 인스턴스 초기화 -> 생성자