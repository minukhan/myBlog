### Variable 이란? 

- 자료를 저장하기 위한 메모리 공간(그릇) 으로 변수에 값을 할당 후 사용. 
	- 타입에 따라 크기가 달라진다. 
	- 값이 아니라 타입에 따라 크기가 다르다. 

### 타입이란?

- 데이터의 형태
- 데이터 타입에 따라 크게 2가지로 분류된다. 
	- 기본형 : 
		- 미리 정해진 크기의 데이터 표현
		- 변수에 값 자체를 저장한다. 
	- 참조형 :
		- 크기가 미리 정해질 수 없는 데이터의 표현.
		- 변수에는 실제 값을 참조할 수 있는 주소만 저장한다. 

### 기본형의 크기

- boolean : 1Byte
- short : 2Byte
- int : 4Byte : 정수형의 기본형 
- long : 8Byte
- float : 4Byte
- double : 8Byte : 실수형의 기본형 
- char : 2Byte

### 자바는 변수 선언시 타입을 명시해야함. (strong typed language)

- var 변수를 사용할 수 있음.

```
public static void main(String[] args) {
    int i = 10;
    var a = 1;             // int로 추론됨
    var str = "Hello";     // String으로 추론됨
    var list2 = new ArrayList<>();         // 타입 추론
    var list3 = new ArrayList<String>();   // String 리스트로 추론
}

```
##### 주의할 점:
- Java는 여전히 **strongly typed language**입니다. 즉, **타입이 한 번 결정되면 바뀌지 않습니다**.
- JavaScript처럼 실행 중 타입이 바뀌는 것은 절대 아닙니다.

### String 은 기본형이 아닌 참조형이다. 

```
String var = "Hello"
String str2 = new String("Hello")
```
- 이렇게 둘다 가능하다.
- 그러나 차이점이 있음. 
	- 1번처럼 생성하면 문자열 풀(String Pool ) 에 저장되고 
	- new 로 생성하면 Heap 에 저장된다.

### 정수 계산할때 오버플로우를 조심해야한다. 

### 실수의 연산은 정확하지 않다. 

- float 는 double 보다 정밀도가 떨어지기 때문에 0.9로 잘 나오는 것 처럼 보임. 
- 그러나 정확하게는 0.9가 아니라 조금 오차가 있어서 double 로 하면 더 정밀한 결과가 나오는것.

- 만약 정확한 소수 계산을 하고싶다면 BigDecimal 객체를 만들어서 계산을 해야한다. 
	- 주로 은행 이런곳에 사용됨.


### 형 변환

- 변수의 형을 다른 형으로 변환하는 것. 
- 기본형은 기본형끼리. 참조형은 참조형끼리만 변환 가능. 
- boolean은 다른 기본형과 호환되지 않는다!!
-  기본형에서 객체형으로 형 변환하는건 Wrapper 클래스를 이용하면 가능. 

### **작은 타입 → 큰 타입**:

✔️ **묵시적(자동) 형 변환**  
별도로 `(형)` 안 써도 자동으로 변환됨

`byte b = 10; int i = b;   // OK! (byte → int 자동 변환)`

---
### 🔸 **큰 타입 → 작은 타입**:

❗ **명시적(강제) 형 변환** 필요  
형을 `(타입)`으로 **명시해줘야 함**, 안 그러면 **컴파일 오류** 발생

`int i = 100; byte b = (byte)i;   // OK! 명시적 형 변환`

단, 이 경우 **데이터 손실**이 생길 수 있으니 주의해야 합니다.

`int i = 130; byte b = (byte)i; System.out.println(b); // 출력: -126 (byte는 -128~127 범위라 오버플로우 발생)`
![](https://i.imgur.com/5NoC1DD.png)


### 오버플로우 예제

![](https://i.imgur.com/bjQGec4.png)
- 값을 계산할때 int 면 오버플로우가 나는것.
- 받는 객체가 long 인건 상관이없고 계산하는 주체의 타입이 중요함. 
- 계산 순서도 중요함.

### 기본형에서 객체형으로 형 변환하는건 메서드를 사용하면 할 수 있음.


### 연산 결과들 

```
byte b1 = 10;
byte b2 = 20;
byte b3 = b1 + b2;  // ❌ 오류!
```

### 왜 오류가 날까?
- `byte + byte`를 하면, Java는 자동으로 **int로 변환**해서 계산합니다.
- 그래서 `b1 + b2`의 결과는 `int` → `byte b3`에 **int를 넣으려 해서 오류 발생**
- `byte + byte → int`
- `short + short → int`

**두 개의 피연산자 중 더 큰 타입으로 변환 후 연산**

- `int + long → long`
- `float + double → double`
- `int + double → double`
![](https://i.imgur.com/gUlzUuQ.png)

- 기본형이 소수점은 double 이기 때문에 마지막에 에러나는 것. 

![](https://i.imgur.com/BytdLcL.png)

- |  이게 하나면 뒤에까지 수행한다. 
- 그러나 || 이게 2개라면 만약 앞에가 True 면 뒤에는 수행하지 않는다. 

### 조건문에는 boolean 타입만 들어갈 수 있음. 

### Switch 문에는 float, double, long 같은 타입은 불가능하다. 
- `switch` 문은 기본적으로 **정수형 타입(int, char, enum)** 을 받는다.

### Switch 가 반환값이 있을 수 있다.

##### 반환값 있는 `switch` 표현식 (Expression)

- `switch`가 **값을 만들어서 변수에 할당하거나, 다른 표현식 안에 들어갈 때**는 반환값이 있는 `switch` 표현식이야.
- 주로 **Java 12 이상**에서 도입된 문법이고, `switch` 자체가 값으로 사용됨.
```
String dayName = switch(day) {
    case 1 -> "Monday";
    case 2 -> "Tuesday";
    default -> "Unknown";
};

```
##### 반환값 없는 `switch` 명령문 (Statement)

- 그냥 기존의 `switch` 문법으로, **분기만 하고 값 할당이나 반환이 없는 경우**.
- 단순히 `case`별로 명령문을 실행하고, 보통 `break`를 써서 빠져나감.

```
switch(day) {
    case 1:
        System.out.println("Monday");
        break;
    case 2:
        System.out.println("Tuesday");
        break;
    default:
        System.out.println("Unknown day");
}

```


### 배열을 사용하는 이유

- 변수의 갯수 증가, 코드의 길이 증가.
- 반복문 적용 불가
- 정의 :
	- 동일한 타입의 데이터 0개 이상을 하나의 연속된 메모리 공간에서 관리하는 것. 
- 배열을 생성하면 대상 자료형의 기본값으로 default 초기화가 진행됨 
- 참조 변수는 null 로 초기화가 된다. 

### 배열을 만드는 방법

- 생성과 동시에 할당한 값으로 초기화 
```
int[] b = new int[]{1,2,3,4,5};
int[] c = {1,203,2,3,5};
```
- 선언과 생성을 따로 처리할 경우에는 초기화 주의
```
int[] point;
points = {1,2,4,56} 이거는 안됨. 컴파일 오류.

int[] b;
b =  new int[]{1,2,3,4,5}; 이거는 가능. 

```

- 배열은 다른 값으로 변경은 가능하나 삭제하거나 삽입할 수 없음. 크기는 불변.


```
int[][] intArray4 = new int[4]{1, 2, 3}; 컴파일 오류. 이런 문법은 없다. 

int[][] intArray5 = new int[][] {{1,2,3}, {1,2,3}, {1,2,3}, {1,2,3}}; 가능

int[][] intArray6 = {{1,2,3}, {1,2,3}, {1,2,3}, {1,2,3}}; 가능.
 
int[][] intArray3 = new int[4][]; 가능. 열을 먼저 만들어놓고 행을 동적으로 처리 가능.
 
int[] intArray2[] = new int[][3]; 불가능. 열을 먼저 만들어야함. 

int intArray[][] = new int[4][3]; 가능 
```

 







