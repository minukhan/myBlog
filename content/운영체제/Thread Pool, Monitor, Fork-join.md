

### Thread Pool 이란?

- 미리 정해진 개수의 스레드를 생성해서 관리하는 방식. 
- 맨날 작업할때 새로 만들고 없애고 그러지말고 이미 생성된 Pool 에서 스레드를 가져다 쓰는것. 
- 작업이 끝났다? -> 다시 Pool 로 돌아가는것임. 

> [!note] 핵심
> “**미리 만들어놓고 재사용하는 방식**”이 핵심입니다.


##### 장점? 

- 스레드 생성, 소멸에 드는 오버헤드를 줄여서 어플리케이션 성능 향상.

##### 그러면 스레드 수는 어떻게 결정할까?

- CPU-bound 작업
	- 계산 중심의 작업이라면 CPU 코어 수와 비슷하게 설정한다함. 
- I/O - bound 작업 
	- 만약 대기시간이 길다? CPU 코어 수보다 많이 설정. 

>[!note] 정리
>
>CPU를 많이 사용하는 작업이다? CPU 코어수랑 비슷하게.
>만약 IO 작업이 많아서 기다리는 시간이 많다? 더 많이!

#### I/O 작업이 많으면 뭐하는데? 스레드 많이필요해?

- 이제 CPU-Bound 작업을 하다가 I/O 작업을 할떄 담당하던 thread는 대기상태로 변한다.
- 이때 다른 스레드가 있다면 다른 작업을 처리할 수 있는것. 


### Monitor 

- 상호 배에와 조건 동기화를 지원하는 동기화 매커니즘이다. 
- 공유자원과 그 자원에 접근하는 메서드들을 하나의 캡슐화된 단위로 묶는다. 
- 약간 뮤텍스랑 비슷한데 캡슐로 관리하고, 운영하는데 차이가 있다고 함.
- 가장 큰 차이점은 하나 thread 가 끝나면 다른 스레드에게 알려주고 이런 운영과정이 더 들어가있는게 모니터인듯. 

- Mutex = “한 번에 하나만 접근”
- Monitor = “한 번에 하나만 접근 + 조건 맞을 때 기다리고 깨움 + 자원 캡슐화”
- 상황에 따라 선택: 단순이면 Mutex, 조건 동기화 필요하면 Monitor


### 현대에서는 어떤식으로 사용??

### 운영체제 수준에서

1. **Mutex / Spinlock**
    
    - 커널에서 **단순 상호 배제**용으로 많이 사용
    - CPU 코어가 많을 때 짧은 시간 동안만 잠금 걸고 해제하는 경우 Spinlock이 효율적
    - 프로세스 내부 공유 자원 보호, 커널 자료구조 보호
        
2. **Semaphore**
    
    - 프로세스나 스레드 간 **자원 수 제한** 용도로 자주 사용
    - 예: 디스크 I/O, 네트워크 버퍼, 프린터 등 **한정된 장치 접근 제어**
        
3. **Monitor / Condition Variable**
    
    - 고수준 동기화, 주로 **멀티스레드 라이브러리**에서 사용
    - Java, C# 같은 언어에서는 Monitor가 내장되어 있음
    - 조건 동기화가 필요한 경우 (예: 생산자-소비자 패턴, 스레드 풀) 많이 활용


### 현실적인 사용 패턴

- OS 내부: **Mutex + Semaphore**  
    → 빠른 상호 배제와 자원 접근 제어 중심
    
- 애플리케이션 레벨 (Java, C#, Python): **Monitor / Condition Variable**  
    → 안전하게 자원 접근 + 조건 동기화 편리하게 구현 가능

### Fork-Join

- 재귀적인 분할정복 방식의 병렬처리 프레임워크임. 
- fork
	- 큰 작업을 여러개의 하위 작업으로 분할한다.
- join 
	- 분할된 하위 작업들의 결과를 모두 취합해서 결합한다. 


### 정렬 전략

- 대량의 데이터를 정렬할 떄, 안전하고 좋은 **병렬 정렬 알고리즘**을 사용하는 것. 

#### 왜 병렬 정렬을 씀?

- 여러개의 스레드를 이용해서 빠르게 정렬하기 위함. 

##### 그래서 어떤 전략이 효율적?

- 병렬 퀵 정렬. 

- 배열을 2개로 나눈다음에 왼쪽, 오른쪽 각각 새로운 스레드로 정렬한다. 
- 이때 모든 작업이 끝나면 결과를 합친다. 

