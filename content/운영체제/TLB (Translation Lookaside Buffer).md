
### TLB 란?

- 메모리 접근을 빠르게 할 수 있도록 캐시역할을 해주는 친구
- MMU 는 가상 메모리 주소를 물리적 메모리 주소로 매핑해주는 역할을 하는 장치.
- 여기서 도와주는게 TLB입니다. 
- 일종의 캐시라고 생각하면 될 것 같고 만약 이 TLB가 없다면 페이지 테이블에 가서 실제 물리적 메모리 주소를 읽어와야하는데 이럴 필요없이 TLB 에 만약 원하는 주소가 있다면 캐시 히트로 바로 읽어와서 오버헤드를 줄일수 있습니다. 

#### 왜빨라져?

### TLB는 무엇인가요?

- TLB는 자주 참조되는 가상 -> 물리 주소 정보를 저장하는 작고 빠른 특수 하드웨어 캐시
- 느리고 저렴한 DRAM 대신 SRAM 을 사용한다고 함. 
- 원래 페이지 테이블에 가서 물리적 주소 정보를 읽어와야 하는데 근처에 위치해 있고 빨라서 만약 캐시 히트가 된다면 오버헤드가 확 준다고 함. 

### MMU 가 뭐야??

- CPU 가 생성하는 가상 주소를 실제 메모리 주소로 변환해주는 핵심적인 하드웨어
- 일반적으로 CPU 내부에 통합되어있다고 함. 
- 단순하게 주소 변환만 해주는게 아니다. 안정성 측면에서도 좋음.
- 각 프로세스마다 영역을 할당해주는데 다른 프로세스가 접근하려하면 막아주는 역할. 

### TLB를 왜써??

- MMU 는 물리적 메모리 주소를 얻기 위해서 페이지 테이블을 방문하게 되는데 이게 시간이 2번들어가게 됨으로 가상 메모리 효율이 안나옴.

-> 그래서 나온게 TLB 임. 

- 자주 사용되는 주소 변환 정보를 캐싱함으로써 주 메모리에 있는 거대한 페이지 테이블을 참조하는 느린 과정을 생략하게 된다. 
- 이게 효율이 높은 이유는 또 지역성과 연결된다. 

### TLB 와 MMU는 물리적으로 어디에??

- CPU 옆에 붙어있거나 내장되어있다. 
- 빠르게 주소 변환을 해야하기 때문. 



### TLB 관점에서, Context Switching 발생 하면?? 

- 만약 컨텍스트 스위칭이 일어나게되면  A에 있던 주소 변환 정보는 B에는 완전히 무의미하고 부정확한 데이터가 된다. 
- 이 상태를 방치하고 B가 메모리에 접근하면 엉뚱하게 접근하게됨. 
- 이러한 문제를 방지하고자 2가지 방법이 있음.

#### 해결책1 : TLB 플러시

- 가장 간단하고 직접적인 해결책은 그냥 컨텍스트 스위칭이 일어나면 TLB 비워버리기.
- 아무것도 없으니까 충돌 위험이 없어짐. 
- 근데 효율이 안좋음. 메모리 접근 속도가 느려질 것. 

#### 해결책 2 : 주소공간 식별자를 두기. 

- TLB 플러시의 성능 저하를 극복하려면 다 없애버리면 안됨. 그래서 각 프로세스에 고유번호를 둔다. 
- 이떄 TLB 에는 가상주소 + ASID(고유번호)로 검색하도록 하고 이때 대응되는 물리주소를 반환하는 구조로 동작한다.
- 그러니까 Key를 id 추가해서 검색하겠다 이거임. 이러면 다른 메모리 접근할떄 key가 다르니까 이상한 접근을 막을 수 있음. 그리고 완전히 삭제 안해도 되니까 빠르게 다시 돌아왔을때 유효한 주소변환 정보가 남아있을 것.  


### 코어가 여러개면 TLB 어떻게 관리??

- 먼저 코어마다 자체 TLB 를 두어서 독립적으로 관리한다. 
- 근데 만약 페이지 테이블이 수정됐다??
	-> TLB 에는 오래된 정보가 남아있을 수 있음. 
	-> 이때 다른 코어가 그 정보를 사용하면 메모리 접근 오류가 발생한다. 

#### 해결책 1 : TLB Shotdown

- 하나의 코어가 공유 페이지 테이블을 변경한다면 해당 항목을 자신의 TLB 에 캐시하고있을 수 있으니까 다른 코어에게 이 사실을 알려서 해당 TLB를 사용 못하게끔. (무효화)
- 보통 IPI (프로세서 간 인터럽트) 를 전송해서 무효화 시킨다고 함. 
- 오버헤드가 장난 아니라고 함. 엄청 큼. 
