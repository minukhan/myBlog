
### 시스템 콜이란 ?

- 응용 프로그램이 운영체제의 기능을 사용하기 위해 커널에게 요청하는 인터페이스. 
- 운영체제를 통해 간접적으로 요청하는 방법. 
- 보통 일반 프로그램은 직접 하드웨어에 접근이 안된다. 
### Dual Mode 개념 ( 이중모드 )

- 운영체제는 CPU를 두가지 권한 수준으로 나눠서 동작시킴. 
### CPL (Current Privilege Level)? 

- 현재 실행중인 코드의 권한 레벨을 나타낸 것. 
- 이거에 따라 특정 자원에 접근할 수 있는 권한을 설정. 

| 모드                      | 이름          | 권한 수준(CPL)    | 특징                                                                        |
| ----------------------- | ----------- | ------------- | ------------------------------------------------------------------------- |
| **유저 모드** (User Mode)   | 일반 프로그램     | CPL=3 (가장 낮음) | - 하드웨어 직접 접근 불가<br>- 제한된 명령어만 실행 가능<br>- 메모리 접근 범위 제한                     |
| **커널 모드** (Kernel Mode) | 운영체제(OS 커널) | CPL=0 (최고 권한) | - 모든 명령어 실행 가능<br>- 모든 메모리, 하드웨어 접근 가능<br>- 장치 드라이버, 파일 시스템, 네트워크 등 직접 제어 |
### 왜 나눌까? 

- 유저 프로그램이 메모리나, 하드웨어를 마음대로 건드리면 시스템 전체가 다운됨. 
- 그래서 안정성을 위해서 운영체제만 중요한 자원에 접근할 수 있도록 제한을 두는 것. 

### 시스템 콜 실행 과정이 어떻게 돼? 

- 유저 모드에서 요청. -> trap 명령 혹은 소프트웨어 인터럽트를 통해 CPU 모드에서 커널 모드로 전환시킨다. 
	- 이때 권한 레벨 변경
	- 스택 변경 - 이거 바로 뒤에서 추가적으로 설명해드리겠습니다. 
	- PC(프로그램 카운터) 변경이 이루어진다. 

- 커널에서 운영체제의 기능을 수행해달라고 요청받은 작업을 여기서 처리. 
- 그리고 결과를 프로그램에 반환하고 다시 커널 -> CPU 모드로 전환후 유저 모드로 돌아온다.

### 동작 과정 전반적으로 보자면 

### **1. 사용자 모드 (mode bit = 1)**

- **user process executing**: 일반 애플리케이션 프로그램이 실행되는 상태입니다.
- CPU는 **mode bit = 1**로 동작하며, 하드웨어 자원(메모리, I/O 장치 등)에 직접 접근하지 못합니다.
- 예: 워드프로세서, 웹브라우저, 게임 실행 중.
---

### **2. 시스템 호출 요청**

- 프로그램이 OS 서비스를 요청하면 `system call`을 호출합니다.
- 예: 파일 읽기/쓰기, 네트워크 전송, 프로세스 생성 등.
- 이 시점에 **트랩(trap)** 이 발생하면서 CPU 모드가 커널 모드로 전환됩니다.
- 이때 메모리에서는 데이터 복사 및 이동이 발생한다. 뒤에서 좀 더 . 
---

### **3. 커널 모드 (mode bit = 0)**
- OS 커널이 CPU를 제어하는 특권 모드입니다.
- 그림의 `execute system call` 단계에서 커널이 요청된 작업(예: 파일 읽기)을 수행합니다.
- 이 상태에서는 모든 하드웨어와 메모리에 직접 접근 가능합니다.

---

### **4. 반환 (return from system call)**

- 커널 작업이 끝나면 CPU 모드가 다시 **mode bit = 1**로 변경됩니다.
- 제어가 사용자 프로그램으로 돌아가고, 애플리케이션이 이후 작업을 이어서 수행합니다.

#### 메모리 구조 페이지

- 이 사진을 왜 가져왔냐면 메모리안에서 어떤 과정이 일어나고 데이터 이동이 일어나는지 간단하게 알면 좋을 것 같아서 가져왔습니다. 
- 먼저 그림을 보시면 유저 영역과 커널 영역이 이렇게 분리가 되어있습니다. 
- 위에 모드를 분리해놓은 것처럼 안정성을 위해서 따로 분리시켜놨고 커널 영역에는 OS 자료구조, 커널에서의 작업할때 필요한 데이터를 저장하는 공간, 커널 스택, 등이 여기에 속해있습니다. 마찬가지로 사용자 모드에서는 커널영역을 접근할 수 없다했는데 그 커널 영역이 이 메모리 영역을 말합니다. 

# 트랩발생 페이지 
## 데이터 이동 관점에서

- 사용자 공간(JVM, 네이티브 메소드) ↔ 커널 공간(OS)
    - **보안 및 안정성**을 위해 필요
    - 커널은 사용자 공간 데이터를 직접 접근하지 않고, **복사(copy)**를 통해 처리
    - 시스템 콜 완료 후 결과를 다시 사용자 공간으로 복사

- 커널은 필요한 데이터를 **사용자 공간에서 커널 공간으로 복사**합니다.

여기서 **커널이 직접 사용자 공간 메모리에 접근하면 위험**합니다. 이유:
1. 보안적인 측면에서 사용자 프로그램이 커널 메모리를 임의로 접근하는 것을 막기 위함.
2. 안정성의 측면에서는 사용자 프로그램이 버퍼를 잘못 제공하면 커널이 크래시날 수 있음.
    
- 커널에서 계산한 데이터를 **커널 공간에서 사용자 공간으로 복사**해야 함.
    
- 사용자 스택에 있는 버퍼를 안전하게 채워주기 위해서입니다.
  따라서, 
- 커널에서 계산한 데이터를 **커널 공간에서 사용자 공간으로 복사**해야 함.
- 사용자 스택에 있는 버퍼를 안전하게 채워주기 위해서입니다.

--- 
### 자바 페이지 

- “자바는 메모리를 직접 할당·해제하지 않는다.”
- “하드웨어나 운영체제 API에 직접 접근하는 명령어를 쓸 수 없다.” 어 그러면 시스템 콜로 
- 커널모드로 변경해서 OS 의 도움을 받는 작업들을 처리한다고했는데 어떻게 접근해야하지? 자바에서는? 
- 그러면 ‘파일 읽기’, ‘네트워크 요청’, ‘스레드 생성’ 같은 OS 자원 접근은 어떻게 할까?

**그럼 이제 궁금증이 생겼다. 자바 애플리케이션은 JVM을 통해 운영체제와 상호작용한다. JVM은 어떻게, 어디서 운영체제와 상호작용하고 있는가**?? 

**JVM의 역할 등장**

- JVM이 자바 바이트코드를 해석·실행하면서, OS와의 모든 인터페이스를 대신 처리한다.
- 이때 **운영체제와 직접 대화하는 구간**이 바로 네이티브 코드 실행 부분이다.

#### 네이티브 언어란? 
- C/ C++ 같은 언어. 
- JVM이나 인터프리터 같은 중간 계층 없이 **바로 하드웨어/OS에서 동작**할 수 있습니다.

## JVM 스택과 네이티브 메소드 스택

- **JVM 스택**
    
    - 자바 바이트코드 실행 전용.
    - **JVM 내부 규칙(operand stack, frame 구조, GC 관리 등)**에 맞춰 구성.
    - CPU나 OS에 직접 맞춘 게 아니라, JVM이라는 **가상머신 규약**에 맞춘 추상화된 스택.
        
- **네이티브 메소드 스택**
    - OS와 CPU 아키텍처에 맞춘 **실제 네이티브 코드(C/C++) 호출**용.
    - 로컬 변수, 레지스터 저장, 호출 규약(calling convention) 등 **플랫폼 종속적인 방식**으로 구성.
    - JVM이 아니라 OS와 하드웨어가 이해할 수 있는 레이아웃이다..

이거 사이에서 변환하는 과정을 담당해주는게 자바에서 JNI 가 있다. 

**JNI**는 자바에서 **네이티브 코드(C, C++ 등)와 상호작용**할 수 있게 해주는 표준 인터페이스입니다.
- 목적: 자바가 제공하지 않는 **저수준 기능**(운영체제 기능, 하드웨어 접근, 성능 최적화)을 사용할 수 있도록 함.


---

