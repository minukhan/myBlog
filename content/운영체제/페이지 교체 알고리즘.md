
### 페이지 교체 알고리즘

- 메모리에 비어있는 물리 프레임이 없으면 운영체제는 방출시킬 메모리를 선택한다. 
- 이떄 어떤놈을 방출시킬까?? -> 페이지 교체 알고리즘

### OPT (Optimal) 알고리즘

- 미래를 예측해서 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식. 
- 가장 이상적이나 실제로 불가능하다. 
- 보통 현식적인 알고리즘의 성능을 평가하기 위한 기준선으로 사용한다. 

### FIFO 알고리즘

 - 가장 먼저 온거 가장 먼저 방출
 - 성능이 별로 안좋음. 현대 OS 에서는 거의 안씀. 

### LRU (Least Recently Used) 알고리즘 

- 목표가 미래를 예측하는것. 그러나 불가능. 
- 지역성의 원리가 예측하는데 유용한 단서가 될 수 있음. 이때 이걸 이용한게 -> LRU

- 특히 시간적 지역성 원리에 기반한다. 
- 간단하게 최근에 참조된 메모리 영역이 다시 또 참조될 가능성이 높다고 가정하고 가장 오래 된 메모리 영역을 방출. 

### 어떻게 LRU 구현할까? 

- 타임 스탬프 
	- 모든페이지 테이블 항목에 접근 시간을 기록한다. 
	- 이렇게 해버리면 전체 테이블 스캔해서 가장 짧은 시간을 찾아야해서 오버헤드가 큼.
- 스택 or 연결 리스트 
	- 참조될때 맨 위로 올린다. 스택에. 
	- 그러면 가장 오랫동안 사용되지 않은 페이지는 맨 아래가 된다. 이떄 HashMap 과 이중 연결 리스트를 조합해서 효율적인 구현이 가능하다 함. 

### LRU 의 한계와 Clock 알고리즘

- LRU의 가장 큰 단점은 완벽한 구현에 따르는 막대한 비용이라 함. 
- 모든 메모리 접근마다 타임스탬프, 연결리스트 갱신하는건 너무 비용이 크다. 

### 그러면 어떻게하라고? 

- 그래서 나온게 Clock 알고리즘. 
- 이 알고리즘은 적은 오버헤드로 LRU를 근사하는 매우 효율적인 방법 이라고 한다. 

### 어떻게 동작하길래??

- 각 프레임마다 하나의 참조비트를 사용한다. 
- 페이지 접근이 일어나면 자동으로 참조비트를 1로 설정한다. 이떄 모든 페이지 프레임을 
- 원형 큐로 관리해서 시곗바늘 포인터가 이 큐를 순회한다.

- 원형으로 관리해서 최근에 접근하면 1로 바꾼다. 이말임. 


### 어떤 질문들이 들어올까? 

## 페이지 교체 알고리즘이란 무엇이며, 왜 필요한가요?

- 가상 메모리 시스템에서 물리 메모리가 가득 찼을때, 공간이 부족하네? 새로운 공간을 확보하기 위해서
- 어떤 페이지를 물리 메모리에서 내보낼지 결정하는 운영체제의 정책!
- 이게 필요한 이유는 요구 페이징 기법 때문이다.
    - 요구 페이징은 프로세스의 모든 부분을 메모리에 올리는 대신 실제로 필요한 페이지만 그때 그때 가져오기 때문.

### 벨라디의 변칙이 무엇이고 왜 발생할까요??

- 벨라디의 변칙은 프로세스의 할당된 물리 메모리 프레임 수를 늘렸음에도 페이지 폴드 수가 오히려 증가하는 비정상적인 현상
- 자원을 더 제공했는데 더 효율이 안나오는 상황이다. 왜 일어날까?
- 주로 FIFO 알고리즘에서 많이 일어난다. 사용패턴이나 중요도를 전혀 고려하지 않고 순서로만 결정하기 때문에
- LRU 나 OPT 같은 스택 기반 알고리즘은 이 현상을 겪지 않는다. 포함속성을 만족하는데,

// 간단하게 보면 될듯. 그냥 FIFO 알고리즘 안좋아서, 더 증가하는 경우도 있다! 라고 넘어가자. 
## 더 증가할 수 있다는 증명?

**참조열: `1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`**

(페이지 폴트가 발생하면 `*`로 표시합니다.)

---

### **사례 1: 프레임이 3개일 경우 (총 9번 페이지 폴트)**

메모리 상태는 큐(Queue)처럼 동작합니다. `[가장 오래됨, 중간, 가장 최신]` 순서입니다.

|요청 페이지|메모리 상태 (프레임 3개)|설명|
|---|---|---|
|**1**|`[1]`|_1`*`_**|
|**2**|`[1, 2]`|_2`*`_**|
|**3**|`[1, 2, 3]`|_3`*`_** (메모리 꽉 참)|
|**4**|`[2, 3, 4]`|_4`*`_** (가장 오래된 `1` 교체)|
|**1**|`[3, 4, 1]`|_1`*`_** (가장 오래된 `2` 교체)|
|**2**|`[4, 1, 2]`|_2`*`_** (가장 오래된 `3` 교체)|
|**5**|`[1, 2, 5]`|_5`*`_** (가장 오래된 `4` 교체)|
|**1**|`[1, 2, 5]`|Hit (변화 없음)|
|**2**|`[1, 2, 5]`|Hit (변화 없음)|
|**3**|`[2, 5, 3]`|_3`*`_** (가장 오래된 `1` 교체)|
|**4**|`[5, 3, 4]`|_4`*`_** (가장 오래된 `2` 교체)|
|**5**|`[5, 3, 4]`|Hit (변화 없음)|
||||

**결과:** 총 **9번**의 페이지 폴트가 발생했습니다. 여기서 페이지 `5`가 들어온 후, 메모리 상태는 `[1, 2, 5]`가 되었습니다.

---

### **사례 2: 프레임이 4개일 경우 (총 10번 페이지 폴트)**

이제 프레임이 하나 더 늘어났습니다. 어떻게 상황이 바뀌는지 보겠습니다.

|요청 페이지|메모리 상태 (프레임 4개)|설명|
|---|---|---|
|**1**|`[1]`|_1`*`_**|
|**2**|`[1, 2]`|_2`*`_**|
|**3**|`[1, 2, 3]`|_3`*`_**|
|**4**|`[1, 2, 3, 4]`|_4`*`_** (메모리 꽉 참)|
|**1**|`[1, 2, 3, 4]`|Hit (변화 없음)|
|**2**|`[1, 2, 3, 4]`|Hit (변화 없음)|
|**5**|`[2, 3, 4, 5]`|_5`*`_** (가장 오래된 `1` 교체)|
|**1**|`[3, 4, 5, 1]`|_1`*`_** (가장 오래된 `2` 교체)|
|**2**|`[4, 5, 1, 2]`|_2`*`_** (가장 오래된 `3` 교체)|
|**3**|`[5, 1, 2, 3]`|_3`*`_** (가장 오래된 `4` 교체)|
|**4**|`[1, 2, 3, 4]`|_4`*`_** (가장 오래된 `5` 교체)|
|**5**|`[2, 3, 4, 5]`|_5`*`_** (가장 오래된 `1` 교체)|

**결과:** 총 **10번**의 페이지 폴트가 발생했습니다. 프레임이 늘었는데도 페이지 폴트가 오히려 1번 더 일어났습니다.

- 이 결과들만 보면 오히려 메모리 프레임이 증가되었는데도 페이지 폴드가 증가되는 걸 볼 수있음.
    
- 이떄 이러한 현상을 벨라디의 변칙이라고 한다.
    
- 결론적으로는 메모리 프레임 수를 증가시켜서 페이지 폴트가 증가된거긴 하지만, 벨라디의 변칙은 '프레임이 늘어난 것'이 직접적인 원인이 아니라 FIFO 알고리즘이 너무 쓰레기라 이런 현상이 생길 수 있고 이런 현상을 벨라디의 변칙이다. 라고 알아두면 될듯.
    

### 대표적인 페이지 알고리즘 FIFO, LRU, OPT 를 설명하고 장단점을 설명해라.

- OPT : 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘. 가장 이상적인 알고리즘이고 실제로 구현하기 힘듬.
- FIFO : 가장 단순한 방식으로 먼저 들어왔으면 먼저 나가라는 알고리즘. 구현이 매우 간단하고 오버헤드가 별로 없으나 벨라디의 변칙 현상이 발생할 수 있다함. \
- LRU : 가장 최근에 참조된 페이지는 미래에도 다시 참조될 가능성이 높으므로 놔두고 가장 오래된 페이지를 꺼내버리는 알고리즘
    - 이는 시간적 지역성과 연관이 있고 OPT에 근접하는 우수한 성능을 보여주긴 하나, 완벽하게 구현하는게 오버헤드가 매우 크다.

### 완벽한 LRU 알고리즘은 구현이 어렵다고 했는데 그 이유가 무엇이며 , 실제 운영체제에서는 어떤식으로 이를 해결했나요??

- 완벽한 LRU 구현이 어려운 이유는 모든 메모리 접근을 추척하는 데 드는 막대한 오버헤드 때문.
- 2가지의 대표 구현 방식이 있다.
    1. 타임스탬프 방식
        1. 각 페이지마다 마지막 접근 시간을 기록, 모든 메모리 읽기, 쓰기 동작마다 타임스탬프 값을 갱신해야 함을 의미하며 모든 연산을 매우 저하시킴.
    2. 스택 방식
        1. 페이지들을 이중연결 리스트로 관리하여 참조될때마다 리스트의 맨 위로 옮긴다. 이때 접근하는 오버헤드가 너무 크다.
- 이런 문제들때문에 실제 운영체제에서는 LRU를 저비용으로 흉내내는 근사 알고리즘을 사용한다.
    1. 클럭 알고리즘
        1. 원형 큐 형태로 관리하고 참조비트를 활용해서 메모리 접근의 효율을 높혔다.

### 현대 운영체제인 리눅스와 윈도우는 페이지 교체 정책에서 어떤 차이점을 보이나요??

- 결론적으로 가장 큰 차이점은 리눅스는 전역교체, 윈도우는 지역교체를 기반으로 한다.
- 리눅스 (MGLRU)
    - active 와 inactive 두개의 리스트를 사용하는 LRU 근사 방식을 사용함.
    - 커널 6.1 부터는 구글이 개발한 MGLRU(Multi-Generational LRU) 를 도입
    - 단순하게 활성, 비활성 이렇게 나누는게 아니라 여러 세대로 나누어서 좀더 세밀하게 추적하고 관리한다.
    - 이를 통해 메모리 압박 상황에서 더 정확한 교체 결정을 내리고 성능을 향상시킨다.
- 윈도우 (지역교체 - 워킹셋 모델)
    - **워킹셋(Working Set)** 모델을 기반으로 작동.
    - 워킹셋이란 프로세스가 현재 실행을 위해서 필요로 하는 집합을 의미한다.
    - 윈도우는 각 프로세스에 최소/최대 워킹셋 크기를 할당하고 메모리가 부족하면 워킹셋을 정리하여 오랫동안 사용되지 않은 페이리를 제거하는 방식으로 동작
    - 특징으로 제거된 페이지는 즉시 버려지지 않고 전역 대기목록으로 이동해서 일종의 캐시 역할을 한다.
    - 만약 해당 페이지가 바로 필요해지면 디스크 I/O없이 빠르게 복원할 수 있어서 효율적이라고 함.