
### 페이지 교체 알고리즘

- 메모리에 비어있는 물리 프레임이 없으면 운영체제는 방출시킬 메모리를 선택한다. 
- 이떄 어떤놈을 방출시킬까?? -> 페이지 교체 알고리즘

### OPT (Optimal) 알고리즘

- 미래를 예측해서 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식. 
- 가장 이상적이나 실제로 불가능하다. 
- 보통 현식적인 알고리즘의 성능을 평가하기 위한 기준선으로 사용한다. 

### FIFO 알고리즘

 - 가장 먼저 온거 가장 먼저 방출
 - 성능이 별로 안좋음. 현대 OS 에서는 거의 안씀. 

### LRU (Least Recently Used) 알고리즘 

- 목표가 미래를 예측하는것. 그러나 불가능. 
- 지역성의 원리가 예측하는데 유용한 단서가 될 수 있음. 이때 이걸 이용한게 -> LRU

- 특히 시간적 지역성 원리에 기반한다. 
- 간단하게 최근에 참조된 메모리 영역이 다시 또 참조될 가능성이 높다고 가정하고 가장 오래 된 메모리 영역을 방출. 

### 어떻게 LRU 구현할까? 

- 타임 스탬프 
	- 모든페이지 테이블 항목에 접근 시간을 기록한다. 
	- 이렇게 해버리면 전체 테이블 스캔해서 가장 짧은 시간을 찾아야해서 오버헤드가 큼.
- 스택 or 연결 리스트 
	- 참조될때 맨 위로 올린다. 스택에. 
	- 그러면 가장 오랫동안 사용되지 않은 페이지는 맨 아래가 된다. 이떄 HashMap 과 이중 연결 리스트를 조합해서 효율적인 구현이 가능하다 함. 

### LRU 의 한계와 Clock 알고리즘

- LRU의 가장 큰 단점은 완벽한 구현에 따르는 막대한 비용이라 함. 
- 모든 메모리 접근마다 타임스탬프, 연결리스트 갱신하는건 너무 비용이 크다. 

### 그러면 어떻게하라고? 

- 그래서 나온게 Clock 알고리즘. 
- 이 알고리즘은 적은 오버헤드로 LRU를 근사하는 매우 효율적인 방법 이라고 한다. 

### 어떻게 동작하길래??

- 각 프레임마다 하나의 참조비트를 사용한다. 
- 페이지 접근이 일어나면 자동으로 참조비트를 1로 설정한다. 이떄 모든 페이지 프레임을 
- 원형 큐로 관리해서 시곗바늘 포인터가 이 큐를 순회한다.

- 원형으로 관리해서 최근에 접근하면 1로 바꾼다. 이말임. 

