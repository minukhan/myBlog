
### 세그멘테이션과 페이징의 차이점
##### 페이징?

- 논리적 주소 공간을 나눈 고정된 크기의 단위.(그냥 페이지처럼 딱 나눠놓은것)
- 내부단편화

![](https://i.imgur.com/YHpBNyc.png)
##### 세그멘테이션?

- 논리적 주소공간을 고정이 아니라 가변적인 크기인 세그먼트로 나눈다. 
- 세그먼트는 코드, 데이터, 스택 등 논리적 단위로 구분된다. 
- 외부단편화

![](https://i.imgur.com/Gbi4MSA.png)




### 여기서 혼동 단어 정리

 ##### 페이지?
- 논리적 주소 공간을 나눈 고정된 크기의 단위.

프레임? 
- 물리적 메모리를 나눈 고정된 크기의 단위.

- 페이지와 프레임은 1:1 대응 관계를 가진다.
- 여기서 페이지 테이블은 논리적 주소의 페이지가 물리적 메모리의 어느 프레임에 있는지 알려주는 역할을 한다. 

알아둘것
- 페이지와 프레임의 크기는 항상 같다. 

![](https://i.imgur.com/zZ0Kcvt.png)

### 페이지에서 실제 주소 가져오는 과정??

- cpu가 논리적 주소를 생성. 
- 페이지 테이블 참조 (MMU) 가 페이지 번호를 사용하여 페이지 테이블을 참조. 
- 페이지 테이블에서 해당 페이지의 프레임 번호를 얻는다. 
- 프레임 번호와 오프셋을 조합해서 물리적 주소를 생성한다. 

### 주소공간의 수정 가능성을 확인하는 방법??

- 페이지 테이블 엔트리(PTE) 에는 접근 권한 비트가 있다. 
- 운영체제가 이 비트를 설정해서 프로세스가 쓸 수 있게끔 할지, 읽기만하게 할지 이런거 제한하는것. 


### C/C++ 개발을 하게 되면 Segmentation Fault 라는 에러를 접한다. 왜??

- Segmentation Fault 는 프로그램이 허용되지 않은 메모리 영역에 접근하려 할 때 발생하는 에러. 
- 존재하지 않는 페이지 번호에 접근할경우.
- 읽기 전용 페이지에 쓰기 작업을 시도하면 페이지 테이블의 접근 권한 비트가 이를 감지 후 트랩 발생.

###### 그냥 단순하게 이상한 메모리에 접근하려고 하거나 권한 없을떄 발생한다고 보면 될듯. 


### 그러면 세그멘테이션 방식을 사용하면 가상 메모리 사용 불가능??

- 결론은 가능. 

> [!important] 가상 메모리가 가능한 핵심적인 이유는??
> 
> 전체 프로그램이 한 번에 물리적 메모리에 올라올 필요가 없다. 라는점.


### 알아둘것

- 세그멘테이션 방식만을 사용하면 고정된 크기의 프레임은 사용되지 않는다. 
- 세그먼트 자체가 가변적인 크기를 가지기 때문. 
- 근데 보통은 세그멘테이션과 페이징을 결합한 혼합 방식을 사용한다고 함. 



### 다중 페이징을 사용하는 이유??

- 결론적으로는 RAM 공간을 절약하기 위함이다. 

###### 문제점 

- 단일 페이지 테이블의 엄청난 크기때문에 필요함. 
	- 현대 컴퓨터에서 사용하는 가상 주소 공간은 매우 크다. 
	- 거대한 테이블로 관리하려면 많은 메모리가 필요함. 
- 실제 메모리 사용은 드문드문 하다. 
	- 대부분의 프로그램은 자신의 가상 주소 공간 전체를 사용하지 않음.
	- 코드, 데이터, 힙, 스택영역 등 일부만 사용하고 그 사이에는 사용되지 않는 구멍이 존재.

- 그래서 페이지 테이블을 트리 구조로 만든다. 
- 가상 주소 영역이 사용하지 않는다면 사우이 단계의 테이블에서 해당 영역을 가리키는 항목 하나만 없음 으로 표시하면됨. 
- 그러면 그 하위단계 페이지 테이블 전체를 아예 만들 필요가 없어진다고 함. 

-> 다단계 페이징은 프로그램이 실제로 사용하는 만큼만 페이지 테이블을 만들어서 RAM을 획기적으로 아끼는 기술
-> 그니까 사용하지 않는 공간이 있다면 페이지 테이블을 아예 만들어놓지도 않는다. 그래서 RAM을 효율적으로 사용할 수 있게된다. 

### 그러면 드는 의문?? 단일 페이징도 사용하는 만큼만 페이지 테이블을 만들어버리면 안돼?

- 하드웨어 (MMU 동작 방식) 때문에 그렇게는 안된다고 함. 
- 하드웨어(MMU)가 주소를 변환하는 방식이 단순한 계산에 기반한다함. 
- 단일 페이지 테이블은 개념적으로 하나의 아주 큰 배열이라고 생각하시면 가장 쉽다. 

```
물리 주소 = (페이지 테이블의 RAM 시작 주소) + (가상 페이지 번호 × 페이지 테이블 항목 크기)
```
- 위 계산식이 오차 없이 정확하게 작동하려면, 페이지 테이블이라는 '배열'이 **물리 메모리(RAM)에 빈틈없이 연속된 하나의 덩어리** 로 존재해야한다. 
- 테이블이 조각나있다면 올바른 항목을 찾아갈 수 없음. 

#### 그래서 나온게 다단계 페이징

- 근데 이때 단일 페이징이면 찾아갈 방법이 없음.
- 그래서 다단계 페이징을 사용하면 연속된 메모리처럼 보일 수 있으니까 가능하다.
- 이 방식 덕분에, 페이지 테이블의 각 조각들은 RAM 여기저기에 흩어져 있어도 괜찮아진다.
- **연속이어야 한다는 조건이 '페이지 테이블 전체'에서 '페이지 테이블의 작은 조각 하나하나'로 축소**된 것