

### OS에서 봤을때 JVM 애플리케이션 메모리를 볼떄

- 보통 많이들 아는 JVM 이 사용하는 메모리로 Heap 을 떠올린다.
- 여기서 JVM이 사용하는 메모리는 힙 만 있는게 아니다. 
- 실제 OS가 보는 총 메모리 사용량은 더 크다. 

##### 여기서 정리하고 갈것

- JVM 에서 메모리를 논할때 2가지 관점이 있음.

###### Heap 메모리

- JVM 이 GC로 관리하는 영역
- java 객체들이 여기에 저장된다. 
- -Xmx 같은 옵션으로 크기를 제어할 수 있음. 
###### 네이티브 메모리(Native Memory)

- JVM 힙 외의 모든 메모리를 네이티브 메모리라고 부름
- 메타 스페이스, 스택, 코드캐시 등 
- OS가 직접 할당하고 JVM이 관리하는 것. 


>[!note] 혼동 주의
>
>**네이티브 메모리도 JVM이 관리하지만, GC가 아니라 JVM 코드/로직이 직접 관리**한다고 이해하면 됩니다.
>
>**JVM이 관리한다는 건 GC처럼 자동 회수가 아니라, JVM 코드 안에서 직접 메모리를 할당/해제**한다는 의미


##### 종류

- 자바 힙 
	- 가장 알려진 영역, 애플리케이션이 생성하는 모든 객체 인스턴스가 저장된다. 
	- GC 에 의해 관리되고 JVM 옵션으로 제어된다. 
- 메타스페이스 
	- 클래스 구조, 필드, 메서드등을 저장하는 네이티브 메모리 영역. 
	- 기본적으로 크기 제한이 없어서 가용 네이티브 메모리만큼 계속 증가할 수 있다.
- 코드 캐시
	- JIT 컴파일러가 자바 바이트코드를 네이티브 코드로 컴파일한 결과물을 저장하는 메모리 영역
- 스레드 스택
	- 각 자바 스레드는 자신만의 스택영역을 가지고 있다고 했는데 
	- 이게 네이티브 메모리에 할당받는다. 
- 네이티브 메모리
	- JNI(Java Native Interface)를 통해 호출되는 C/C++ 라이브러리가 사용하는 메모리


- 그래서 JVM 메모리는 단순히 Heap 뿐만 아니라 모든 네이티브 메모리까지 더한 값이 JVM 메모리 총 사용량이라고 보면 된다. 
- 그래서 몇몇 개발자가 메모리의 한도를 정할때 -Xmx 로 정할 수 있는데 이건 Heap 메모리만 고려하는 것. 나머지도 고려해서 적절한 메모리 한도를 정해야한다. 

![](https://i.imgur.com/OYCZ0rB.png)


#### 만약 너무 과하게 잡으면?? 

- 그래서 힙 외 메모리 구성 요소들이 증가해서 컨테이너의 총 메모리 사용량이 한도를 초과하면 쿠버네티스같은 컨테이너 오케스트레이션 시스템에서는 JVM 을 강제로 종료시킨다. 

- 이때 JVM 은 OutOfMemoryError 를 발생시킬 기회도 안주고 종료시켜서 아무런 흔적이 남지 않아서 문제 해결도 힘들게 할 수 있다 함. 


### JVM과 OS의 상호작용?

- JVM은 OS로부터 거대한 가상 주소 공간을 할당받아서 사용한다. 
- JVM관점에서는 이 공간이 연속적인 메모리처럼 보이지만 실제로 OS가 필요에따라 가상 주소 공간의 페이지들을 물리적 RAM 페이지에 매핑한다. 

- 모든 프로세스는 실행중에 활발하게 참조하는 메모리 페이지들의 집합(작업집합) 을 가짐
- JVM인 경우에는 힙, 코드캐시, 메타스페이스 등 모든 메모리 영역에 걸쳐있는 페이지들로 구성되어있음. 
- 만약 시스템에서 실행중인 프로세스의 작업집합크기의 합이 가용 RAM 크기를 초과하면 OS는 디스크 일부를 가상메모리로 사용하기 시작한다고 함. 
- 이때 메모리 페이지를 RAM 과 보조기억장치 사이에서 이동시키는 작업을 페이징, 스와핑이라고 한다.

### 페이징이 가비지 컬렉션에 미치는 치명적 영향

- OS 스레싱과 자바 성능 사이의 가장 치명적인 연결고리는 "Stop-the-World"(STW) GC, 특히 전체 GC(Full GC) 중에 나타난다. 
- GC 알고리즘은 힙 전체가 RAM에 상주하고 있다는 가정하에 설계됨. 
- Full GC의 '표시(Mark)' 단계에서는 흩어져 있는 수많은 메모리 페이지에 접근하게됨.

- 만약 힙의 일부가 디스크로 페이징 아웃 되어있다면 GC 스레드가 해당 객체에 접근할때마다 페이지 폴트가 발생. 
- 이때 OS는 GC 스레드의 실행을 중단시키고 디스크에서 찾아서 다시 RAM으로 로드해야함. 
- 단 한번의 Full GC가 수천 수만번의 페이지 폴드를 유발할 수 있다. 
- 이러면 애플리케이션이 완전히 멈춘것처럼 동작하지 않을 수 있다. 

- 대용량 힙은 GC 발생 빈도를 줄여주지만 만약 이 힙이 RAM 용량을 초과한다면 OS 페이징때문에 앱을 다운시키는 경우를 초래한다. 
- 그래서 가능한 한 많은 메모리를 할당해라 라는 말 전체가 있는데 물리적으로 사용 가능한! 이라는 중요한 전제를 기억해라. 


### GC 스레싱 : JVM 내부의 악순환

- GC 스레싱은 OS 스레싱과 구별되게 JVM 내부에서 발생하는 고유한 성능 병목 현상. 
- GC 스레싱은 JVM이 CPU 시간의 대부분을 가비지 컬렉션에 사용하면서 회수하는 양은 매우 적은 상태를 의미 
- 이러면 스레드는 CPU 시간을 거의 할당받지 못해서 전혀 진행되지 않는다고 함. 
- 근데 여기서 차이점은 CPU 이용률은 100%라는점. 겉으로 보기에는 좋은데? 할 수 있지만 실상 앱은 매우 느림. 

![](https://i.imgur.com/aCLRPlf.png)



### 그러면 실무자는 어떻게 해야할까?

- OS 스레싱과 GC 스레싱을 탐지하기 위해서는 표준 도구를 활용해서 구체적이고 실용적인 진단 방법이 필요하다함. 

- 로그분석
	- GC 로그를 활성화
	- (Java 9+에서는 `-Xlog:gc*`, Java 8에서는 `-XX:+PrintGCDetails`)

- GC 스레싱 패턴 식별
	- 잦은 Full GC 발생
	- 미미한 힙 감소량
	- 긴 누적 일시정지 시간 이런걸 파악해라. 

- VisualVM 이란게 있는데 실행중인 자바 프로세스에 연결해서 내부 상태를 시각적으로 모니터링 하는 도구를 말한다. 
- 특히 Visual GC 플러그인이 있는데 메모리 및 GC 활동을 직관적으로 보여준다고 함.

### 이러한 스레싱을 예방하는 방법?? 

- 정확한 힙 크기를 설정해라. 
- 현대적 가비지 컬렉터를 비교해가면서 잘 선택해라.
	- 최신 JVM에서 제공하는 저지연 GC가 있는데 대용량 힙 환경에서 스레싱에 대한 회복 탄력성을 크게 향상시킬 수 있다고 함. 



![](https://i.imgur.com/y2Pp3FM.png)








