
### 성능 저하의 주범 : 오버헤드 

- 컨텍스트 스위칭은 멀티 테스킹을 가능하게 하는 필수적인 매커니즘. 
- 공짜가 아님. 발생할때마다 CPU 는 본래의 작업을 멈추고, 스위칭 자체를 위한 부가적인 작업을 수행한다. 
- 이때 소요되는 시간과 자원을 오버헤드(OverHead) 라고 부른다. 
- 이 크기와 원인을 이해하는건 효율적인 시스템을 설계하고 최적화 하는데 매우 중요하다. 

#### 이떄 오버헤드는  2가지로 나눌 수 있다.

##### 직접 비용 

- 이는 컨텍스트 스위칭을 수행하는 커널 코드가 실행되는 동안 소요되는 CPU 시간을 의미. 
- 비교적 시간이기에 측정하기 쉽다. 

##### 종류? 

- 스케쥴러 실행시키는 시간.
	-  다음에 실행시킬 프로세스나 스레드를 결정하기 위해서 스케쥴링 알고리즘을 실행하는데 드는 비용이 여기.
- 레지스터 저장 및 복원 시키는 시간. 
	- 현재 작업의 하드웨어 컨텍스트를 메모리에 저장하고 새로운 작업의 컨텍스트를 CPU 레지스터로 불러오는데 필요한 시간. 
- 메모리 맵 전환시키는 시간. (프로세스 스위칭할때 일어남)
	- 페이지 테이블 포인터를 변경하는 등 MMU 관련 설정을 바꾸는데 드는 비용을 말한다. 

![](https://i.imgur.com/3JL3HYB.png)

### CR3(페이지 테이블 포인터) 레지스터가 뭐야? 

- 현재 실행중인 프로세스의 최상위 페이지 테이블의 물리적 주소를 담고있다. 
	- 최상위 페이지 테이블의 물리적 주소를 가지고있는 이유?
		- 약간 목차라고 생각하면 편하다. 
		- 엄청 방대한 메모리에서 빠르게 찾기 위해서 두는 총괄 목차라고 생각하면 좋음. 
		- 미적분 개념을 찾을때 수학이라는 큰 개념을 두는 것처럼. 
- 그리고 이 CR3 레지스터는 메모리 관리장치(MMU)한테 페이지 레이블 주소를 참조해서 길을 찾아라 라고 알려주는 역할을 하는놈

#### 이게 언제바뀌나??

- CR3 레지스터 변경은 운영체제 커널이 프로세스 컨텍스트 스위치를 수행할때 발생한다고 합니다. 
- 먼저 컨텍스트 스위치가 일어날때 운영체제 스케쥴러가 교체할 다른 프로세스를 결정하겠죠? 
- 그러면 컨텍스트 스위치는 커널의 고유권한이기 때문에 커널모드로 바뀌어있을 것. 
- 이때 커널은 다음에 실행될 프로세스의 PCB 에서 페이지 디렉터리 물리 주소를 읽어옵니다. 
- 이때 커널은 MOV CR3 와 같은 특권 명령어를 실행.
- 전에 읽어온 프로세스 디렉터리 주소를 CR3 레지스터에 로드한다. (수학 -> 국어)
	- 이러는 순간 이제 CPU 의 MMU는 메모리를 이전에 사용하던 메모리 맵이 아니라
	- 갈아 끼운 프로세스의 메모리 맵을 이용하고 접근하는것. 


#### 이렇게 되면 TLB 플러시가 생길 수 밖에 없다. 

- CR3 레지스터를 변경하는건 단순히 포인터 하나만 바꾸는게 아니라 이상의 의미를 가진다. 
- 가장 중요한건 TLB(Translation Lookaside Buffer) 의 무효화가 일어난다. 
![](https://i.imgur.com/PTQQqTt.png)


#### TLB가 뭔데? 
- 최근에 사용된 가상 주소 - 물리주소 변환 정보를 저장하는 고속 하드웨어 캐시를 말한다. 

#### TLB가 필요한 이유? 

- CPU 가 사용하는 주소는 가상 주소 , 실제 데이터가 저장되는 RAM 의 위치는 물리주소임. 
- 이 둘을 변환해주는게 페이지 테이블임. 
- TLB는 최근에 변환했던 가상-물리 주소 쌍을 저장해두는 캐시라고 생각하면 됨. 
- 이떄 MMU가 매번 페이지 테이블을 메모리에서 읽어오는 것은 느림. 
- 그래서 중간에 캐시를 두는것. 
- TLB를 통해서 주소 변환 속도를 향상시킨다. 

#### 그래서 생기는 문제가 뭔데?

-  CR3 가 변경되면 이전 프로세스의 정보가 담긴 캐시들이 TLB에 저장되어있는데 이것들은 쓰레기값이 된다.
- 그래서 자동으로 TLB 의 내용 대부분을 비워버린다. 
- 이떄 새로 실행되는 프로세스에서 작업을 할때 TLB 가 다 비워져있기때문에 miss 를 겪게되고 매번 느린 메인 메모리에 있는 페이지 테이블을 직접 참조하게 된다.
- 이게 프로세스 컨텍스트 스위치 오버헤드의 주요 원인이된다. 


### 그래서 현대에는 PCID(Process-Context Identifier) 라는게 나왔다!!

- PCID 는 TLB 의 각 항목에 꼬리표를 붙이는 기능을 말한다. 
- 각 프로세스 마다 고유한 ID를 할당하고 TLB에 주소변환 정보를 캐싱할때 이 ID를 저장한다. 
- CR3 레지스터의 하위 비트를 이용해서 PCID 값으로 사용한다. 
- 이때 컨텍스트 스위칭할때 CR3를 변경하면 TLB를 전체 비우는게 아니라 새로운 PCID와 일치하는 항목만 사용하도록 전환한다. 
- 이 방식을 사용하면 여러 프로세스 주소 변환 정보가 TLB에 공존할 수 있다고 한다. 
- 이건 이런 상황에서 빛을 바란다.
	- A 프로세스에서 B 프로세스로 전환됐다가 빠르게 다시 A프로세스로 돌아오는경우? 
	- TLB 항목들이 그대로 남아있어서 TLB MIss 를 줄이고 컨텍스트 스위칭 비용을 크게 줄이게된다. 


#### 그래서 정리!

- CR3 레지스터를 변경하는건 운영체제가 한 프로세스의 메모리 세계에서 다른 프로세스로 이동하는 핵심적인 과정
- 이때 하드웨어(MMU) 에게 새로운 메모리 주소를 접근하는데 TLB 플러시라는 성능 비용을 수반. 
- 이때 PCID는 ID 값을 기록해두고 비용을 최소화해서 멀티 태스킹 환경의 효율을 높이는 것. 

#### 간접비용

- 이는 컨텍스트 스위칭 작업이 완료된 이후에 발생하는 성능 저하를 말합니다. 
- 새로운 작업이 시작할 때, 하드웨어 캐시들이 이전 이전 작업의 데이터로 채워져있음. 
- 그래서 효율이 급격하게 떨어진다고 함. 
- 중요한게 이 간접 비용이 직접 비용보다 훨씬 더 크고 시스템 성능에 치명적인 영향을 준다고 함. 

#### 종류

- CPU 캐시 오염 
	- 현대 CPU 는 캐시 L1, L2, L3 를 쓰면서 여러 단계의 고속 캐시 메모리를 사용해서 메인 메모리 RAM 에 접근을 최소화 한다.
	- 컨텍스트 스위칭 하면 이전에 사용하던 데이터와 명령어로 가득 차있어서 
	- 새로 실행되는 프로세스는 자신에게 필요한 데이터와 명령어로 가득 차있다. 
- 위에 설명한 TLB 플러시
	- 위에서 설명했듯, 새로운 프로세스는 접근할 때 TLB 미스를 겪에 되면서 매번 페이지 테이블을 직접 탐색하며 느리게 작업하게됨. 
- 분기 예측 버퍼 무효화
	- 현대 CPU 는 프로그램의 조건문이 어떤 방향으로 실행될지 미리 예측해서 파이프라인의 효율을 높인다고 합니다. 
	- 이때 실행 패턴에 기반해서 만약 컨텍스트 스위칭이 일어나면 이제 아예 다른 코드를 실행되기 때문에 예측 정보가 쓸모가 없어진다. 
	- 이로인한 예측 실패율이 높아져서 CPU 파이프라인이 중단되고 성능이 저하된다고 한다. 


