

### 동기 vs 비동기 

- 호출할 작업이 끝날 떄 까지 호출자가 기다리는게 동기처리
- 기다리지 않고 바로 반환. 이후 작업완료 여부는 나중에 확인. 

- 동기, 비동기는 요청 개념임. 
- A에서 B로 요청이 갔을때 B에서 끝나서 응답이 왔다면 
	- 동기는 그 응답을 바로 처리를한다. 
	- 근데 비동기는 응 그래 너 했구나 내가 하고싶을때 할께~ 이런느낌임

### 블로킹 vs 논블로킹

- 요청 후 작업 완료될 떄까지 호출자가 멈추는게 블로킹 
- 데이터 없으면 즉시 반환, 나중에 다시시도 하는게 논 블로킹. 

- 블로킹, 논블로킹은 제어권의 유무 개념임

- 결과가 반환됐을때 바로 처리 하는건 : 동기
- 바로 처리 안하고 나중에 처리할꺼야 : 비동기 
- 요청을 보내놓고 아무것도 못할때     : 블로킹
- 요청을 보내놓고 다른 작업을 할떄    : 논블로킹

### 블로킹 + 동기

![](https://i.imgur.com/RMNLsYY.png)

### 논블로킹 + 동기
![](https://i.imgur.com/bIBYuMp.png)

- 논블로킹은 제어권이 A에게 있어서 지속적으로 확인 절차를 가짐.
- 블로킹 : A는 더 이상 확인하지 않고, **B가 끝나면 A를 깨워줌(알려줌)**.

### 블로킹 + 비동기
![](https://i.imgur.com/PmaRRiA.png)
- A 가 B 가 끝났다고해서 바로 처리하지 않는다. 

### 논블로킹 + 비동기

![](https://i.imgur.com/U29UEfc.png)


### I/O 멀티 플렉싱

- 하나의 스레드로 여러 I/O 를 효율적으로 처리한다. 
- 수천 수만개의 클라이언트 연결을 동시에 처리해야하는 현대 네트워크는 연결마다 스레드 생성해버리면 자원소모가 너무크다. 
- 그래서 I/O 멀티 플렉싱은 단일 스레드 여러 파일 디스크립터를 동시에 감시하고 작업이 필요하면 처리하는 기술을 말한다. 

- 하나로 여러개를 관리하면서 작업을 한다 라고 생각하면 될듯. 

### 논블로킹 I/O의 결과를 어떻게 받을까??

- Polling 방식 
	- 주기적으로 read, write 호출. 데이터 없으면 바로 반환. 
	- CPU 낭비 가능. 효율이 낮다. 
- I/O 멀티플렉싱
- 이벤트 기반 비동기 I/O
### 정리 

- 동기/비동기 = **결과를 기다리느냐 안 기다리느냐**
- 블로킹/논블로킹 = **CPU를 기다리게 하느냐 안 하느냐**
- I/O 멀티플렉싱 = **하나의 스레드로 여러 I/O를 효율적으로 처리**
- 논블로킹 I/O 결과 = **폴링, 이벤트, 멀티플렉싱**으로 수신