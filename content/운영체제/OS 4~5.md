
## 프로세스의 개념

프로세스 : 실행중인 프로그램을 의미

- 디스크 실행파일 형태로 존재하던 프로그램이 메모리 (RAM) 에 올라가면서 생명력을 갖는 프로세스가 된다.
- 이떄부터 프로세스는 CPU를 점유하며 자신의 코드를 수행한다. 

#### 프로세스 문맥

- 프로세스 문맥이란?
	-  프로세스가 현재 어떤 상태에서 수행되고있는지 정확히 규명하기 위해 필요한 정보
	 -> "이 프로세스가 어디까지 실행됐고, CPU가 다시 실행할 때 필요한 정보"
	 -> 프로세스의 상태를 저장하는 정보

### **프로세스 문맥이 필요한 이유**

- CPU는 여러 프로세스를 번갈아 실행 (시분할 시스템)
- 문맥 교환(Context Switching) 시, 이전 상태를 복원해야 함
- 프로세스가 중단된 지점부터 정상적으로 실행되도록 하기 위해 필요

-> **프로세스 제어 블록(PCB, Process Control Block)** 에 저장

#### **프로세스 문맥 구성 요소**

1. **주소 공간**: 코드, 데이터, 스택 상태
2. **레지스터 값**: CPU가 현재 사용 중인 값
3. **커널 상태**: 커널 스택 및 시스템 호출 정보

 [![](https://github.com/binghe819/TIL/raw/master/OS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80%20%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98%20%EC%9B%90%EB%A6%AC/image/process_structure.png)]

## **하드웨어 문맥 (Hardware Context)**

 **CPU의 수행 상태를 나타냄**  
**프로세스가 실행되면서 CPU가 사용하는 정보**

 **포함하는 정보:**
- **PC (Program Counter):** 현재 실행 중인 명령어의 위치
- **레지스터 값:** 연산 중인 데이터, 스택 포인터(SP) 등

---

## **프로세스의 독자적인 주소 공간 (User Address Space)**

 **프로세스가 사용하는 메모리 공간**

 **포함하는 정보:**
- **코드(Code):** 프로그램의 실행 명령어
- **데이터(Data):** 전역 변수, static 변수
- **스택(Stack):** 함수 호출 정보, 지역 변수
- 힙(Heap) : 객체들 

---
## **커널상의 문맥 (Kernel Context)**

**운영체제가 프로세스를 관리하기 위해 필요한 정보**  
**프로세스 관련 커널 자료구조 포함**

**포함하는 정보:**
- **PCB (Process Control Block):** 프로세스의 ID, 상태, 우선순위, 메모리 정보 등
- **커널 스택:** 시스템 호출 정보를 저장 (예: 파일 읽기, 메모리 할당 요청)
    
| 문맥 종류          | 역할             | 포함하는 정보      |
| -------------- | -------------- | ------------ |
| **하드웨어 문맥**    | CPU 수행 상태 저장   | PC 값, 레지스터 값 |
| **프로세스 주소 공간** | 프로세스가 사용하는 메모리 | 코드, 데이터, 스택  |
| **커널 문맥**      | 운영체제가 관리하는 정보  | PCB, 커널 스택   |

 **프로세스가 실행되려면 이 3가지 문맥이 모두 필요**하고,  
 **운영체제는 문맥을 저장했다가 나중에 다시 불러와서 실행!** 

---
## ** 프로세스 상태 & 문맥교환 (Context Switching) 정리**


### ** 프로세스의 상태**

프로세스는 실행되는 동안 여러 상태를 오가며 변경돼.

| 상태                              | 설명                                    |
| ------------------------------- | ------------------------------------- |
| **실행 (Running)**                | 프로세스가 CPU를 점유하고, 명령을 실행 중인 상태         |
| **준비 (Ready)**                  | 실행할 준비가 완료되었지만, CPU를 할당받지 못한 상태       |
| **봉쇄 (Blocked / Wait / Sleep)** | CPU를 할당받아도 실행할 수 없는 상태 (예: 입출력 작업 대기) |
| **시작 (New)**                    | 프로세스가 생성 중이며, 아직 메모리 할당이 승인되지 않은 상태   |
| **완료 (Terminated)**             | 프로세스가 종료되었지만, 운영체제가 아직 정리 중인 상태       |

 **프로세스 상태 변화 예시**

- **준비 → 실행**: CPU를 할당받으면 실행됨.
- **실행 → 준비**: CPU를 뺏기면 다시 준비 상태로 돌아감.
- **실행 → 봉쇄**: 입출력(IO) 작업 같은 이유로 실행 불가능해지면 봉쇄 상태가 됨.
- **봉쇄 → 준비**: 필요한 작업이 끝나면 다시 실행 가능해짐.
- **실행 → 완료**: 프로세스가 정상적으로 끝나면 종료됨.

### ** 문맥교환 (Context Switching) & CPU 디스패치 (Dispatch)**

 **문맥교환 (Context Switching)**
- 실행 중이던 프로세스를 멈추고, 다른 프로세스로 교체하는 과정
- 이전 프로세스의 **문맥(레지스터 값, 메모리 상태 등)**을 저장하고, 새 프로세스의 문맥을 복원함

**디스패치(Dispatch)**는 **준비(Ready) 상태에 있는 프로세스 중 하나를 선택하여 CPU를 할당하는 과정**

 **언제 발생할까?**

1. **타임 슬라이스(Time Slice) 종료** → CPU를 다른 프로세스에 넘겨야 할 때
2. **입출력(IO) 대기** → 현재 프로세스가 봉쇄(Blocked) 상태로 들어갈 때
3. **우선순위 변경** → 더 중요한 프로세스가 실행될 필요가 있을 때

## ** 프로세스 제어 블록 (PCB) & 문맥 교환 정리**

---

## **프로세스 제어 블록 (PCB)란?**

 **운영체제가 프로세스를 관리하기 위해 프로세스마다 유지하는 정보들의 집합**  
 **커널 영역에 저장됨**

 운영체제가 프로세스를 관리하려면, **각 프로세스의 정보(상태, 메모리, 스케줄링 정보 등)**가 필요하기 때문!

## ** PCB의 구성 요소**

| 항목                                     | 설명                           |
| -------------------------------------- | ---------------------------- |
| **프로세스 상태 (Process State)**            | 현재 실행 중인지, 대기 중인지 등 프로세스의 상태 |
| **프로그램 카운터 (PC, Program Counter)**     | 다음 실행할 명령어의 위치               |
| **CPU 레지스터 값**                         | 프로세스가 실행될 때 사용하던 레지스터 정보     |
| **CPU 스케줄링 정보**                        | 우선순위, 스케줄링 큐 정보 등            |
| **메모리 관리 정보**                          | 프로세스의 코드, 데이터, 스택 등 메모리 정보   |
| **자원 사용 정보 (Accounting Information)**  | CPU 사용량, 실행 시간 등의 통계         |
| **입출력 상태 정보 (I/O Status Information)** | 프로세스가 연 파일 정보, 입출력 장치 상태     |

## 문맥교환 (Context Switching)

 **CPU가 실행할 프로세스를 변경하는 과정**  
 **기존 프로세스의 문맥을 PCB에 저장하고, 새로운 프로세스의 문맥을 불러옴**

 **문맥 교환 과정**

1. 실행 중이던 프로세스의 **문맥(Context)**을 PCB에 저장
2. 새로운 프로세스를 선택하여 **PCB에서 문맥을 복원**
3. CPU가 새로운 프로세스를 실행
    
 **문맥 교환 단점**  
 **비용(Overhead)이 크다!**

- 문맥을 저장하고 불러오는 과정이 CPU를 잡아먹음.
- 너무 자주 일어나면 성능이 떨어짐.

## **문맥 교환이 일어나는 경우 vs. 일어나지 않는 경우**

| 경우                           | 문맥 교환 발생 여부 | 설명                                              |
| ---------------------------- | ----------- | ----------------------------------------------- |
| **타이머 인터럽트**                 | 발생          | 특정 프로세스가 할당된 시간 동안 실행되었으면, CPU를 다른 프로세스에게 넘겨야 함 |
| **입출력 요청 (I/O System Call)** | 발생          | 프로세스가 I/O 요청을 하면 CPU를 다른 프로세스에게 넘김              |
| **사용자 모드 → 커널 모드 전환**        | 발생 X        | 같은 프로세스가 실행 중이지만, 실행 모드만 바뀌는 것                  |
| **시스템 콜 (System Call)**      | 발생 X        | 프로세스가 운영체제 기능을 호출하는 것이므로 CPU를 넘기지 않음            |

**사용자 모드 → 커널 모드 전환** 예시
예를 들어, 사용자가 **파일을 열기 위한 시스템 콜을 호출**하면, 현재 프로세스가 **사용자 모드에서 커널 모드로 전환**됩니다. 이때 CPU는 **같은 프로세스가 계속 실행되지만** 모드만 변경되는 것

**시스템 콜 (System Call)** 예시
시스템 콜은 프로세스가 운영체제 기능을 **호출**하는 것이며, 이때 **CPU를 다른 프로세스로 넘기지 않습니다**.

문맥 교환은 보통 타이머 인터럽트에 의해 많이 실행된다. 즉, CPU 할당 시간을 어떻게 정하느냐가 중요하다.

## **문맥 교환 & CPU 할당 시간 관계**

 **타임 슬라이스(Time Slice)**를 너무 짧게 하면?  
 **문맥 교환이 자주 발생 → 오버헤드 증가 → 성능 저하**

 **타임 슬라이스를 너무 길게 하면?**  
 **한 프로세스가 너무 오래 실행 → 시분할 시스템의 의미가 사라짐**

 **즉, 문맥 교환을 최소화하면서도 여러 프로세스가 공평하게 CPU를 사용할 수 있도록 적절한 타임 슬라이스를 정하는 것이 중요!**


|개념|설명|
|---|---|
|**PCB (Process Control Block)**|운영체제가 프로세스를 관리하기 위해 저장하는 정보|
|**문맥 교환 (Context Switching)**|실행 중인 프로세스를 변경하는 과정|
|**문맥 교환 발생 조건**|타이머 인터럽트, 입출력 요청, 우선순위 변경|
|**문맥 교환이 발생하지 않는 경우**|사용자 모드 → 커널 모드 전환, 시스템 콜|
|**문맥 교환의 단점**|오버헤드 발생 (CPU 성능 저하)|
|**타임 슬라이스 영향**|너무 짧으면 문맥 교환 증가, 너무 길면 시분할 시스템이 무의미|

## **프로세스를 스케줄링하기 위한 큐 정리**

운영체제는 **프로세스들을 효율적으로 관리**하기 위해 여러 개의 **큐(Queue)를 사용**함!

 **프로세스 상태에 따라 적절한 큐에 배치**  
 **각 큐는 연결 리스트로 관리됨**

## **주요 프로세스 스케줄링 큐 종류**

[![](https://github.com/binghe819/TIL/raw/master/OS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80%20%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98%20%EC%9B%90%EB%A6%AC/image/process_status_change_and_queue.png)](https://github.com/binghe819/TIL/blob/master/OS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80%20%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98%20%EC%9B%90%EB%A6%AC/image/process_status_change_and_queue.png)

|**큐 종류**|**설명**|
|---|---|
|**CPU 스케줄링 큐 (Ready Queue)**|CPU를 할당받기 위해 준비된 프로세스들의 대기열|
|**장치 큐 (Device Queue)**|특정 입출력 장치를 기다리는 프로세스들의 대기열|
|**공유 데이터 큐**|공유 데이터를 사용하려는 프로세스들이 대기하는 큐|
|**Job Queue**|시스템 내의 모든 프로세스를 관리하는 큐|
|**Ready Queue**|실행할 준비가 된 프로세스들이 대기하는 큐|
|**Device Queue**|I/O 작업을 기다리는 프로세스들이 대기하는 큐|

---

###  CPU 스케줄링 큐 (Ready Queue)**

 **준비 상태(Ready) 프로세스들의 대기열**  
 **CPU가 할당되길 기다리는 프로세스들이 줄 서 있음**

 **작동 방식**

1. CPU가 프로세스를 실행하다가 **타이머 인터럽트 발생**
2. 실행 중이던 프로세스는 **준비 큐(Ready Queue)의 맨 뒤로 이동**
3. 가장 앞에 있는 프로세스가 CPU를 할당받아 실행

** 쉽게 말하면?**  
 **CPU를 기다리는 프로세스들이 줄을 서서 기다리는 곳!**

---

### ** 장치 큐 (Device Queue)**

 **입출력 장치를 기다리는 프로세스들이 대기하는 큐**

 **작동 방식 (디스크 입출력 예시)**

1. 프로세스가 **디스크에서 데이터를 읽어야 함**
2. 입출력 작업이 완료될 때까지 **CPU를 반납하고 봉쇄(Blocked) 상태**로 변경
3. 디스크 컨트롤러가 **장치 큐(Device Queue)에 줄 서 있는 프로세스를 순서대로 처리**
4. 입출력 작업이 끝나면 **운영체제가 해당 프로세스를 Ready Queue로 이동**

** 쉽게 말하면?**  
 **"ATM에서 줄 서서 기다리는 것"**  
 **입출력 장치를 사용하려면 줄을 서서 차례를 기다려야 함!**

---

### ** Ready Queue & Device Queue 비교**

|큐|상태|설명|
|---|---|---|
|**Ready Queue**|준비 (Ready)|CPU를 할당받기 위해 대기 중|
|**Device Queue**|봉쇄 (Blocked)|I/O 작업이 끝나길 기다리는 중|

** 프로세스의 상태 변화 예시**

1. **Ready 상태** → CPU를 할당받아 실행
2. 실행 중 I/O 요청 발생 → **Device Queue로 이동 (Blocked 상태)**
3. I/O 작업이 완료되면 **Ready Queue로 복귀**
4. 다시 CPU를 할당받아 실행

---

### ** 공유 데이터 큐**

 **공유 데이터(예: 파일, 메모리 등)를 사용하려는 프로세스들이 대기하는 큐**  
 **데이터 일관성을 유지하기 위해 한 번에 하나의 프로세스만 접근 가능**

 **예시**

1. 여러 프로세스가 **같은 파일을 수정하려고 함**
2. **첫 번째 프로세스가 파일을 점유 → 다른 프로세스들은 공유 데이터 큐에서 대기**
3. **첫 번째 프로세스가 작업을 끝내면 → 다음 프로세스가 파일을 사용**

---

### ** Job Queue**

 **시스템 내 모든 프로세스를 관리하는 큐**  
 **Ready Queue + Device Queue 모두 포함하는 개념**  
 **프로세스가 메모리에 있는지 여부와 관계없이 존재**


---

## ** 커널의 큐 관리 방식**

**커널은 프로세스를 큐에 넣어 관리**  
 **각 프로세스의 PCB를 연결 리스트 형태로 관리**

 **작동 방식**

- **각 장치마다 개별적인 큐를 운영** (디스크 큐, 프린터 큐 등)
- **프로세스 상태에 따라 Ready Queue ↔ Device Queue 이동**
- **큐의 포인터를 이용해 프로세스 순서를 관리**
    

---

## ** 최종 정리**

| 개념                           | 설명                      |
| ---------------------------- | ----------------------- |
| **CPU 스케줄링 큐 (Ready Queue)** | CPU를 기다리는 프로세스들이 대기     |
| **장치 큐 (Device Queue)**      | I/O 장치를 기다리는 프로세스들이 대기  |
| **공유 데이터 큐**                 | 공유 데이터를 사용하려는 프로세스들이 대기 |
| **Job Queue**                | 시스템 내 모든 프로세스를 관리       |
| **큐 관리 방식**                  | 커널이 연결 리스트 형태로 PCB를 관리  |

 **운영체제는 여러 개의 큐를 사용하여 프로세스를 효율적으로 관리함!** 

--- 
## **스케줄러(Scheduler) 정리**

운영체제는 **한정된 CPU와 메모리를 효율적으로 사용**하기 위해 **스케줄러**를 사용함!  
스케줄러는 **어떤 프로세스에게 자원을 할당할지 결정하는 운영체제 커널의 코드**

 **CPU와 메모리를 효율적으로 배분**  
 **시스템 성능을 최적화**

## **스케줄러 종류**

|**스케줄러 종류**|**설명**|
|---|---|
|**장기 스케줄러 (Long-term Scheduler)**|Ready Queue에 어떤 프로세스를 넣을지 결정|
|**단기 스케줄러 (Short-term Scheduler)**|Ready Queue에서 실행할 프로세스를 선택|
|**중기 스케줄러 (Medium-term Scheduler)**|메모리에 너무 많은 프로세스가 올라오면 일부를 Swap Out|

## **장기 스케줄러 (Long-term Scheduler)**

 **Ready Queue에 어떤 프로세스를 넣을지 결정**  
 **New 상태 → Ready 상태로 변경**  
 **CPU에 실행될 프로세스를 미리 결정하는 역할**

 **작동 방식**

1. 프로세스가 생성되면 **New 상태**
2. **장기 스케줄러가 일부 프로세스를 Ready Queue에 추가**
3. 프로세스가 **메모리에 올라가 실행 준비 완료**
    

 **특징**
- 실행 빈도가 **낮음 (수십 초 ~ 수분 단위)**
- 속도가 빠를 필요가 없음
- **메모리 관리와 관련**
- **현대 OS에는 존재하지 않음** → 메모리 성능이 향상되면서 불필요해짐
    
## **단기 스케줄러 (Short-term Scheduler)**

 **Ready Queue에서 실행할 프로세스를 선택**  
 **CPU를 어느 프로세스에게 줄지 결정**

 **작동 방식**

1. Ready Queue에서 **가장 적절한 프로세스를 선택**
2. **CPU를 할당**하고 Running 상태로 변경
3. **타이머 인터럽트 발생 시 다시 Ready Queue로 이동**
    

 **특징**

- 실행 빈도가 **매우 높음 (밀리초 단위)**
- 속도가 **빠를 필요가 있음**
- **시분할 시스템에서 매우 중요**

## **중기 스케줄러 (Medium-term Scheduler)**

 **메모리 부족 시 일부 프로세스를 Swap Out**  
 **프로세스를 통째로 디스크에 저장하고, 나중에 다시 불러옴**

 **작동 방식**

1. **메모리에 너무 많은 프로세스가 올라오면**
2. **일부 프로세스를 Swap Out (디스크로 이동)**
3. **메모리를 확보한 후 나중에 다시 Swap In**
    

 **특징**
- **Swap 영역을 사용하여 메모리 관리 최적화**
- **장기 스케줄러 대신 현대 OS에서 사용됨**
- **봉쇄(Blocked) 상태의 프로세스를 먼저 Swap Out**

## **Swap Out & Swap In**

 **중기 스케줄러가 Swap Out 하는 프로세스 기준**  

**0순위: 봉쇄(Blocked) 상태 프로세스**

- **당장 CPU를 사용할 가능성이 없으므로 Swap Out**  
- **메모리가 여전히 부족하면 Ready 상태 프로세스도 Swap Out**
     
 **Swap In 과정**

- **봉쇄 상태의 프로세스가 I/O 완료 시 다시 Ready Queue로 이동**
- **Swap Out 된 프로세스가 다시 메모리로 올라와 실행 가능**

## **Suspended (중지) 상태 추가**

 **중기 스케줄러 등장으로 인해 새로운 상태 추가됨**  
 **메모리에서 완전히 제거된 상태**

| **중지 상태 종류**          | **설명**                        |
| --------------------- | ----------------------------- |
| **Suspended Ready**   | Ready 상태였지만 Swap Out 되어 중지됨   |
| **Suspended Blocked** | Blocked 상태였지만 Swap Out 되어 중지됨 |

 **Suspended Blocked → Suspended Ready 변환 조건**
- **I/O 작업이 끝나면 Ready 상태로 변경**
    
## **프로세스의 생성과 종료**

❗️ **흔한 오해 - 운영체제가 프로세스 전부를 생성한다고 생각한다**

운영체제가 **모든 프로세스를 직접 생성하는 것은 아님!**  
 최초 프로세스(예: `init` 프로세스)는 운영체제가 생성  
 이후에는 **부모 프로세스가 새로운 프로세스를 생성**

## **부모 프로세스 & 자식 프로세스**

- **부모 프로세스**: 다른 프로세스를 생성한 프로세스.
- **자식 프로세스**: 부모 프로세스에 의해 생성된 프로세스.
    
- **특징**:
    - 자식 프로세스가 먼저 종료됨.
    - 부모 프로세스는 자식 프로세스를 처리하는 역할을 담당.
    - 부모 프로세스가 종료되려면 자식 프로세스가 모두 종료되어야 함.
        
#### 프로세스가 자원을 얻는 방법

운영체제 및 자원에 따라 방식이 다름.

1. 운영체제로부터 직접 자원을 할당받음.
2. 부모 프로세스와 자원을 공유함.

#### 프로세스 수행 모델

1. **부모와 자식이 공존하며 수행되는 모델**
    - 부모와 자식 프로세스가 CPU를 경쟁적으로 사용.
        
2. **자식이 종료될 때까지 부모가 기다리는(wait) 모델**
    - 부모 프로세스는 자식 프로세스가 종료될 때까지 봉쇄(blocked) 상태.
    - 자식이 종료되면 부모가 준비(ready) 상태로 전환되어 CPU 점유를 기다림.
    - **예시**: 유닉스에서 명령어 실행 시, 부모 프로세스는 자식이 끝날 때까지 기다림.

#### 프로세스 생성 절차

- **복사 & 덮어씌우기**
    
    - 프로세스는 독자적인 공간을 가짐.
    - 새로운 자식 프로세스는 부모 프로세스의 주소 공간을 그대로 복사하여 생성.
    - 이후, 새로운 프로그램의 주소 공간을 덮어씌움.
        
- **유닉스 시스템에서의 예시**
    
    1. `fork()` 시스템 콜을 호출하여 부모 프로세스를 복제 (PID 제외).
    2. `exec()` 시스템 콜을 호출하여 새로운 프로그램으로 주소 공간을 덮어씌움.
        

#### 자식 프로세스 생성 과정

1. **이벤트 발생** (I/O, timer, fork, interrupt 등).
2. **CPU 제어권이 커널로 이동** (fork 호출).
3. **커널이 부모 프로세스를 복제하여 자식 프로세스 생성**.
4. **자식 프로세스는 부모와 동일한 문맥을 가짐** (PCB 복사됨).
    - 초기에는 자식도 자신이 부모라고 인식함.
5. **exec()를 실행하여 새로운 프로그램으로 변환**.
6. **부모는 wait() 호출하여 자식 종료를 대기** (봉쇄 상태).
7. **자식이 종료되면 부모는 준비 상태로 변경**.
8. **fork(), exec(), wait()은 시스템 콜을 통해서만 실행 가능** (사용자는 직접 실행 불가).

#### 프로세스 종료

**원칙**: 부모 프로세스가 종료되기 전에 모든 자식 프로세스가 종료되어야 함.

1. **자발적 종료 (`exit()`)**
    - 프로세스가 마지막 명령을 수행한 후 운영체제에 종료를 알림.
    - 컴파일러가 자동으로 `exit()` 명령어 삽입.
        
2. **비자발적 종료 (`abort()`)**
    - 부모 프로세스가 자식 프로세스를 강제로 종료.
    - 발생 조건:
        - 자식이 과도한 자원을 요구할 때.
        - 자식이 필요하지 않은 작업을 수행할 때.
        - 부모가 종료될 때 (자식도 함께 종료됨).
            
#### 로그아웃 후에도 프로그램을 계속 실행하는 방법 (nohup)

- 로그인 후 생성된 모든 프로세스는 해당 로그인 프로세스(부모) 아래에서 실행됨.
- 로그아웃하면 부모 프로세스가 종료되므로, 그 아래에 있는 모든 자식 프로세스도 종료됨.
- 만약 로그아웃하고도 모든 프로세스를 종료시키고 싶지 않으면, 자식 프로세스를 종료되지 않을 다른 프로세스의 자식으로 보내주어야 한다.

## **프로세스 간의 협력 (IPC)**

 **기본 원칙:**

- **각 프로세스는 독립적인 주소 공간**을 가짐 → **다른 프로세스의 메모리 직접 접근 불가**
- 부모와 자식 프로세스도 **완전히 독립적인 공간**을 가짐
- **BUT!** 협력이 필요할 때도 있음 → **IPC(Inter-Process Communication) 필요**

## **IPC (Inter-Process Communication)란?**

 **IPC**: 하나의 컴퓨터 내에서 실행 중인 **다른 프로세스 간의 통신을 의미**  
 **기능**:

- **통신** → 데이터를 주고받음
- **동기화** → 수행 순서를 조정

## **IPC의 2가지 방식**

###  메시지 전달 방식 (Message Passing)**

 **특징:**

- **공유 데이터 없음**
- **커널이 메시지 전달 중개**
- `send(message)`, `receive(message)` 연산을 통해 통신
    

 **통신 방식:**

| 방식        | 설명                                  |
| --------- | ----------------------------------- |
| **직접 통신** | P1 ↔ P2 직접 메시지 전송                   |
| **간접 통신** | P1 → **MailBox** → P2 (중간 인터페이스 존재) |
### **공유 메모리 방식 (Shared Memory)**

 **특징:**

- **프로세스가 일부 주소 공간을 공유**
- 공유된 메모리 공간에 데이터를 저장하면 **모든 프로세스가 접근 가능**
- BUT! **운영체제가 동기화 문제를 해결해주지 않음** → 사용자가 직접 해결 필요
    

 **문제점:** **동기화 (Synchronization) 문제 발생!**  
 **경쟁 조건(Race Condition)**

- 여러 프로세스가 동시에 공유 메모리를 수정하면 **데이터 충돌 가능**
    
 **해결 방법:**

- **뮤텍스(Mutex)**: 한 번에 **오직 하나의 프로세스(또는 스레드)**만 공유 자원에 접근할 수 있도록 하는 **잠금(lock) 메커니즘**.
    
- **세마포어(Semaphore)**: **카운터(정수 값)**를 사용하여 **여러 개의 프로세스(또는 스레드)**가 공유 자원에 접근할 수 있도록 제어.
    

**차이점**

- **뮤텍스**는 한 번에 **1개 프로세스(스레드)만 접근 가능** (이진값, 0 또는 1).
- **세마포어**는 **여러 개의 프로세스(스레드) 접근 가능** (N개의 자원 관리 가능).


### 좀비 프로세스(Zombie Process)와 고아 프로세스(Orphan Process)

#### 1. **좀비 프로세스 (Zombie Process)**

- 프로세스가 종료되었지만 **부모 프로세스가 종료 상태를 회수하지 않은 경우** 좀비 프로세스가 됨.
- 프로세스가 종료되면 커널은 **종료 상태(exit status)** 를 부모에게 전달해야 함.
    
- 부모가 `wait()` 또는 `waitpid()`를 호출하지 않으면 종료된 자식 프로세스의 정보가 계속 커널에 남아 있음. -> 리소스 낭비
    
    
- 해결 방법:
    
    - 부모 프로세스가 `wait()` 또는 `waitpid()`를 호출하여 자식 프로세스의 종료 상태를 회수.
    - 부모 프로세스가 먼저 종료되면, 고아 프로세스가 되어 init 프로세스(1번 프로세스)가 상태를 회수함.
        

#### 2. **고아 프로세스 (Orphan Process)**

- 자식 프로세스가 실행 중인데 **부모 프로세스가 먼저 종료된 경우** 고아 프로세스가 됨.
- 고아 프로세스는 자동으로 `init` 프로세스(프로세스 ID 1)가 부모가 되어 관리.
- `init` 프로세스가 고아 프로세스의 종료 상태를 회수하기 때문에 좀비 프로세스가 되지 않음.
- 일반적으로 문제를 일으키지 않지만, 자식 프로세스가 많은 시스템 자원을 소비하면 부담이 될 수 있음.
    

#### 3. **fork() 시스템 호출을 통한 프로세스 생성**

- 기존 프로세스를 복제하여 새로운 프로세스를 생성하는 방식.

- `fork()` 호출 시:
    - 부모 프로세스와 동일한 메모리 상태를 가진 자식 프로세스가 생성됨.
    - 부모 프로세스와 자식 프로세스는 별도의 프로세스로 실행됨.
    - `fork()`의 반환값을 통해 부모와 자식을 구분할 수 있음.
        - 부모 프로세스: `fork()`의 반환값이 자식의 PID.
        - 자식 프로세스: `fork()`의 반환값이 0.
            

#### 4. **정리**

- 부모가 자식의 종료 상태를 회수하지 않으면 **좀비 프로세스**가 됨.
- 부모가 먼저 종료되면 자식은 **고아 프로세스**가 되어 `init`이 부모가 됨.
- `fork()`를 통해 프로세스를 복제하여 자식 프로세스를 만들 수 있음.



## **CPU 스케줄링이 필요한 이유**

 **CPU란?**

- 중앙처리장치(CPU)는 프로그램의 **기계어 명령을 수행**하는 역할
- 프로세스가 실행될 때, **PCB(프로세스 제어 블록)**의 **PC(Program Counter)** 레지스터가 **현재 실행할 명령어의 주소**를 저장
- CPU는 이 **PC 값을 참고**하여 **프로세스를 실행**

## **CPU가 실행하는 명령의 종류**

| 명령 종류        | 설명                                    | 특징                  |
| ------------ | ------------------------------------- | ------------------- |
| **CPU 내 연산** | CPU 내부에서 수행되는 연산 (ex. `add`)          | 매우 빠름, 사용자 직접 실행 가능 |
| **메모리 접근**   | 데이터를 메모리에 저장/로드 (ex. `store`, `load`) | 빠름, 사용자 직접 실행 가능    |
| **I/O 연산**   | 키보드 입력, 디스크 읽기/쓰기 (ex. `disk I/O`)    | 느림, 운영체제 통해 실행      |

 **즉, 프로세스는 CPU 작업과 I/O 작업을 번갈아 수행**

## **CPU 버스트 & I/O 버스트**

 **프로세스는 다음 두 단계를 반복하며 실행됨**

| 구분                      | 설명                     | 예시             |
| ----------------------- | ---------------------- | -------------- |
| **CPU 버스트 (CPU Burst)** | CPU를 직접 사용하여 연산 수행     | 덧셈, 곱셈, 메모리 접근 |
| **I/O 버스트 (I/O Burst)** | CPU를 사용하지 않고 I/O 작업 수행 | 디스크 읽기, 키보드 입력 |

 **중요한 점**

- **각 프로세스마다 CPU 버스트와 I/O 버스트의 비율이 다름!**
- 따라서 **CPU 스케줄링을 통해 적절히 CPU를 할당해야 함**

## **프로세스의 유형**

 **CPU 사용 패턴에 따라 프로세스를 두 가지로 분류**

| 구분               | 설명        | 특징                                          |
| ---------------- | --------- | ------------------------------------------- |
| **CPU 바운드 프로세스** | CPU 연산 위주 | 긴 CPU 버스트, 연산이 많은 프로세스 (예: 과학 계산)           |
| **I/O 바운드 프로세스** | I/O 작업 위주 | 짧은 CPU 버스트, I/O 요청 많음 (예: 웹 브라우저, 대화형 프로그램) |

 **그래프 예시**

- **I/O 바운드 프로세스** → 짧은 CPU 사용 후 **I/O 요청 많음**
- **CPU 바운드 프로세스** → **CPU 사용 시간이 길음**

## **그래서 CPU 스케줄링이 왜 필요할까?**

 **현대의 운영체제는 여러 프로세스를 동시에 실행해야 함**

- **모든 프로세스의 CPU 사용 패턴이 다름**
- 어떤 프로세스는 **CPU를 오래 사용**, 어떤 프로세스는 **I/O를 자주 수행**
- **CPU를 적절히 나누어 사용해야 함 → CPU 스케줄링 필요!**

 **효율적인 CPU 스케줄링이 필요한 이유**

1. **응답 시간 단축** → 사용자의 입력에 빠르게 반응
2. **CPU & I/O 장치 활용 극대화** → CPU와 I/O 장치가 쉬지 않고 동작하도록 함
3. **여러 프로세스를 공정하게 실행** → 특정 프로세스가 독점하지 않도록 함

## **CPU 스케줄링 전략: I/O 바운드 프로세스 우선 배치**

 **I/O 바운드 프로세스를 먼저 실행하는 것이 유리함!**

- **I/O 작업이 많아 CPU를 오래 사용하지 않음** → CPU를 **잠깐 사용한 후 I/O 대기**
- 다른 프로세스가 **CPU를 사용할 기회 증가**
- 결과적으로 **CPU와 I/O 장치의 사용률이 높아짐**
    

 **CPU 바운드 프로세스를 먼저 실행하면?**

- 긴 CPU 버스트로 인해 **다른 프로세스들이 CPU를 기다려야 함**
- **I/O 장치는 놀게 됨** → 시스템 전체 성능 저하

 **결론: "I/O 바운드 프로세스에 우선순위를 주는 것이 시스템 효율을 높인다!"**


### **CPU 스케줄러란?** (단기 스케줄러에 해당)

CPU 스케줄러는 **준비 상태(Ready Queue)에 있는 프로세스들 중 하나를 선택하여 CPU를 할당하는 역할**을 수행하는 운영체제의 핵심 기능이다.

- 실행 중인 프로세스가 **CPU를 반납**해야 하는 상황이 발생하면 **CPU 스케줄러가 동작**한다.
- **타이머 인터럽트**가 발생하면 **스케줄러가 호출**된다.

### **CPU 스케줄러가 필요한 순간**

CPU 스케줄러는 다음과 같은 경우에 CPU 할당을 결정한다.

| 상황                                        | 설명                            |
| ----------------------------------------- | ----------------------------- |
| **CPU 사용 중인 프로세스가 I/O 요청을 수행**            | 실행 상태 → 봉쇄(Blocked) 상태        |
| **CPU 사용 중인 프로세스가 타이머 인터럽트 발생으로 CPU를 반납** | 실행 상태 → 준비(Ready) 상태          |
| **I/O 완료 후 프로세스가 다시 CPU를 요청**             | 봉쇄(Blocked) 상태 → 준비(Ready) 상태 |
| **프로세스가 종료됨**                             | 실행 상태 → 종료(Terminated) 상태     |
## **CPU 스케줄링의 2가지 방식**

 CPU 스케줄링 방식은 **프로세스가 CPU를 점유하는 방식에 따라 2가지로 나뉜다.**

| 방식                        | 설명                                     | 예시                   |
| ------------------------- | -------------------------------------- | -------------------- |
| **선점형 (Preemptive)**      | 프로세스가 CPU를 사용하고 있더라도 **강제로 중단 가능**     | 타이머 인터럽트, 우선순위 스케줄링  |
| **비선점형 (Non-Preemptive)** | 프로세스가 스스로 CPU를 반납하기 전까지 **CPU를 계속 사용** | 프로세스가 종료될 때까지 CPU 유지 |


 **현대 운영체제는 대부분 "선점형 스케줄링"을 사용한다.**

## **디스패처 (Dispatcher)**

 **디스패처란?**

- CPU 스케줄러에 의해 선택된 프로세스가 실제로 **CPU를 사용하도록 전환하는 역할**을 한다.
- **컨텍스트 스위칭(Context Switching)** 작업도 포함된다.
- **디스패처는 다음 3가지 작업을 수행**
    
    1. **CPU를 새 프로세스에 이양**
    2. **모드 변경 (User Mode ↔ Kernel Mode)**
    3. **컨텍스트 스위칭 수행**

 **디스패치 지연시간 (Dispatch Latency)**

- 디스패처가 **새로운 프로세스를 실행하기까지 걸리는 시간**
- **컨텍스트 스위칭 오버헤드가 주요 원인**

 **즉, 디스패처가 빨리 동작할수록 CPU 스케줄링의 효율성이 증가한다.**

## **CPU 스케줄링 성능 평가 지표**

 CPU 스케줄링의 성능은 **시스템 관점과 사용자 관점에서 평가**

### ** 시스템 관점 (운영체제 입장)**

| 성능 지표                         | 설명                      | 목표            |
| ----------------------------- | ----------------------- | ------------- |
| **CPU 이용률 (CPU Utilization)** | CPU가 실제로 **일한 시간의 비율**  | 최대화 (높을수록 좋음) |
| **처리량 (Throughput)**          | **일정 시간 동안 처리된 프로세스 수** | 최대화 (많을수록 좋음) |

 **비유**: CPU 이용률과 처리량은 **중국집 주방장** 입장에서 중요

- **CPU 이용률이 높을수록** 주방장이 쉬지 않고 일함
- **처리량이 많을수록** 많은 요리를 빠르게 제공

### **사용자 관점 (사용자 경험 측면)**

| 성능 지표                      | 설명                             | 목표            |
| -------------------------- | ------------------------------ | ------------- |
| **소요시간 (Turnaround Time)** | 프로세스가 요청 → 종료까지 걸린 시간          | 최소화 (빠를수록 좋음) |
| **대기시간 (Waiting Time)**    | CPU를 사용하기 위해 **준비 큐에서 기다린 시간** | 최소화           |
| **응답시간 (Response Time)**   | 처음 CPU를 획득하기까지 기다린 시간          | 최소화           |

 **비유**: 사용자 관점 지표는 **중국집 손님** 입장에서 중요

- **소요시간이 짧을수록** 손님이 빨리 음식을 받음
- **대기시간이 짧을수록** 주문 후 기다리는 시간이 짧음
- **응답시간이 짧을수록** 주문하자마자 요리가 시작됨

## **결론: CPU 스케줄링의 목표**

 **CPU 이용률과 처리량을 최대화** (시스템 관점)  
 **소요시간, 대기시간, 응답시간을 최소화** (사용자 관점)  
 **I/O 장치와 CPU를 효율적으로 활용하여 성능을 극대화**


### **CPU 스케줄링 알고리즘 정리**

#### **1. 선입선출 (FCFS, First-Come First-Served)**

- **개념**: 준비 큐에 도착한 순서대로 CPU를 할당하는 방식.
- **특징**: 프로세스가 자발적으로 CPU를 반납할 때까지 유지.
    
- **단점**:
    - 하나의 프로세스가 오래 CPU를 점유하면 다른 프로세스가 대기해야 함.
    - **콘보이 효과**: 짧은 프로세스가 긴 프로세스 때문에 오래 기다리는 현상 발생.
        

#### **2. 최단작업 우선 (SJF, Shortest-Job First)**

- **개념**: CPU 버스트가 가장 짧은 프로세스에게 CPU를 우선 할당하는 방식.
    
- **종류**:
    - **비선점형**: CPU를 할당받은 프로세스가 종료될 때까지 CPU를 유지.
    - **선점형**: 더 짧은 프로세스가 도착하면 현재 프로세스를 중단하고 새 프로세스에 CPU 할당.
        
- **장점**: 평균 대기시간이 짧아짐.
- **단점**: 프로세스의 CPU 버스트 시간을 미리 알기 어려움.
    

#### **3. 우선순위 스케줄링 (Priority Scheduling)**

- **개념**: 각 프로세스에 우선순위를 부여하고, 가장 높은 우선순위의 프로세스에 CPU를 할당하는 방식.
    
- **종류**:
    - **비선점형**: CPU를 한 번 할당받으면 프로세스가 종료될 때까지 유지.
    - **선점형**: 더 높은 우선순위의 프로세스가 도착하면 현재 프로세스를 중단하고 CPU 할당.
        
- **단점**:
    - **기아 현상**(Starvation): 낮은 우선순위 프로세스가 CPU를 계속 할당받지 못할 수 있음.
    - **해결책**: **노화(Aging)** 기법 사용 (오래 기다린 프로세스의 우선순위를 점진적으로 상승).

#### **4. 라운드 로빈 (RR, Round Robin)**

- **개념**: 모든 프로세스가 **동일한 시간(Time Quantum)** 동안 CPU를 할당받고, 시간이 지나면 대기 큐로 이동하는 방식.
    
- **특징**:
    - 공정한 스케줄링 방식.
    - 시분할 시스템(Time-Sharing System)에 적합.
- **장점**:
    - 응답 시간이 짧아 **대화형 시스템(Interactive System)** 에 적합.
    - CPU 버스트 시간이 긴 프로세스도 불이익을 받지 않음.
- **단점**:
    - **시간 할당량**이 너무 크면 FCFS처럼 동작.
    - 너무 작으면 **컨텍스트 스위칭 오버헤드**가 커짐.

#### **5. 다단계 큐 스케줄링 (Multi-Level Queue Scheduling)** (멀티레벨 큐)

- **개념**: 준비 큐를 여러 개로 분할해 관리하는 방식.
    
- **특징**:
    - **대화형 작업**(Foreground)과 **계산 작업**(Background)으로 큐를 나눔.
    - 각 큐에 다른 스케줄링 알고리즘 적용 (예: 전위 큐는 RR, 후위 큐는 FCFS).
        
- **큐 간 스케줄링 방식**:
    - **고정 우선순위 방식**: 우선순위가 높은 큐가 CPU를 독점할 가능성이 있음.
    - **타임 슬라이스 방식**: 각 큐에 CPU 시간을 비율로 할당하여 기아 현상 방지.
        
#### **6. 다단계 피드백 큐 (Multi-Level Feedback Queue)**

- **개념**: 다단계 큐처럼 여러 개의 큐를 사용하되, **프로세스가 다른 큐로 이동할 수 있는 방식**.
    
- **특징**:
    - CPU 점유 시간이 짧은 프로세스는 높은 우선순위 큐에서 빠르게 처리.
    - CPU 점유 시간이 길어지면 낮은 우선순위 큐로 이동.
    - 오래 기다린 프로세스를 높은 우선순위 큐로 승격(노화 기법).
        
- **장점**: 다양한 스케줄링 기법을 융합하여 효율적 운영 가능.
    
#### **7. 다중처리기 스케줄링 (Multiprocessor Scheduling)**

- **개념**: CPU가 여러 개인 시스템에서 CPU를 스케줄링하는 방식.
- **방식**:
    - **공유 큐 방식**: 하나의 준비 큐에서 여러 CPU가 프로세스를 꺼내 실행.
    - **개별 큐 방식**: 각 CPU별로 준비 큐를 따로 관리.
- **부하 균형 (Load Balancing)** 문제 해결 필요.
    
- **스케줄링 방식**:
    - **대칭형 (SMP, Symmetric Multiprocessing)**: 각 CPU가 독립적으로 스케줄링.
    - **비대칭형 (AMP, Asymmetric Multiprocessing)**: 특정 CPU가 스케줄링을 전담.

#### **8. 실시간 스케줄링 (Real-Time Scheduling)**

- **개념**: 주어진 **데드라인** 안에 작업을 반드시 완료해야 하는 스케줄링.
    
- **종류**:
    - **Hard 실시간 시스템**: 데드라인을 반드시 준수해야 함 (예: 원자로 제어, 미사일 발사).
    - **Soft 실시간 시스템**: 데드라인을 약간 초과해도 괜찮음 (예: 비디오 스트리밍).

### **CPU 스케줄링 알고리즘 평가 방법**

1. **큐잉 모델 방식**
    - 확률분포를 통해 프로세스 도착률과 CPU 처리율을 분석하여 평균 대기시간 등을 계산.
        
2. **시뮬레이션 방식**
    - 가상의 CPU 스케줄링 프로그램을 작성하고 결과를 확인.
        
3. **구현 및 실측 방식**
    - 실제 OS 커널의 CPU 스케줄링 코드를 수정하고 직접 실행하여 평가.

### **요약**

| 스케줄링 알고리즘                      | 특징                 | 장점                  | 단점                |
| ------------------------------ | ------------------ | ------------------- | ----------------- |
| **FCFS** (선입선출)                | 도착 순서대로 CPU 할당     | 단순, 공정              | 콘보이 효과 발생         |
| **SJF** (최단작업 우선)              | 짧은 프로세스를 우선 실행     | 평균 대기시간 감소          | CPU 버스트 시간 예측 어려움 |
| **Priority** (우선순위)            | 우선순위 높은 프로세스 우선 실행 | 중요 작업 우선 처리 가능      | 기아 현상 발생 가능       |
| **Round Robin** (라운드 로빈)       | 일정 시간 할당 후 교체      | 공정성 보장, 대화형 시스템에 적합 | 시간 할당량 설정이 중요     |
| **Multi-Level Queue** (다단계 큐)  | 여러 개의 준비 큐 사용      | 다양한 환경 지원 가능        | 큐 간 스케줄링 문제       |
| **Multi-Level Feedback Queue** | 다단계 큐 + 프로세스 이동 가능 | 기아 현상 방지, 유연함       | 구현이 복잡            |
| **Multiprocessor Scheduling**  | 다중 CPU 환경에서의 스케줄링  | 처리 속도 향상            |                   |

### 1. **홀블로킹 (Whole Blocking)**

- 프로세스가 **자원을 요청했을 때** 해당 자원이 사용 중이면 **완전히 대기(Blocking)하는 방식**.
- CPU를 사용하지 않고 **대기 상태**로 전환됨.
- 자원이 사용 가능해질 때까지 실행되지 않음.
- 단점: 자원을 기다리는 동안 CPU를 낭비하지는 않지만, 다른 작업을 수행할 수 없어서 전체적인 시스템 성능이 저하될 수 있음.
- 
### **HRN 스케줄링 (Highest Response Ratio Next)**

- **우선순위 기반 스케줄링 기법** 중 하나.
- 기아 현상(Starvation)을 방지하면서 **긴 작업도 적절히 실행될 수 있도록** 조정하는 방식.
- **대기 시간이 길수록 우선순위가 높아지는 방식**으로 동작.
    

#### 응답률 (Response Ratio):

- **대기 시간이 길어질수록** 응답률이 증가 → 오래 기다린 프로세스가 우선적으로 실행됨.
- **서비스 시간이 짧을수록** 응답률이 커지기 어려움 → 짧은 작업이 빠르게 처리될 가능성이 큼.
    
####  특징

- **FCFS (선입선출) + SJF (최단 작업 우선) 기법의 장점을 조합한 방식**.
- SJF처럼 짧은 작업을 우선 실행하되, 대기 시간이 길어진 작업도 점점 우선순위가 높아짐.
- **기아 현상 방지 가능**.

####  ex)

| 프로세스 | 도착 시간 | 실행 시간 | 대기 시간 | 응답률 (계산)    |     |
| ---- | ----- | ----- | ----- | ----------- | --- |
| P1   | 0     | 4     | 0     | (0+4)/4 = 1 |     |
| P2   | 1     | 3     | 3     | (3+3)/3 = 2 |     |
| P3   | 2     | 2     | 4     | (4+2)/2 = 3 |     |

- 초기에는 실행 시간이 짧은 P3이 선택될 가능성이 높지만, 시간이 지남에 따라 P2가 실행됨.
- P1은 처음 실행되므로 응답률이 1이고, 대기 시간이 쌓이면서 점점 높아짐.
    

 **HRN의 장점**

- SJF보다 **기아 현상이 적음**.
- **대기 시간이 길어지면 자동으로 우선순위가 증가**.
- 비교적 공정한 방식.

 **HRN의 단점**

- 모든 프로세스의 응답률을 **계속 계산해야 하므로 오버헤드**가 발생할 수 있음.
- 실시간 시스템에는 적합하지 않음.