## Introduction

간단하게
**파일시스템이란?**
파일의 실제 데이터와 메타데이터(파일의 위치, 크기, 소유자, 허가권 등 ls -al로 볼 수있는 파일 정보)를 유지/저장하는 체계

파일에 이름을 붙이고, 저장이나 검색을 위해 논리적으로 그것들이 어디에 위치시켜야 하는지 등을 나타내는 방법

윈도우, OS/2, 매킨토시 및 유닉스 기반의 운영체계들은 모두 파일들이 **어딘가에 계층적인 구조로 위치하는 파일 시스템**을 가지고 있음
파일은 계층구조 내의 올바른 디렉토리 또는 서브디렉토리 내에 놓여진다.
- 디렉토리/서브디렉토리 ??

## 1. 파일시스템 (File System)

### 파일시스템이란?
![](https://i.imgur.com/cO7ifaz.png)

컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 or 조직하는 체제를 가리키는 말
저장 매체의 크기가 증가할수록 보관하는 파일의 수 또한 증가하게 되어 별도의 관리 시스템이 필요해짐
-> 이를 해결하기 위해 개발된 것이 파일시스템 
파일시스템 종류 `UFS, FAT16, FAT32, NTFS, ext2, ext3, ext4, HFS+` 등이 있음

### 파일이란?

파일 : 프로그램 또는 데이터 등과 같은 정보들의 집합

이러한 정보들을 저장할 수 있는 기억장소 공간은 디스크에 할당되어 있는데,
디스크에 존재하는 여러 파일들은 **각자 고유한 이름**을 가짐으로서 구별됨

### 파일 시스템 구조

![](https://i.imgur.com/AZ3UFK3.png)

파일시스템은 파일에 대한 메타데이터 즉, 파일 데이터의 데이터가 저장된 영역과 
실제 데이터가 기록된 영역 2가지로 구분됨

메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제 유무 등 파일에 대한 정보
데이터 영역 : 파일의 데이터

### 파일시스템 특징

계층적 디렉토리 구조를 가짐
디스크 파티션 별로 하나씩 둘 수 있음 -> 파티션 : 논리적인 디스크의 구성단위임
윈도우 기준 c 드라이브 / d 드라이브 등등의 파티션이 나뉘고 이걸 기준으로 트리 계층으로 파일 시스템이 생김

### 파일시스템 역할

⦁ 파일관리 : 파일 저장, 참조, 공유  
⦁ 보조 저장소 관리 : 저장 공간 할당  
⦁ 파일 무결성 메커니즘 : 파일이 의도한 정보만 포함하고 있음을 의미  
⦁ 접근 방법 : 저장된 데이터에 접근할 수 있는 방법 제공


### 파일시스템 목적

⦁ HDD(하드 디스크 드라이브 -> 비휘발성, 순차 접근이 가능한 보조 기억장치)와 메인 메모리 속도차 줄이기  
⦁ 파일 관리 용이  
⦁ HDD의 막대한 용량을 효율적으로 이용

### 파일시스템은 왜 필요한가

파일 시스템은 **디스크의 고정된 블록 단위 저장 방식과, 사용자가 원하는 연속적인 바이트 단위 접근 방식 간의 간극을 연결**해주는 역할을 함
사용자는 파일 이름만 알고 데이터를 접근하지만, 실제 저장은 **디스크 곳곳의 블록에 분산되므로**, 이를 **관리하고 매핑하는 구조가 필요**  
즉, **파일 시스템은 사용자와 하드웨어 사이에서 데이터를 효율적이고 일관되게 다룰 수 있게 해주는 핵심 계층**

## 2. 파일시스템 마운팅

파일 시스템을 실제로 사용 가능하게 만드는 첫 단계 -> **마운트**

마운트(mount)란
운영체제가 어떤 저장 장치를 "내 디렉토리 트리 안에 붙여서 사용할 수 있게 만드는 작업"

운영체제의 디렉토리 구조 = 하나의 거대한 책장이라 볼 수 있고
하드디스크, SSD, USB 등 저장 장치 = 책 한 권이라 볼 수 있는데

책을 꽂아야 뭐 그 책을 다시 빼서 확인을 하든 읽든 할 수 있듯이
운영체제도 **마운트**를 해야 그 안의 파일에 접근할 수 있음

운영체제는 처음부터 모은 저장 장치를 알지 못하기 때문에
USB를 꽂거나 외장하드를 붙이거나 네트워크 파일 시스템 연결을 하더라도 마운트 하지 않으면
OS는 내부 파일 시스템에 접근하지 못함

마운트를 수행할 때 운영체제에게 '이 장치를 여기 디렉토리에 붙여서 사용하자'라고 알려주고, 파일 시스템을 특정 디렉토리에 붙이면 그때부터 /mnt/usb 같은 경로로 파일탐색/읽기/쓰기 등의 실제 사용이 가능해짐

## 3. 파일시스템 (File System) 모델

![](https://i.imgur.com/YcMY0KB.png)

### 슈퍼블록 (Super Block)

UFS (Unix File System)에서 슈퍼블록은 수많은 정보들을 포함하고 있음 
이러한 값들로 파일 시스템에 레이아웃 정의가 가능해짐

슈퍼블록에 있는 파일시스템 상태를 기술하는 여러 필드에는
- filesystem의 크기
- filesystem 내의 free block 수
- inode의 list 크기
- filesystem 내의 free inode 수
- filesystem 내의 free inode의 list
- free inode list의 다음 free inode의 index
- free block list와 free inode list를 위한 lock field

등이 존재

### inode (Index Node)

inode는 파일에 대한 메타데이터(정보)를 저장하는 구조체
우리가 흔히 말하는 **파일 정보의 집합**임
이름, 접근 권한, 실제 저장 위치 (**데이터 블록 위치**) 등은 inode안에 기록됨

근데 이때 inode에는 파일 이름이 없음
파일 이름은 디렉토리 엔트리에서 **inode 번호**와 연결돼 있음
어느 한 파일이나 디렉토리가 만들어질 경우 그에 해당하는 하나의 inode가 만들어지고, 그 inode가 inode list에 등록되는데, 이때 등록된 번호를 'inode 번호'라고 하는 것

예시로, 디스크 안에 hello.txt와 data.bin이라는 파일이 있다하자

디렉토리는
`"hello.txt" → inode 번호 123`
`"data.bin" → inode 번호 456`
이렇게 매핑할 뿐이고, 진짜 정보는 inode 123, 456 안에 있게 되는 것

e.g.
cat hello.txt 를 진행하면
- 디렉토리에서 `"hello.txt"` → inode 번호 123 찾음
- inode 123을 읽어서:
    - 이 파일의 크기, 권한, 마지막 수정 시간
    - 실제 데이터가 저장된 **디스크 블록 위치들**
- 그 블록들을 읽어와서 사용자에게 보여줌

inode는 실제 파일 데이터를 저장하는 블록들을 **직접 가리키거나**,  
필요할 경우 **간접 포인터를 통해 더 많은 블록을 연결**함
-> 즉, inode 하나만으로도 수십 GB ~ TB 파일 표현이 가능해짐


> inode는 **파일을 대표하는 정보 묶음(메타데이터)** 이며,  
**디스크에 저장된 블록들과 파일 간의 연결고리** 역할을 함
디렉토리는 단지 이름과 inode 번호를 연결해주는 “주소록”일 뿐이고,  
진짜 파일의 실체는 inode가 관리!!


### Data Block

데이터블록은 inode에 포함됨 
inode는 몇 개의 데이터블록을 포함하고 있으며, 각 데이터블록은 **파일들의 데이터를 실제로 저장**하고 있음

📦 나 혼자 들어보는 예시

|단계|설명|
|---|---|
|1. 디렉토리에서 파일 이름 찾음|`hello.txt → inode 123`|
|2. inode 123에서 데이터 블록 위치 확인|`direct[0] = 블록 #105` 등|
|3. 해당 블록들에서 **파일 내용 읽어옴**|블록 105, 106, ...|

### Indirection Block

간접 블록
추가적인 데이터블록을 사용하기 위한 포인터들이 할당되는 공간
실제로 inode는 적은 수의 데이터블록을 갖고 있기 때문에 더 많은 데이터블록이 필요할 경우 이를 동적으로 가리킬 포인터가 저장됨 
이 포인터들이 할당되는 곳


### directory file

![](https://i.imgur.com/AC3GQuE.png)

- directory = file 이름들의 저장 창고
- 디렉토리는 각 파일의 이름과 그 파일 자체를 서로 연결!!!시켜주는 역할 하므로 파일 시스템의 전체적 구조를 결정지어줌
- directory는 많은 file들을 포함하며 또한 마찬가지로 여러 file들을 갖는 sub directory를 가질 수 있음
- directory는 ordinary file과 구별되는 개념이지만 읽힐 때는 ordinary file과 똑같이 행동함
- 모든 directory는 적어도 '.'와 '..'라는 file을 가지고 있어야 하는데, '.'은 directory file 자체를 지시하고 '..'은 그 directory의 상위 directory를 나타냄
- 이들 file들을 이용하여 전체 file 시스템을 루트에서부터 차례로 내려오면서 모든 file을 탐색할 수 있음
    
- pathname(경로명)  
    모든 file은 자신이 속해 있는 directory가 있으므로 어느 한 file을 지정하기 위해서는 그 file명은 물론 그 File이 속해 있는 directory name도 지정해야 함
    따라서 file을 지정하기 위해서는 관련 directory name과 file명 그리고 '/'로 이루어지는 pathname(경로명)이 필요!!
    - 절대 path  
    - 상대 path



### 디렉토리 구조 (Directory Structure)

#### 1단계 디렉토리
![](https://i.imgur.com/3nJlxVt.png)

모든 파일을 하나의 디렉토리에 다 넣는 구조
- 서브 디렉토리 X
- 이름 겹치면 X
- 파일 수가 많아지면 관리 어려움
간단하지만, 확장성과 관리성이 떨어지는 구조


#### 2단계 디렉토리
![](https://i.imgur.com/8oWeHHS.png)

각 사용자가 자기만의 디렉토리(UFD)를 가지며,
시스템은 마스터 디렉토리 (MFD)를 통해 각 사용자 디렉토리에 접근할 수 있음

사용자 간 파일 이름 충돌은 해결되지만, 파일 공유는 어려움

#### 트리 구조 디렉토리
![](https://i.imgur.com/aN9ankY.png)

여러 단계로 확장하는 일반적인 방법의 임의의 높이를 갖는 트리 구조
일반 사용자들에게 자신의 서브 디렉토리를 얼마든지 만들 수 있게 해줌
가장 일반적인 디렉토리 구조!!

#### 비순환 그래프 디렉토리
![](https://i.imgur.com/xBN0xwX.png)

트리 구조는 파일 또는 디렉토리의 공유를 허용하지 X
비순환 그래프는 디렉토리들이 서브디렉토리들과 파일들을 공유할 수 있도록 허용하는 구조

똑같은 파일이나 서브디렉토리가 서로 다른 서브디렉토리에 존재할 수 있음

파일을 공유하는 방법으로는 
	- 링크(link)라 불리는 새로운 디렉토리 항목을 만드는 것 (다른 파일/서브디렉토리를 가리키는 포인터 가지고 참조)
	- 디렉토리들이 동일한 항목 내용을 복사해서 가지고 있는 방법 (일관성에 문제생김)

**바로가기** 같은 건데... -> 순환 구조는 없다 !!
#### 일반 그래프 디렉토리
![](https://i.imgur.com/lqZfkjN.png)

비순환 그래프 트리구조의 문제점 = 순환이 발생하지 않도록 보장하는 것이 어려움

2단계 디렉토리부터 시작해서 사용자가 서브디렉토리를 생성하면 트리 구조가 형성됨
단순히 새로운 파일이나 디렉토리를 기존의 트리 구조 디렉토리에 추가하는 것은 트리 구조의 성질을 유지
but 기존의 트리에 새로운 링크를 추가하면 **트리 구조는 파괴되고 일반적인 그래프 구조가 될 수 있음**


#### Meta data
- 파일 사용자 ID, 파일 형태, 크기, 저장장소, 정보의 장소(offset), 버퍼, 시간 정보(생성시간, 최근 읽기,쓰기된 시간)등의 정보들이 저장된 데이터 의미
- 파일에 접근하는데 필요한 정보를 가진 Meta data가 있어야 파일이 제대로 관리될 수 있으며 이들은 디스크 내부에 파일과 별도로 저장

#### 버퍼 캐쉬 (buffer cache)
파일 사용자와 디스크 사이에 자리 잡고 **완충 역할**하게되는 장치
파일 사용할 때마다 디스크에서 일일이 읽어오려면 속도 매우 느리기때문에
처음 읽은 파일은 버퍼 캐쉬에 저장해 둠으로써 이후 동일한 파일을 읽어들여야할 때 읽어오는 속도 늘릴 수 있음
바로 파일에 접근하는 것도 지역적 성격을 갖고 있기 때문에 버퍼 캐쉬 사용 가능

but 버퍼 캐쉬가 무한정의 메모리 사용할 수는 없다

완충하는 역할은 그냥 거의 다 **캐시**다 !!!!!

## 4. 파일 시스템 구현


## 5. 파일시스템 종류

###  FAT (File Allocation Table)

마이크로소프트에서 빌게이츠가 만들었으며 전 세계적으로 가장 많이 사용되는 파일시스템
최초 제작시에는 크기 작았으며 최근에는 대용량으로 발전

- **FAT16**: MS-DOS 개발할 당시 사용하던 파일시스템 
	- 하나의 파티션으로 최대 2GB 설정 가능, 보안·압축 미지원, 용량 낭비 큼, MS OS에서 호환됨
- **FAT32**: 최대 2TB까지 지원, 긴 파일명 지원, 클러스터당 4KB로 용량 낭비 줄임, 보안·압축 여전히 미지원

### NTFS (New Technology File System)

- FAT의 한계를 보완한 **윈도우 표준 파일 시스템**
- 보안, 암호화, 실시간 압축, 트랜잭션 로그, 자체 오류 복구 등 **고급 기능 다수 지원**
- 최대 저장 용량, 긴 파일 이름, 충돌 보호 등 **서버 및 고성능에 적합**

### HPFS (High Performance File System)

- IBM OS/2용, NTFS 나오기 전 많은 영향을 준 파일시스템
- FAT보다 **단편화 적고 캐싱 효율적**
- 서버용 대용량에 강하지만, 대용량을 타켓으로 잡았기에 **소용량(200MB↓)에서 성능 저하** 존재

###  UFS (Unix File System)

- 전통적인 유닉스 파일 시스템, **빠른 속도·안정성** 중시
- 많은 유닉스 계열의 OS들이 UFS를 각각의 OS에 맞게 변형해서 사용하고 있음
- 데이터 그룹화, 중복 백업으로 **신뢰성 강화**
- Berkeley대학의 FFS(Fast File System) 기반 → 리눅스 **Ext2에 영향**

###  Ext2 (Second Extended File System)

- 리눅스 초기 기본 파일 시스템, **UFS에서 복잡한 부분 제거**
- **간결하고 빠른 구조**, 저널링 없음 (→ Ext3에서 추가됨)