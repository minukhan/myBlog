
# **프로세스가 무엇인가요?**

답변 : 프로그램을 수행하기 위해서 메모리에 적재되어있는 상태를 프로세스라고 한다. 이때 프로세스는 메모리와 CPU 를 점유하며 실제로 실행되고있는 상태를 말함. 각각의 프로세스는 PCB라는게 있고 이는 프로세스의 정보를 담고있는 블럭인데 이걸 통해서 다른 프로세스로 전환할때 상태를 유지할 수 있는 것.

- 프로그램 + 실행환경 이라고 생각하면 좋음.
    
- 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
    
    - 프로그램 : 디스크에 저장된 실행코드, 아직 실행되지 않은 상태를 말한다.
    - 프로세스 : 실행중인 작업 단위, 프로그램이 실행될 때 생성된다.
        - 코드, 데이터, 힙, 스택 , PCB 등 다양한 메모리를 가지고있음.
        - CPU에서 실행중인것
    - 스레드 : 프로세스 내에서 작업을 쪼개놨는데 그 작업을 실제로 수행하는 실행 단위.
        - 같은 프로세스 자원을 공유하고있어서 잘 처리해줘야함.
        - 스택은 별도로 가지고있음. 그러나 나머지는 프로세스와 공유.
- PCB가 무엇인가요?
    
    - Process Control Block 으로 프로세스에 대한 정보들을 가지고있는 블럭이다. 그 안에는
    - 프로세스 식별자 (PID) , CPU 상태, 메모리 정보, 스케쥴링 정보 등이 들어있다.
    - PCB 가 있기에 운영체제는 CPU를 다른 프로세스를 작업하다 와도 상태를 유지시킬 수 있고 나중에 다시 복귀 할 수 있는것.
- 그렇다면, 스레드는 PCB를 갖고 있을까요?
    
    - 스레드는 PCB를 가지고있지 않다. 스레드는 PCB를 공유하며 자원들을 접근한다. 이떄 공유자원을 잘 사용해야하기에 공유락, 베타락 등 자원 관리 방법이 나오게 된 것.
    - 대신에 TCB를 가지고있다. 스레드 컨트롤 블록으로 그 안에는 스택, 레지스터, 상태 정보가 들어있다.
    - 스레드는 Stack 은 별도로 가지고있다!!
- 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
    
    - 프로세스 생성할때는 fork 를 이용한다. 부모 프로세스의 PCB를 복사해서 자식 프로세스를 생성한다.
    - 스레드는 clone() , pthread_create() 를 사용해서 같은 프로세스 자원을 공유하고 독립적인 스택과 TCB만 생성한다.
- 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
    
    - 원래는 자식 프로세스가 종료하면 운영체제는 부모 프로세스에게 알려줌.
    - 근데 부모가 아직 확인하지 않으면 자식 PCB는 그대로 메모리에 남아있음. 이 상태를
    - 좀비 프로세스라고 부른다.
        - 실제 CPU 는 사용하지 않으나, 프로세스 테이블에서 자리를 차지한다.
        - 부모가 wait() 을 호출하면 PCB를 제거하고 좀비 상태가 사라지게 된다.
    - 왜 운영체제가 알려준다면서 부모는 모를까?
        - 운영체제는 자식 프로세스가 종료됐다는 사실과 종료상태를 기록한다.
        - 그 정보를 PCB에서 제거하고 자원을 회수하는일은 부모가 하는일임
        - 부모가 wait()를 호출해야 운영체제가 PCB를 완전히 삭제화고 프로세스를 정리하게 됨.
        - 운영체제는 종료 사실만 기록하고 부모가 확인할때까지 남아있는것.
- 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
    
    - 데몬 프로세스란?
        - 백그라운드에서 실행되는 특별한 시스템 프로세스를 말합니다.
        - 일반 사용자와 상호작용하지 않고 시스템 서비스나 기능을 지속적으로 제공합니다.
- 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
    
    - 리눅스에서 모든 프로세스는 부모- 자식 관계를 가지며 트리 구조를 형성하고 있습니다.
    - 예전에는 init 이 루트 프로세스였고 PID는 1로 고정되어있습니다. 그러나 현대 리눅스에서는 init 대신에 systemd 가 루트 프로세스로 사용되고있습니다.
    - 이전 init 보다 더 많은 기능을 제공하고 수행합니다.

# **프로세스 주소공간에 대해 설명해 주세요.**

답변 :

- 초기화 하지 않은 변수들은 어디에 저장될까요?
    
    - BSS 영역에 저장된다고 한다.
        - Block Started By Symbol 의 약자를 말함.
        - 프로그램 시작할때 0으로 초기화 된다.
        - 메모리를 효율적으로 사용하기 위해서 초기값 데이터를 포함하지 않는다.
- 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?
    
    - 둘다 매우 크지 않다고 할 수 있을 것 같습니다.
        - stack 은 컴파일 할때 OS가 프로세스를 생성할때 결정합니다.
        - Heap 은 프로그램 실행시 동적으로 증가합니다.
- Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
    
    - Stack 이 더 빠릅니다.
        - 그 이유는 CPU 레지스터 기반 접근을 한다.
        - **연속적인 메모리 접근 패턴**을 L1 캐시에 잘 적재해서 빠르게 읽고 쓸 수 있음
    - 그에 반면 Heap 은
        - 동적 할당으로 주소가 흩어져 있을 가능성이 높습니다.
- "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.
    
    - stack은 함수 호출 시 후입 선출을 따르며 지역 변수를 관리합니다.
    - 자료구조 stack 과 연관이 있다고 볼 수 있을 것 같습니다.
    - 그러나 Heap 영역은
        - 동적 메모리를 자유롭게 할당하고 해제합니다.
        - 자료구조와는 연관이 없습니다.
- 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?
    
    - stack 은 컴파일 할때 결정된다고 한다.
        - 유저가 수정할 수 있다고 함.
    - 프로그램 실행 중에 동적으로 증가가 가능하다.