
### 쿠키와 세션의 차이??

- 보통 토큰이랑 세션이랑 비교하지 않나??

### 쿠키란?? 

- 브라우저에 로그인 상태를 기록해놓아서 사용자가 더 편리하게 사용하도록 도와준다.
- 주로 세션 ID 나 토큰 같은 인증 정보를 운반하는데 쓰인다. 
- 옵션
	- HttpOnly : JS 접근 금지
	- Secure : HTTPS 에서만
	- SameSite :  CSRF 완화 

### 세션이란? 

- 서버 메모리 DB/Redis 등에 저장된 사용자 상태(로그인 유저, 권한, 장바구니)
- 클라이언트에서는 보통 세션 식별자(ID) 만 보관하고 매 요청마다 서버가 세션을 찾아서 쓴다. 

##### 세션의 흐름? 

- 로그인
	- 클라이언트에서 사용자가 아이디/비밀번호를 입력해서 서버로 전송한다. 
- 세션 생성
	- 서버는 DB/Redis등에 사용자의 상태(로그인 여부, 권한)을 저장하고 그 세션을 식별할 수 있는 세션 ID를 만든다. 
- 세션 ID 발급
	- 서버가 응답 헤더에(Set Cookie) 에 세션 ID를 쿠키로 내려준다. 
- 이후 요청
	- 브라우저는 매 요청마다 이 쿠키(세션ID)를 함께 보낸다. 
- 서버 검증
	- 서버는 세션 저장소에서 해당 ID를 찾아서 사용자 상태를 확인한다. 

> 클라이언트는 세션 ID만 가지고 있고, 실제 상태는 서버가 관리한다.

>[!important] 정리
>
>세션은 민감한 정보를 서버에 안전하게 보관할 수 있어서 보안성이 매우 높음. 
>쿠키는 자원을 소모하지 않고 빠른 처리가 가능. 하지만 저장 용량에 한계가 있음
>
>그래서 현대 웹앱에서는 두 기술을 혼합해서 중요한건 세션, 가벼운 정보는 쿠키로 관리. 

### 토큰이란?? 대표적으로 (JWT)

- 토큰 자체에 PayLoad에 데이터(정보)와 서명이 들어있는 문자열을 말함. 
- 서버가 누구인지 검증하고 신뢰한다. 

##### 토큰의 흐름

- 로그인
	- 사용자가 아이디/비밀번호를 입력해서 서버로 전송
- 토큰 발급
	- 서버는 인증에 성공하면 JWT를 생성한다.(payLoad, 서명을 포함)
- 토큰 저장
	- 클라이언트는 이 토큰을 쿠키나, 로컬 스토리지에 저장한다.
- 이후 요청
	- 요청할때 Authorization 헤더에 `Bearer <JWT>`를 붙여 보낸다.
- 서버 검증
	- 서버는 JWT 서명을 확인하고 payLoad에서 유저 정보를 꺼내서 사용한다. 

> 토큰 자체에 상태/정보가 들어있고, 서버는 토큰을 신뢰하는 구조임. 

`Authorization: Bearer ...`의 Bearer는 **HTTP 인증 방식**을 말한다. 

>[!note] 참고
>여기서 세션이랑 토큰방식이랑 다른점 
>서버가 사용자의 정보를 가지고 있냐 아니냐가 아님. 지금 현재 사용자의 상태(로그인 상태, 장바구니 상태) 
>같은것들을 기록해놓는다? -> 세션방식 
>기록하지 않고 토큰에 담아서 보낸다 -> 토큰방식


### HTTP는 왜 Stateless인가??

###### stateless란?
- 프로토콜 차원에서 상태를 기억하지 않는다. 
- 각 요청은 이전 요청과 독립적이다. 
- 과거 상태를 기억하지 않음.

##### 왜 Stateless라고 하는가??

- http는 요청 - 응답 단위가 서로 연결되어있지 않기때문에 
- TCP 같은 하위 계층은 연결을 유지할 수 있지만, HTTP 상태에서는 상태를 연결하지 않음. 

##### 그러면 Stateless의 장점이 뭐야??

- 단순함
	- 서버는 각 요청을 독립적으로 처리 가능. 구현이 간단.
- 리트라이 쉬움
	- 네트워크 에러나면 똑같은 요청 다시 보내도 문제없음.
- 확장성
	- 서버를 여러대 두어도 이전 상태를 공유할 필요가 없으니, 편리함. 
- 캐싱이 용이함
	- 특정 요청이 같은 응답을 내면 프록시/브라우저가 캐시 가능.

##### 하지만 상태는 필요하다. 

- 웹앱은 로그인, 장바구니 같은 상태가 필요함.
- - HTTP 자체는 Stateless지만, **쿠키 / 세션 / JWT 같은 기법**을 이용해 애플리케이션 레벨에서 상태를 관리
- 즉, “프로토콜은 Stateless, 애플리케이션은 Stateful” 구조가 됨.


### 무상태 프로토콜인 HTTP에서 상태를 유지하는 세션은 부적절한 인증 방식이 아닌가?

- 세션이 HTTP 프로토콜 자체를 변경하는 것이 아니라, 그 위에 **추상화된 상태 관리 계층을 구축**하는 방식으로 동작하기 때문에 가능하다고 함. 
- 세션 기반 인증은 부적절한 방식이 아니라, HTTP의 기본 원칙을 훼손하지 않으면서도 사용자에게 상태가 유지되는 듯한 경험을 제공하기 위한 매우 영리하고 실용적인 아키텍처 패턴 임

### 규모가 커지면서 여러대의 서버로 확장될경우 세션 어떻게 관리해?

##### 문제점

- 로드 밸런서가 사용자의 첫 요청은 A서버로, 두번째는 B서버로 보낸다면?? 
- B서버는 A서버에 저장된 세션 정보를 알지 못하므로 로그인이 풀리는 현상을 겪는다. 
	- 이를 세션 정합성 문제라고 하며 이를 해결하는 방법이 있음.

##### 세션 정합성 문제 해결 방법

#### 스티키 세션

- 로드밸런서가 특정 사용자의 모든 요청을 항상 동일한 서버로만 전달하도록 설정하는 방식.
- 보통 쿠키를 사용해서 사용자가 처음 연결했던 서버를 기억한다. 
##### 단점
- 트래픽을 균등하게 분산하려고 로드 밸런싱을 하는건데 이러면 특정 서버에만 부하가 가게됨.
- 만약 그 특정 서버에 장애가 발생되면 모든 세션 정보가 유실되어 다시 재로그인 해야함. 


#### 세션 클러스터링

- 클러스터를 구성하는 모든 서버가 세션 데이터를 서로 복제하여 공유하는 방식. 
- 하나의 서버에서 세션이 생성되거나 변경되면 전파시켜서 동기화시킴
- 이러면 한 서버가 다운되도 다른 서버에 가지고 있으니 중단없이 서비스 이어감. 

##### 단점

- 당연히 복제하는 과정에서 트래픽 발생 및 잦은 업데이트로 인한 성능 저하.
- 서버 수가 늘어날수록 부하가 늘어나므로 대규모 시스템에서는 부적합.
- 전파되다가 손실되면?? 데이터 정합성 문제가 발생할 수 있음. 

#### 세션 스토리지 분리

- 모든 세션 데이터를 웹 서버와 분리된 외부의 중앙 집중식 저장소에 저장하는 방식
- Redis, memcached같은 고속 인메모리 데이터 베이스가 여기에 사용됨. 
- 웹 서버들은 상태를 가지고 있지 않고, 필요할때 여기서 이 세션정보를 조회함. 
- 서버 확장하는데 문제없음, 매우 빠른 메모리니까 속도가 빠름. 

##### 단점

- 별도의 세션 저장소를 구축하고 유지보수해야함. 
- 만약 레디스가 문제가 생기면?? 시스템에 영향이 생김. 구현 복잡도 상승.


>[!note] 정리
>
>이렇게 발전해온 과정이 있고. 스티키 세션부터 세션 클러스터링, 세션 스토리지 분리 이렇게 발전해왔고 
>현대에서는 중앙세션 저장소 방식으로 대규모 처리 과정에서 확장성, 장애 허용성, 아키텍처 분리 측면에서 가장 뛰어나다고 판단하여 업계 표준으로 자리잡았음.

