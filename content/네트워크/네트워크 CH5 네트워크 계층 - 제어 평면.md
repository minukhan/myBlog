## 5.1 개요
### 5.1.1 네트워크 계층의 데이터 평면과 제어 평면 연결
- 포워딩 테이블(목적지 기반 포워딩의 경우)과 플로우 테이블(일반화된 포워딩의 경우)이 데이터 평면과 제어 평면을 연결
	-> 이 테이블들이 라우터의 로컬데이터 평면에서의 포워딩을 지정한다. 
> [!note] 여기서 목적지 기반 포워딩과 일반화된 포워딩에 대해 이야기하자면 목적지 기반 포워딩 즉, Destination Based Forwarding은 패킷에 쓰여진 Destination IP Address만을 보고 포워딩 작업을 수행하는 것이고, 이것을 확장시킨 개념인 일반화된 포워딩(Generalized Forwarding)은 Destination IP Address 뿐만 아니라 헤더에 있는 다른 다양한 필드들까지 보고 포워딩 작업을 수행하는 것 
> -> 일반화된 포워딩은 SDN(Software-Defined Networking), 정책 기반 라우팅, 세그먼트 라우팅 등 현대적인 네트워킹 기술에서 많이 활용되며, 단순히 패킷을 목적지로 전달하는 것을 넘어 네트워크 차원의 최적화와 다양한 서비스 요구사항을 충족시키는데 중요한 역할을 한다.   

![[Pasted image 20250313173715.png]]![[Pasted image 20250313173730.png]]
- 위 그림은 네트워크 라우팅 구조의 두 가지 모델을 비교하는 것이다.(전통적인 라우팅 모델 vs SDN 모델)
- 첫 번째 그림(목적지 기반 포워딩과 연관이 있음) -> 라우터별 제어
	1. 각 라우터 내부에 제어 평면과 데이터 평면이 함께 존재
	2. 각라우터가 독립적으로 자체 라우팅 알고리즘을 실행
	3. 라우터는 자체적으로 포워딩 테이블을 생성 및 관리
	4. 패킷 헤더 값(예 : 0110) 에 따라 출력 포트(예 : 2번 포트)로 패킷을 전달

	- 특징
		1. 일반적으로 목적지 IP 주소를 기반으로 라우팅 결정
		2. 라우팅 알고리즘이 각 라우터에서 독립적으로 실행되며, 주로 최단 경로를 계산
		3. 포워딩 테이블이 상대적으로 단순하고 목적지 주소 패턴에 따른 결정
- 두 번째 그림(일반화된 포워딩과 연관이 있음) -> 논리적 중앙 집중형 제어
	1. 중앙화된 제어 : 원격 컨트롤러(Remote Controller)가 네트워크 전체의 제어 평면을 담당
	2. 분리된 제어 평면 : 제어 평면이 개별 라우터에서 분리되어 중앙화됨
	3. 각 라우터에는 데이터 평면만 존재하며, 포워딩 테이블을 통해 피킷을 전달
	4. 원격 컨트롤러가 모든 네트워크 장치의 포워딩 테이블을 관리하고 업데이트

	- SDN은 그 자체로 일반화된 포워딩을 의미하지는 않지만, SDN 아키텍처가 일반화된 포워딩을 구현하기에 훨씬 적합한 환경을 제공
		-> 중앙 컨트롤러를 통해 다양한 조건에 따른 세밀한 포워딩 규칙을 정의하고 네트워크 전체에 일관되게 적용할 수 있기 때문
	- 특징
		1. 중앙 컨트롤러가 있어 더 복잡한 포워딩 규칙을 정의할 수 있음
		2. 목적지 주소뿐만 아니라 다양한 패킷 헤더 필드(소스 주소, 프로토콜, 포트 등)를 기반으로 결정 가능
		3. 전체 네트워크 상태를 고려한 더 지능적인 포워딩 결정 가능
		4. 트래픽 엔지니어링, QoS, 보안 정책 등 고급 기능 구현에 유리
##### 일반화된 포워딩의 다양한 행동 형태
- 라우터의 출력 포트로 패킷을 전달
- 패킷을 버리거나 복제
- 2, 3, 4 계층의 헤더 필드를 재작성
	- 2계층 : 이더넷 헤더
	- 3계층 : IP 헤더(TTL, ToS 등) - Time To Live, Type of Service
	- 4계층 : TCP/UDP 헤더(포트 번호 등)
### 5.1.2 제어 방식
##### 라우터별 제어
- 각 라우터마다 독립적인 제어 평면이 존재
- 개별 라우팅 알고리즘들이 제어 평면에서 상호작용
- 포워딩과 라우팅 기능이 모두 개별 라우터에 포함되어 있음
- 각 라우터는 다른 라우터의 라우팅 구성요소와 통신하여 자신의 포워딩 테이블값을 계산하는 라우팅 구성요소를 가짐
- OSPF, BGP 프로토콜이 이 방식을 기반으로 한다.
- 분산형 제어 방식으로 장애에 강하지만 일관성 유지가 어려움
![[Pasted image 20250313181905.png]]
##### 논리적 중앙 집중형 제어
- 원격 컨트롤러가 지역의 제어 에이전트(CA)와 상호작용
- 중앙 집중형 컨트롤러가 포워딩 테이블 작성하고 이를 모든 개별 라우터가 사용할 수 있도록 배포
- **일반화된 '매치 플러스 액션' 추상화**로 다양한 기능 수행 가능
    - 전통적인 IP 포워딩뿐만 아니라 부하 분산, 방화벽, NAT 등 기존에 별도의 장치로 구현되었던 기능 수행
    - 매치 플러스 액션
	    - SDN과 OpenFlow에서 중요한 개념
	    - 만약 이런 조건을 가진 패킷이라면, 이런 동작을 수행하라의 느낌
	    - 기본 원리
		    1. Match : 패킷의 특정 필드나 헤더 정보가 정의된 패턴과 일치하는지 확인
		    2. Action : 매치 조건이 충족되면 패킷에 대해 수행할 구체적인 작업
		- 특징
			- 패킷 처리를 위한 프로그래밍 가능한 모델 제공
			- 복잡한 네트워크 정책을 간단한 규칙으로 구현
			- 전통적인 라이팅보다 훨씬 세밀한 트래픽 제어 가능
- 컨트롤러는 프로토콜을 통해 각 라우터의 제어 에이전트와 상호작용
- CA는 서로 직접 상호작용하지 않고 포워딩 테이블을 계산하는 데도 적극적으로 참여하지 않음
- SDN(Software-Defined Networking)의 기본 원리
![[Pasted image 20250313182309.png]]
##### 제어 평면의 진화
- 초기 인터넷 : 완전 분산형 제어(라우터별 제어)
- 현대 : 논리적 중앙 집중형 제어 방식으로 점진적 전환
- 하이브리드 방식도 존재 : 일부는 중앙 집중형, 일부는 분산형으로 동작
	- 시간에 민감한 결정과 로컬 이벤트는 분산 처리, 전역 정책은 중앙 관리
	- 예시 
		1. Google의 B4 네트워크
			 - 글로벌 WAN 트래픽 관리는 중앙 컨트롤러
			- 로컬 장애 복구는 개별 라우터에서 처리
		2. 엔터프라이즈 네트워크
			- 부서 내부 트래픽은 로컬 라우터에서 처리
			- 부서 간 정책 및 보안 규칙은 중앙 컨트롤러에서 관리
	- 중앙 컨트롤러의 부하를 줄이고, 장애 내성을 높이며, 여전히 네트워크 전체에 일관된 정책을 적용할 수 있음
### 5.2 라우팅 알고리즘
- 라우팅 알고리즘의 목표는 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것
	: 좋은 결로란 최소 비용 경로를 의미한다.(Least Cost Path)
- 현실적으로는 네트워크 정책과 같은 실제 문제가 고려된다.
	ex) Y 기관에 속해 있는 라우터 x는 Z 기관이 소유한 네트워크가 보낸 패킷을 전달해서는 안 됨
#### 5.2.1 그래프
- 라우팅 문제는 그래프로 표현
- 그래프, G(N, E)
	- N : 노드(Node)의 집합 -> 노드는 패킷 전달 결정이 이루어지는 지점인 라우터를 나타냄
	- E : 에지(Edge)의 집합 -> 에지는 라우터들 간의 물리 링크를 나타냄
		- 에지는 비용 값을 가진다.(일반적으로 해당 링크의 물리적인 거리, 링크 속도, 링크와 관련된 금전 비용 등을 반영)
		- 하나의 에지는 집합 N에 속하는 한 쌍의 노드로 표시된다. (노드 A, 노드 B) 이런식으로
		- 집합 E에 포함된 어떤 에지 (x, y)에 대해 c(x, y) 간의 비용을 의미
		- 에지 (x, y)가 집합 E에 속하면, 노드 y는 노드 x의 이웃(neighbor)이라고 한다.
- 경로(Path)
	- 그래프 G(N, E)에서의 경로는 노드의 연속 (x1, x2, x3, ..., xp)
	- 노드 쌍은 집합 E에 속한 에지들
	- 경로의 비용 = 경로상 모든 에지 비용의 합
		- c(x1, x2) + c(x2, x3) + ... + c(xp-1, xp)
#### 5.2.2 라우팅 알고리즘의 분류
##### 제어 방식에 따른 분류
1. 중앙 집중형 라우팅 알고리즘(Centralized Routing Algorithm)
	- 네트워크 전체에 대한 완전한 정보를 기반으로 최소 비용 경로를 계산
	- 링크 상태(Link State, LS) 알고리즘 형태로 구현 -> 뒤에서 추가 설명
		: 전체 상태 정보를 갖는 알고리즘(이 알고리즘이 네트워크 내 각 링크의 비용을 알고 있어야 함)
	- 장점 : 전역 최적화 가능
	- 단점 : 확장성 한계, 단일 장애점 위험(중앙 집중형이므로)
2. 분산 라우팅 알고리즘(Decentralized Routing Algorithm)
	- 라우터들이 반복적이고 분산된 방식으로 최소 비용 경로를 계산
	- 각 노드는 직접 연결된 링크에 대한 비용 정보만 가지고 시작
	- 이웃 노드와의 정보 교환을 통해 점진적으로 경로 계산
	- 거리 벡터(Distance Vector, DV) 알고리즘 형태로 구현 -> 뒤에서 추가 설명
	- 장점 : 확장성, 분산화되어 장애에 내성을 가짐
	- 단점 : 수렴 시간이 길 수 있음, 라우팅 루프 가능성이 있음(패킷이 네트워크 내에서 무한히 순환하는 현상 -> 방지하기 위한 방법으로 TTL을 사용하는 방법이 있음)
##### 변화 대응 방식에 따른 분류
1. 정적 라우팅 알고리즘(Static Routing Algorithm)
	- 사람이 직접 링크 비용을 수정하는 등 느리게 변화
	- 예측 가능하고 안정적이지만 네트워크 변화에 둔감
2. 동적 라우팅 알고리즘(Dynamic Routing Algorithm)
	- 네트워크 트래픽 부하나 토폴로지 변화에 따라 라우팅 경로 변경
	- 주기적으로 혹은 토폴로지/링크 비용 변경에 직접적으로 응답하는 방식(토폴로지 변경 : 네트워크 구조 자체의 변화 -> 링크 추가/제거, 노드 추가/제거 등)
	- 토폴로지 : 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식
	- 장점 : 네트워크 변화에 빠른 대응
	- 단점 : 경로 루프나 경로 진동 같은 문제에 취약
> [!note] 경로 루프(Loop)
> - 데이터 패킷이 동일한 라우터들 사이를 무한히 순환하는 현상
> - 원인 : 잘못된 라우팅 테이블, 불완전한 라우팅 정보 공유
> - 해결책 : TTL 사용, 거리 벡터 알고리즘의 "무한대까지 카운트" 기법, 분할 수평선 기법

>[!note] 경로 진동(Oscillation) - 뒤에 또 있음
>- 라우팅 경로가 안정적으로 수렴하지 않고 지속적으로 변경되는 현상
>- 원인 : 비용 변경이 네트워크 전체에 전파되는 시간 차이, 트래픽 변화에 따른 동적 비용 측정
>- 영향 : 패킷 손실, 지연 증가, 대역폭 낭비, 네트워크 성능 저하
>- 해결책 : 경로 댐핑(route damping) 매커니즘, 라우팅 업데이트 타이머 조정
##### 부하 민감성에 따른 분류
1. 부하에 민감한 알고리즘(Load-Sensitive Algorithm)
	- 링크 비용이 현재 혼잡 수준을 반영하여 동적 변화
	- 혼잡한 링크에 높은 비용을 비과하여 우회 유도
	- 초기 ARPAnet 라우팅 알고리즘이 부하에 민감해서 어려움이 있었다.(경로 진동 현상을 초래할 수 있기 때문)
2. 부하에 민감하지 않은 알고리즘(Load-Insensitive Algorithm)
	- 현재 인터넷 라우팅 알고리즘(RIP, OSPF, BGP 등)이 이에 해당
	- 링크 비용이 현재 혼잡을 반영하지 않음
	- 안정적이지만 혼잡 상황에 최적화되지 않을 수 있다.
### 5.2.3 링크 상태(LS) 라우팅 알고리즘
##### 개념 및 작동 방식
- 네트워크 토폴로지와 모든 링크 비용이 알려져 있음 -> 링크 상태 알고리즘의 입력값으로 사용될 수 있음
- 각 노드가 링크 상태 패킷을 네트워크 전체에 브로드캐스트
	-> 패킷 내용 : 자신과 직접 연결된 링크의 식별자와 비용 정보
- 인터넷 OSPF 라우팅 프로토콜 같은 링크 상태 브로드캐스트(Link-State Broadcast) 알고리즘에 의해 수행된다.
##### 다익스트라 알고리즘(Dijkstra's Algorithm)
- 하나의 출발지 노드에서 네트워크 내 다른 모든 노드로의 최소 비용 경로를 계산
- k번째 반복 후 : k개  목적지 노드에 대한 최소 비용 경로 확정
- 시간복잡도 : O(n²), 효율적인 구현으로 O(n log n) 가능
- 기호 정의
	- D(v) : 알고리즘의 현재 반복 시점에서 출발지 노드부터 목적지 v까지의 최소 비용 경로의 비용
	- p(v) : 출발지에서 v까지의 현재 최소 비용 경로에서 v의 직전 노드
	- N’ : 최소 비용 경로가 확정된 노드 집합
##### 링크 상태 알고리즘 과정 - 중앙 집중형 라우팅 알고리즘
1. 초기화 단계
2. 반복 부분 : 수행 횟수는 네트워크의 노드 수와 같다.
![[Pasted image 20250313220006.png]]
![[Pasted image 20250313220057.png]]
![[Pasted image 20250313220104.png]]
-> 링크 상태 알고리즘을 수행한 결과
##### 포워딩 테이블
- 링크 상태 알고리즘이 종료된 후에 출발 노드로부터 각 노드까지의 최소 비용 경로상의 직접 노드를 알 수 있음
- 이를 통해 다음 홉 노드 정보를 포함한 포워딩 테이블 구성
![[Pasted image 20250313220541.png]]
##### 계산 복잡도
- 출발지에서 모든 목적지까지의 최단 경로를 찾는 과정
- 각 반복에서 아직 처리되지 않은 노드 중 최소 비용 노드를 선택
- 첫 반복에서 n개, 두 번째에서 n-1개, 세 번째에서 n-2개... 식으로 검사
- 총 검사 노드 수: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2
- 따라서 최악의 경우 시간 복잡도는 O(n²)
##### 진동(Oscillation) 문제
- 링크 상태 알고리즘 뿐만 아니라 혼잡이나 지연 시간을 기반으로 링크 비용을 산출하는 모든 알고리즘에서 발생할 수 있음
- 링크 비용이 트래픽 양에 따라 변할 때 사용
- 라우팅 결정이 반복적으로 왔다갔다하는 현상
- 방지 방법
	- 모든 라우터가 동시에 링크 상태 알고리즘을 실행하는 것 방지
		: 하지만 각기 다른 시작 시각에, 그러나 같은 주기를 갖도록 해서 실행하더라도  점진적으로 결국엔 서로 동기화된다는 것을 발견 
		-> 각 노드가 링크 상태 정보를 송신하는 시각을 임의로 결정하게 함으로써 회피(자기 동기화 방지)
	- 링크 비용을 천천히 변화시키는 댐핑(damping) 기법
### 5.2.4 거리 벡터 (DV) 라우팅 알고리즘
: 오늘날 실제로 사용되는 알고리즘
##### 특징
- 링크 상태 알고리즘이 네트워크 전체 정보를 이용하는 알고리즘인 반면,  거리 벡터 알고리즘은 반복적이고 비동기적이며 분산적이다.
- 분산적(distributed) : 각 노드는 하나 이상의 직접 연결된 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 이웃들에게 배포한다.
- 반복적(iterative) : 이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다.
- 비동기적(asynchronous) : 모든 노드가 서로 정확히 맞물려 동작할 필요가 없다.
##### 벨만-포드(Bellman-Ford) 식
- 최소 비용 경로의 비용을 수학적으로 표현
- 노드 x부터 y까지 최소 비용 경로의 비용은 다음과 같다
	-> `d_x(y) = min_v{c(x,v) + d_v(y)}`
- x에서 이웃 v로 이동 후, v에서  y까지 최소 비용 경로 선택
- 모든 이웃에 대해 계산한 값 중 최솟값 선택
- 벨만-포드 식의 해답은 각 노드 포워딩 테이블의 엔트리를 제공한다.
	- 위의 식을 최소로 만드는 이웃 노드를 v* 이고 노드 x가 노드 y에게 최소 비용 경로로 패킷을 보내기 원한다면, 노드 x는 패킷을 노드 v* 로 전달해야 한다.
	(노드 x의 포워딩 테이블에는 최종 목적지 y로 가기 위한 다음 홉 라우터로 v* 가 지정되어 있어야 한다.)
##### 거리 벡터 라우팅 알고리즘의 기본 아이디어
- 출발지 노드를 x라고 가정하면, 노드 x는 자신으로부터 집합 N에 속한 다른 노드 y까지의 최소 비용 경로의 비용 D.x(y)를 추정한다.
- D.x : 노드 x로부터 N에 속한 모든 다른  노드 y까지의 비용 추정값의 벡터
- DV 알고리즘을 통해 각 노드 x가 유지하는 정보
	- 직접 연결된 이웃 노드까지의 비용 c(x, y)
	- 자신의 거리 벡터(D.x) : 모든 목적지까지의 비용 추정값
	- 이웃 노드들의 거리 벡터(D.v)
- 작동 방식
	1. 각 노드는 자신의 거리 벡터를 주기적으로 이웃들과 공유
	2. 이웃으로부터 새 거리 벡터 수신 시 벨만-포드 식으로 자신의 벡터 갱신
	3. 갱신으로 변경 발생 시 이웃들에게 새 벡터 전송
		-> 이웃들도 이 정보를 바탕으로 거리 벡터 갱신
	4. 더 이상 변화 없을 때까지 반복
		-> 모든 노드가 자신의 거리 벡터를 비동기적으로 교환하는 동작을 계속하다 보면, 비용 추정값 D.x(y)는 노드 x에서 노드 y까지의 실제 최소 비용 경로의 비용인 d.x(y)로 수렴하게 된다.
- 특징
	- 분산적, 비동기적 작동
	- 최종적으로 모든 노드의 비용 추정값은 실제 비용으로 수렴
- 이런 과정을 거쳐 최종적으로 노드별 포워딩 테이블이 생성된다(각 목적지까지 가는 최적의 다음 홉)
##### 링크 비용 변경과 링크 고장
- 링크 비용 변경 시 알고리즘 동작
	1. 자신과 이웃 사이 링크의 비용이 변경된 것을 알게 됨
	2. 자신의 거리 벡터를 갱신한 후
	3. 최소 비용 경로의 비용에 변화가 있는 경우에는 이웃에게 새로운 거리 벡터를 보냄
###### 비용이 감소한 상황
- y에서 x로의 링크 비용이 4에서 1로 변한 상황
	![[Pasted image 20250314025605.png]]
- 진행 과정
	- t0 : y가 링크 비용의 변화를 감지하고, 자신의 거리 벡터를 갱신한 후 이 변경값을 이웃에게 알린다.
	- t1 : z는 y로부터 갱신 정보를 받고 자신의 테이블을 갱신한 후 이웃에게 새 거리 벡터를 전송한다.
	- t2 : y는 z로부터 갱신 정보를 받고 자신의 테이블을 갱신하고 y는 최소 비용 변화가 없으므로 y는 z에게 아무런 메시지를 보내지 않는다. (알고리즘 정지 상태)
- 결론 : 알고리즘이 빠르게 수렴한다.(2회 반복)
###### 비용이 증가한 상황
- y에서 x로의 링크 비용이 4에서 60으로 증가
- 진행 과정
	- t0 : y가 링크 비용 변화를 감지하고 노드 x까지 다음의 비용을 갖는 새로운 최소 비용 경로를 계산한다.
		![[Pasted image 20250314030421.png]]
		-> 우리는 네트워크 전체를 볼 수 있기 때문에 D.z(x) 값이 잘못되었다는 것을 알고 있지만 노드 y의 입장에서는 알 수 없다.
	- t1 : x로 가기 위해 y는 z로 경로 설정을 하고, z는 y로 경로 설정을 하는 라우팅 루프(routing loop)가 발생
		-> t1에 x를 목적지로 하는 패킷이 y나 z에 도착하면 포워딩 테이블이 변할 때까지 이 두 노드 사이에서 왔다 갔다 순환할 것
		-> 노드 y는 x까지의 새로운 최소 비용을 계산했으므로 z에게 새로운 거리 벡터를 보낸다.
	- t2 : z는 y로부터 갱신 정보를 받고 새로운 최소 비용을 계산한다.
		- D.z(x) = min{50 + 5, 1 + 6} = 7
		- x까지의 z의 최소 비용이 증가했으므로, 새로운 거리 벡터를 y에 알린다.
	- t3 : y는 z로부터 새로운 거리 벡터를 수신하고 새로운 최소 비용을 계산한다.
		- D.y(x) = min{60 + 0, 1 + 7} = 8
		- x까지의 y의 최소 비용이 증가했으므로, 새로운 거리 벡터를 z에 알린다.
	- 반복
-> 이렇게 계속 반복되는 문제를 무한 계수 문제(count-to-infinity) 라고 한다.
##### 포이즌 리버스(Poisoned Reverse)
- 방금 설명한 라우팅 루프 시나리오는 포이즌 리버스라는 방법을 통해 방지할 수 있다.
- 노드가 다른 노드를 통해 목적지로 경로 설정 시, 해당 노드에게 목적지까지 거리가 무한대라고 알림
	ex) z가 y를 통해 목적지 x로 가는 경로 설정을 했다면, z는 y에게 x까지의 거리가 무한대라고 알린다
		-> z는 y를 통과해서 x로 가는 동안 이런 거짓말을 계속하고 이렇게 되면 y는 z에서 x로 가는 경로가 없다고 믿게 되고, z가 계속해서 y를 통해 x로 가는 경로를 사용하는 동안은 y는 z를 통해 x로 가는 경로를 시도하지 않을 것이다.
- 포이즌 리버스가 모든 무한 계수 문제를 해결할 수 있는 것은 아니다.
	-> 2개 노드 간 루프는 감지하여 해결할 수 있지만, 3개 이상의 노드를 포함한 루프는 포이즌 리버스로 감지할 수 없다.
### 5.2.5 링크 상태 알고리즘과 거리 벡터 라우팅 알고리즘의 비교
##### 경로 계산 방법
- LS 알고리즘
	- 전체 네트워크 정보를 필요로 함
	- 각 노드는 다른 모든 노드와 브로드 캐스트를 통해 통신
	- 자신에게 직접 연결된 링크의 비용만 알림
- DV 알고리즘
	- 각 노드는 직접 연결된 이웃과만 통신
	- 자신으로부터 네트워크 내 모든 노드로의 최소 비용 추정값을 이웃들에게 제공한다.
##### 메시지 복잡성
- LS 알고리즘
	- 각 노드는 네트워크 내 각 링크 비용을 알아야 하며, 이를 위해서는 O(|N| |E|) 개의 메시지가 전송되어야 한다.
	- 링크 비용이 변할 때마다 새로운 링크 비용이 모든 노드에게 전달되어야 한다.
- DV 알고리즘
	- 매번 반복마다 직접 연결된 이웃끼리만 메시지 교환
	- 알고리즘 결과가 수렴하는데 걸리는 시간은 많은 요소에 좌우된다.
	- 링크 비용이 변하고, 이 새로운 링크 비용이 이 링크에 연결된 어떤 노드의 최소 비용 경로에 변화를 준 경우에만 수정된 링크 비용을 전파
##### 견고성
- LS 알고리즘
	- 라우터는 연결된 링크에 대해 잘못된 비용 정보를 브로드 캐스트 할 수 있다.
	- 노드는 링크 상태 브로드 캐스트를 통해 받은 패킷을 변질시키거나 폐기할 수 있다.
	
> [!note] 그러나 하나의 링크 상태 노드는 자신의 포워딩 테이블만 계산하기 때문에 링크 상태 알고리즘에서 경로 계산은 어느 정도 분산되어 수행된다.
>	-> 분산 계산을 통해 링크 상태 알고리즘은 어느 정도의 견고성을 제공한다.
- DS 알고리즘
	- 노드는 잘못된 최소 비용 경로를 일부 혹은 모든 목적지에 알릴 수 있다.
	- 각 반복마다 한 노드의 거리 벡터 계산이 이웃에게 전달되고 다음 반복에서 이웃의 이웃에게 간접적으로 전달된다.
		-> 거리 벡터 알고리즘을 사용하는 네트워크에서 한 노드의 잘못된 계산은 전체로 확산될 수 있다.
##### 실제 사용
-> 두 알고리즘 모두 인터넷에서 사용되고 있다
- OSPF : 링크 상태 알고리즘 기반
- RIP : 거리 벡터 알고리즘 기반
- BGP : 경로 벡터(Path Vector) 알고리즘 사용(DV의 변형)
## 5.3 인터넷에서의 AS 라우팅 : OSPF
- 네트워크를 동일한 라우팅 알고리즘을 수행하는 동종의 라우터 집합으로 간주하는 관점은 두 가지 문제점이 존재한다.
	1. 확장
		- 라우터의 수가 증가함에 따라 라우팅 정보의 통신, 계산, 저장에 필요한 오버헤드가 걷잡을 수 없이 증가
		- 전체 인터넷을 하나의 네트워크로 관리하기 불가능
	2. 관리 자율성
		- ISP는 일반적으로 자신의 네트워크를 원하는 대로 운용하거나 네트워크 내부 구성을 외부에 감추기를 원한다.
##### 자율 시스템(Autonomous System, AS)
: 위에서 설명한 문제점들은 라우터들을 자율 시스템으로 조직화하여 해결이 가능하다.
- 각 AS는 동일한 관리 제어 하에 있는 라우터의 그룹으로 구성
- 자율 시스템은 전 세계적으로 고유한 AS 번호(Autonomous System Number, ASN)으로 식별됨
	- IANA(Internet Assigned Numbers Authority)에서 할당
	- 16비트 및 32비트 ASN 사용
- 같은 AS 내 라우터는 동일 라우팅 알고리즘 사용
- 자율 시스템 내부에서 동작하는 라우팅 알고리즘을 AS 내부 라우팅 프로토콜(Infra-Autonomous System Routing)이라고 한다.
### 5.3.1 개방형 최단 경로 우선(OSPF) 프로토콜
- 개방형 최단 경로 우선(Open Short Path First, OSPF)과 IS-IS(Intermediate System to Intermediate System)는 인터넷에서 AS 내부 라우팅에 널리 사용됨
- 링크 상태 알고리즘 기반
	-> OSPF는 링크 상태 정보를 플러딩(flooding)하고 다익스트라 최소 비용 경로 알고리즘을 사용하는 링크 상태 알고리즘이다.
##### 작동 방식
- OSPF를 이용하여 각 라우터는 전체 AS에 대한 완벽한 토폴로지 지도(그래프)를 얻는다.
- 각 라우터는 자신을 루트로 한 최단 경로 트리를 계산하기 위해 다익스트라 최단 경로 알고리즘 수행
- OSPF를 사용하는 라우터는 다음의 경우에 자율 시스템 내의 다른 모든 라우터에게 라우팅 정보를 브로드 캐스팅한다.
	1. 링크 상태가 변경될 때마다
	2. 링크 상태가 변경되지 않았더라도 정기적으로(최소한 30분마다 한 번씩)
- OSPF 메시지는 IP 프로토콜에 의해 전달되며, 상위 계층 프로토콜 번호로는 OSPF를 의미하는 89를 갖는다.
	-> 인터넷 프로토콜은 기본적으로 신뢰성 있는 전송 브로드 캐스트 기능, 링크 상태 감지, 아웃 라우터의 링크 상태 데이터베이스 동기화 등의 기능을 제공하지 않기 때문에 OSFP 프로토콜은 이러한 기능들을 자체적으로 구현해야 한다.
##### OSPF 링크 가중치 설정
- 일반적인 순서
	1. 링크 가중치가 설정됨
	2. 라우팅 알고리즘 수행(OSPF)
	3. LS 알고리즘에 의해 계산된 라우팅 테이블의 내용에 따라 트래픽이 흐름
- 링크 가중치가 주어지고 이에 따라 전체 비용을 최소화하는 라우팅 경로가 결정된다
- 실제로는 역방향으로도 가능하며, 원하는 트래픽 흐름에 맞게 링크 가중치를 설정한다.
- 다양한 설정 전략
	1.  모든 링크 비용을 1로 설정 -> 최소 홉 라우팅이 이루어지게 함
	2. 링크 용량에 반비례하게 링크 가중치 설정 -> 저대역폭 링크 사용 억제
	3. 지연 시간 기반 설정 -> 최소 지연 경로 선택
##### OSPF에 구현된 개선사항들
- 보안
	- OSPF 라우터들 간의 정보 교환(링크 상태 갱신과 같은)을 인증할 수 있음
	- 인증을 통해 신뢰할 수 있는 라우터들만이 AS 내부의 OSPF 프로토콜에 참여 가능
	- 인증 종류(2 가지)
		1. 단순 인증 : 동일한 패스워드가 각 라우터에 설정되며,  라우터가 OSPF 패킷을 보낼 때 패스워드를 평문 그대로 포함하기 때문에 안전하지 않음
		2. MD5 인증 : 모든 라우터에 설정된 공유 비밀키를 기반으로 한다(8장에서 다룸)
- 복수 동일 비용 경로 지원
	- 하나의 목적지에 대해 동일한 비용을 가진 여러 개의 경로가 존재할 때 OSPF는 여러 개의 경로를 사용할 수 있도록 한다.
		-> 여러 동일 비용 경로를 라우팅 테이블에 모두 등록 
	- 비용이 동일한 여러 개의 경로가 있을 때 모든 트래픽을 전달하기 위한 단 하나의 경로를 선택할 필요가 없다.    
		-> 트래픽을 여러 경로에 분산하는 로드 밸런싱을구현
	- IP가 제공하지 않는 기능을 OSPF가 자체적으로 구현
	- 장점
		- 네트워크 처리량 향상
		- 대역폭의 효율적 활용
		- 경로 장애 발생 시 대응성 개선
		- 네트워크 리소스 최적화
- 유니캐스트와 멀티캐스트 라우팅 통합 지원
	- MOSPF(Multiple OSPF)는 멀티캐스트 라우팅 기능을 제공하기 위해 OSPF를 단순 확장한 것
		- 기존의 OSPF 링크 데이터베이스 사용
		- 새로운 형태의 링크 상태 알림 추가
	- MAC 주소 : 네트워크 상에서 서로를 구분하기 위해 디바이스마다 할당된 물리적 주소
	- 유니캐스트 : 정보를 전송하기 위한 프레임에 자신의 MAC 주소와 목적지의 MAC 주소를 첨부하여 전송하는 방식(일대일 통신)
	- 브로드캐스트 : 로컬 네트워크에 연결되어 있는 모든 시스템에게 프레임을 보내는 방식 
	- 멀티캐스트 : 네트워크에 연결되어 있는 시스템 중 특정 그룹을 지정해서 해당 그룹원들에게 한번에 정보를 전달하는 방식(라우터가 멀티캐스트를 지원해야 사용 가능) 
- 단일 AS 내에서의 계층 지원
	- OSPF의 자율 시스템(AS)를 계층적인 영역(area)으로 구성 가능
	- 각 영역은 자체 OSPF 링크 상태 라우팅 알고리즘을 수행
	- 한 영역 내의 라우터는 같은 영역 내의 라우터들에게만 링크 상태를 브로드캐스트
	- 각 영역 내에서 하나 혹은 그 이상의 영역 경계 라우터가 영역 간 라우팅을 담당(영역 외부로의 패킷 라우팅을 책임짐)
	- 백본 영역의 주요 역할은 AS 내 영역 간의 트래픽을 라우팅하는 것 
	- AS 내 영역 간 라우팅 절차
		1. 영역 경계라우터로 패킷을 라우팅(영역 내 라우팅)
		2. 백본을 통과하여 목적지 영역의 영역 경계 라우터로 라우팅
		3. 최종 목적지로 라우팅  
 >[!note] 백본 영역(Backbone Area)
>백본 영역은 OSPF 네트워크 구조에서 중추 역할을 하는 특별한 영역으로, 항상 Area0으로 지정된다.
>주요 특징은 다음과 같다.
>1. 모든 비백본 영역(Area 1, 2 등)은 반드시 백본 영역과 직접 연결되어야 함
>2. 다른 영역 간의 모든 트래픽은 백본 영역을 통해 라우팅
>3. 계층적 라우팅 구조의 핵심 요소
>4. 대규모 네트워크의 확장성과 관리 효율성 향상
>5. 라우팅테이블 크기와 라우팅 업데이트 트래픽 감소
>6. 직접 연결이 불가능한 경우 가상 링크를 통해 백본 영역과의 연결을 설정할 수 있음
- OSPF vs IS-IS
- IS-IS(Intermediate System to Intermediate System)도 링크 상태 알고리즘 기반
- 대형 ISP들이 OSPF 대신 IS-IS를 선호하는 경우가 많음
- IS-IS가 더 확장성이 뛰어나고 대규모 네트워크에 적합
	-> 계층적 설계로 라우팅 정보를 더 휴율적으로
- OSPF는 일반적으로 더 쉽게 구성 가능
## 5.4 인터넷 서비스 제공업자(ISP) 간의 라우팅 : BGP
##### BGP의 필요성
- 패킷이 여러 AS를 통과하는 경우 필요
	ex) 한국에서 실리콘 밸리 데이터 센터로 통신 시
 - 자율 시스템 간 라우팅 프로토콜 필요
 - 통신하는 AS들은 동일한 AS 간 라우팅 프로토콜 필요
	 -> 인터넷의 모든 AS는 경계 게이트웨이 프로토콜(Border Gateway Protocol)을 사용
	  (거리 벡터 라우팅과 같은 줄기에서 나왔다고 볼 수 있는 분산형 비동기식 프로토콜)
### 5.4.1 BGP의 역할
##### AS 내부 vs 외부 라우팅
- AS 내부 목적지 : AS 내부 라우팅 프로토콜로 결정 (OSPF 등)
- AS 외부 목적지 : BGP 필요
##### BGP 주요 특징
- 패킷은 CIDR 형식으로 표현된 주소 프리픽스를 향해 전달됨
	ex) 139.16.68.0/22
- 각 프리픽스는 서브넷이나 서브넷의 집합을 나타낸다.
- 라우팅 포워딩 테이블은(x, I) 같은 형식의 엔트리를 갖게 됨 
	- x : 주소 프리픽스
	- I : 라우터 인터페이스의 인터페이스 번호
##### BGP의 주요 기능
1. 이웃 AS를 통해 도달 가능한 서브넷 프리픽스 정보를 얻음
	- 각 서브넷이 자신의 존재를 인터넷 전체에 알릴 수 있도록 함
	- 글로벌 라우팅 테이블 구성
2. 서브넷 주소 프리픽스로의 가장 좋은 경로를 결졍
	- 라우터는 특정한 주소 프리픽스를 향한 2개 이상의 경로를 알 수도 있음
	- 가장 좋은 경로를 결정하기 위해 라우터는 BGP의 경로 결정 프로시저를 수행
### 5.4.2 BGP 경로 정보 알리기
- 아래의 단순한 네트워크는 3개의 자율 시스템을 가지며, AS3는 주소 프리픽스가 x인 서브넷을 포함 
- 각 AS에서 각각의 라우터들은 게이트웨이 라우터 또는 내부 라우터 
![[Pasted image 20250314083616.png]]
##### BGP 네트워크 구성 요소
- 게이트웨이 라우터
	- AS의 경계에 위치한라우터
	- 다른 AS 라우터와 직접 연결
	ex) AS1의 1c 라우터
- 내부 라우터
	- 자신의 AS 내 호스트/라우터와만 연결
	ex) AS1의 1a, 1b, 1c
##### BGP 연결 유형
- BGP 연결 : 라우트 쌍들은 포트 번호가 179이고 반영구적인 TCP 연결을 통해 라우팅 정보를 교환
	-> 이 TCP 연결을 통해 모든 BGP 메시지가 전송됨
- 외부 BGP(eBGP) 연결
	- 서로 다른 AS를 연결하는 BGP 연결
	- AS 경계에서 정보 교환
- 내부 BGP(iBGP) 연결
	- 같은 AS 내 라우터 연결하는 BGP 연결
	- 물리적 링크와 항상 일치하지는 않음
	- AS 내부에서 외부 경로 정보 공유
![[Pasted image 20250314084458.png]]
##### BGP 경로 정보 전파 과정
1. 프리픽스 소유 AS가 eBGP로 이웃 AS에 존재 알림
2. 이웃 AS는 iBGP로 내부 모든 라우터에 전파
3. 다음 AS로 eBGP를 통해 추가 경로 정보 전파
4. 각 AS는 경로에 자신의 AS 번호 추가
- 예시 
	1. 먼저 게이트웨이 라우터 3a는 게이트웨이 라우터 2c에게 ‘`AS3 x`’라는 `eBGP 메시지`를 보낸다.  
	    (x가 존재하고 AS3 내에 있다는 의미)
	    
	2. 게이트웨이 라우터 2c는 `iBGP 메시지` ‘`AS3 x`’를 게이트웨이 라우터 2a를 포함한 **AS2 내부의 모든 라우터에게 전송한다.**
	    
	3. 게이트웨이 라우터 2a는 `eBGP 메시지` ‘`AS2 AS3 x`’를 게이트웨이 라우터 1c에게 보낸다.  
	    (’x가 존재하고 x에 도달하기 위해서는 먼저 **AS2를 통과하고 그 후 AS3으로 갈 수 있다**’는 의미)
	    
	4. 마지막으로, 게이트웨이 라우터 1c는 iBGP를 사용하여 AS1 내의 **모든 라우터에게** 메시지 ‘`AS2 AS3 x`’를 전달한다.
- 라우터 1d에서 3d로 연결되는 물리적인 링크를 추가한다면 다음과 같다
![[Pasted image 20250314084907.png]]
- 이 경우에 AS1에서 x로는 2개의 경로가 존재
	1. 라우터 1c를 통과하는 경로 ‘`AS2 AS3 x`’
	2. 라우터 1d를 통과하는 새로운 경로 ‘`AS3 x`’
### 5.4.3 최고의 경로 결정
- 프리픽스와 BGP 속성을 경로라고 한다
- AS-PATH
	- 알림 메시지가 통과하는 AS들의 리스트
		:프리픽스가 어떤 AS에 전달되었을 때, 그 AS는 자신의 ASN을 AS-PATH 내 현재 리스트에 추가
	- 메시지의 루프를 감지하고 방지하기 위해 활용
		: 어떤 라우터가 자신의 AS가 경로 리스트에 포함되어 있는 것을 발견하면 그 알림 메시지를 버린다. 
- NEXT-HOP
	- AS-PATH가 시작되는 라우터 인터페이스의 IP 주소
	- AS 외부에 속하는 라우터의 IP 주소이지만 직접 연결됨
		![[Pasted image 20250314085459.png]]
	- AS1에서 AS2를 통과하여 x로 가는 ‘`AS2 AS3 x`’ 경로의 NEXT-HOP 속성은 **라우터 2a의 왼쪽 인터페이스의 IP 주소**다.
	- AS1에서 AS2를 우회하여 x로 가는 ‘`AS3 x`’ 경로의 NEXT-HOP 속성은 **라우터 3d의 맨 왼쪽 인터페이스의 IP 주소**다.
##### 뜨거운 감자 라우팅
- 가능한 모든 경로 중 NEXT-HOP 라우터까지의 경로 비용이 최소인 경로 선택
- 네트워크 내 비용만 고려하는 Greedy 알고리즘
- 과정
	1. AS 간 프로토콜로 여러 게이트웨이 경로 파악(여러 게이트웨이를 통해 서브넷 x에 도착할 수 있는지 확인)
	2. AS 내부 프로토콜로 얻은 라우팅 정보를 통해 각 게이트웨이까지 최소 비용 경로 계산
	3. 최소 비용 게이트웨이 선택(뜨거운 감자 라우팅)
	4. 해당 게이트웨이로 향하는 인터페이스를 포워딩 테이블에 추가(x, I)
	-> 포워딩 테이블에 AS 외부의 목적지를 추가할 때 AS 간 라우팅 프로토콜(BGP)과 라우팅 프로톨(OSPF) 둘 다가 사용된다. 
- 위의 예시에 대한 실제 처리 과정
	1. `라우터 1b`는 주소가 `x`로 시작하는 서브넷으로 가는 2개의 BGP 경로를 안다.
	2. `NEXT-HOP 라우터 2a와 3d` 각각에 대해 최소 비용을 가진 AS 내부 경로를 찾기 위해 **AS 내부 라우팅 정보를 조사한다.**
	3. 이들 최소 비용 경로 중에서도 **가장 적은 비용을 가진 경로를 선택한다.**
		비용을 거쳐가야 하는 링크의 수로 정의하면
		- 라우터 1b에서 `라우터 2a`까지의 최소 비용 : 2
		- 라우터 1b에서 `라우터 3d`까지의 최소 비용 : 3
		따라서 라우터 2a가 선택된다.
	4. 라우터 1b는 자신의 (AS 내부 알고리즘에 의해 설정된) 포워딩 테이블을 관찰하여 라우터 2a로 가기 위한 인터페이스 I를 찾아내고,  엔트리 `(x, I)`를 **자신의 포워딩 테이블에 추가한다.**
- 라우터가 목적지까지의 경로 중 자신의 AS 바깥에 있는 부분에 대한 비용은 고려하지 않고 최소한의 비용으로 패킷을 자신의 AS 밖에 내보내는 것
- AS 내 2개의 라우터가 동일한 목적지에 대해 각기 다른 AS 경로를 택할 수 있다.
##### 경로 선택 알고리즘
- 실제로 BGP 는 뜨거운 감자 라우팅을 포함하는 더 복잡한 알고리즘 사용 
- 목적지 주소의 프리픽스가 주어지면, 지금까지 라우터가 알아낸 해당 목적지까지의 모든 경로가 BGP의 경로 선택 알고리즘의 입력으로 주어지고 BGP는 하나의 경로가 남을 때까지 다음의 제거 규칙을 계속 수행한다.
	-> 뜨거운 감자 라우팅에서 지역 선호도라는 속성이 경로에 할당됨
- 한 경로의 지역 선호도는 라우터에 의해 설정되거나 같은 AS 내부의 다른 라우터로부터 학습된 것
- 과정
	1. `최고 지역 선호 값`을 가진 경로가 선택된다.
	2. 최고 지역 선호 값을 가진 경로가 여러 개 있다면 이들 중에서 `최단 AS-PATH`를 가진 경로가 선택된다.
	    - 만약 이 규칙이 경로 선택을 위한 유일한 규칙이라면, BGP는 **경로 결정을 위해** `DV 알고리즘`을 사용할 것이다.
	    - 여기서 거릿값으로는 **AS 홉 수**를 사용한다.
	3. (같은 최고 지역 선호 값 및 같은 AS-PATH 길이를 가진) 모든 남은 경로들에 대해 `뜨거운 감자 라우팅`을 수행한다.
	4. 만일 아직도 하나보다 많은 경로가 남아 있다면 라우터는 `BGP 식별자`를 사용하여 경로를 선택한다.
		- 정해져 있는 값
### 5.4.4 IP 애니캐스트
- BGP는 IP 애니캐스트 서비스를 구현하는 데도 활용됨
- 애니캐스트 : 송신 노드가 네트워크에 연결된 수신 가능한 노드 중에서 가장 가까운 한 노드에만 데이트를 전송한다.(IPv6 기반으로 작동)
##### IP 애니캐스트 개념
- 동일 콘텐츠를 지리적으로 분산된 서버에 복제
- 사용자를 가장 가까운 서버로 연결(접근하게 함)
-  BGP 경로 선택 알고리즘 활용
![[Pasted image 20250314092520.png]]
##### IP 애니캐스트 구현 방법
1. 여러 서버에 동일한 IP 주소 할당
2. 표준 BGP를 활용하여 이 주소를 서버 각각으로부터 알림
	- 라우터가 이 IP 주소에 대한 여러 개의 경로 알림 메시지를 받으면 이를 동일한 물리적 위치로의 서로 다른경로에 대한 정보를 제공받고 있는 것으로 생각한다.
	- 실제로는 서로 다른 물리적 위치로 가는 서로 다른 경로이다.
3. 사용자가 어디에 위치해 있든 상관없이 지리적으로 분산되어 있는 서버들이 공통적으로 사용하는 IP 주소를 사용자에게 돌려준다.
4. 사용자가 그 주소로 요청을 보내면 인터넷 라우터는 그 요청 패킷을 BGP 경로 선택 알고리즘이 정의한 가장 '가까운' 서버로 전달
##### 실제 사용
- CDN : BGP 라우팅이 변경되면 하나의 TCP 연결에 속한 패킷들이 서로 다른 복제 웹 서버로 도착할 수 있기 때문에 CDN은 IP 애니 캐스트를 사용하지 않음
- DNS : DNS 질의를 가장 가까운 루트 DNS 서버로 전달하기 위해 IP 애니캐스트를 광범위하게 사용 
### 5.4.5 라우팅 정책
##### 자율 시스템 간 라우팅 정책
- 라우터가 목적지까지의 경로를 선택하려고 할 때 AS 라우팅정책은 최단 AS-PATH나 뜨거운 감자 라우팅 등의 다른 모든 고려사항보다 우선시됨  
- 라우팅 정책은 비즈니스 관계와 트래픽 흐름 제어에 기반  
##### 트래픽 정책 구현
- 접속 ISP의 정책: 자신을 목적지/출발지로 하는 트래픽만 처리
	- X는 B와 C 사이의 트래픽 전달 금지
	- 구현 방법 : BGP 경로 알림 제어(자신 외 목적지로의 경로 미알림)
- 하나의 ISP만 x로 연결되는 경로를(연결된다는 사실을) 알고 있고 나머지는 아예 몰라야 한다.
##### 백본 ISP 간 정책
- 일반적 규칙: 고객 네트워크를 출발지나 목적지로 하는 트래픽만 전송
- 개별 상호 협정은 ISP 간 협상으로 결정
- 결과적으로 인터넷은 정책 기반 라우팅으로 동작
### 5.4.6 AS 간 라우팅과 AS 내부 라우팅 차이점
##### 정책
- AS 간 라우팅 : 정책 이슈가 지배적(어떤 트래픽을 전달할지 등)
- AS 내부 라우팅 : 동일한 관리 통제 하에 있어 정책 문제가 덜 중요
##### 확장성
- AS 간 라우팅 : 수많은 네트워크 간 경로 설정 처리가 매우 중요
- AS 내부 라우팅 : 확장상 문제 적음(필요시 AS를 여러 영역으로 나눌 수 있음 ) 
##### 성능
- AS 간 라우팅: 정책 지향형으로 성능은 부수적 관심사
- AS 내부 라우팅: 정책 고려 덜 중요하여 경로 성능에 더 초점
### 5.4.7 인터넷 존재 확인하기

##### 인터넷 연결 과정
1. 지역 ISP와 계약
    - 회사의 게이트웨이 라우터를 ISP 라우터에 연결
    - IP 주소 범위 할당 받음
    - 회사 내 장치들에 IP 주소 할당
2. 도메인 이름 등록
    - 인터넷 등록 기관과 계약
    - DNS 서버 IP 주소 제공
    - 등록 기관이 최상위 도메인 서버에 DNS 서버 정보 추가
3. DNS 서버 설정
    - 웹 서버 등 공개 서버의 호스트명과 IP 주소 매핑 설정
    - 외부 사용자가 도메인 이름으로 서버 접근 가능
4. 전 세계 접근성 확보
    - BGP 활용: ISP가 회사 IP 프리픽스를 알림
    - 연결된 ISP들이 BGP로 이 정보 전파
    - 전 세계 라우터가 회사 네트워크로의 경로 인식
## 5.5 소프트웨어 정의 네트워크(SDN) 제어 평면
- 네트워크 포워딩 장비들은 '패킷 스위치' 혹은 '스위치'라고 지칭
- 포워딩 결정은 다양한 계층 헤더 값 기반으로 결정
	- 2계층 : 이더넷 MAC 주소
	- 3계층 : IP 주소
	- 4계층 : TCP/UDP 포트 번호 등
### 5.5.1 SDN 구조의 특징
##### 플로우 기반 포워딩
- SDN 스위치는 다양한 계층 헤더 값 기반으로 포워딩 가능
- 전통적IP 포워딩(목적지 주소 기반)과 대조적
- SN 제어 평면이모든 스위치의 플로우 테이블 관리
##### 데이터 평면과 제어 평면의 분리
- 데이터 평면
	- 네트워크의 스위치들로 구성(상대적으로 단순하지만 빠른 장치들)
	- 자신들의 플로우 테이블 내용을 기반으로 '매치 플러스 액션'을 수행
- 제어 평면
	- 서버와 스위치들의 플로우 테이블을 결정, 관리하는 소프트웨어로 이루어짐
##### 네트워크 제어 기능이 데이터 평면 외부에 존재
- SDN 제어 평면은 소프트웨어로 구현되어 있으며, 네트워크 스위치에서 분리된 별도 서버에서 수행
- 2가지 주요 구성요소
	1. SDN 컨트롤러(네트워크 운영체제)
		- 정확한 상태정보(e.g., 원격 링크와 스위치, 호스트들의 상태)를 유지하고,
		- 이 정보를 네트워크 제어 애플리케이션들에 제공하며,
		- 애플리케이션들이 하부 네트워크 장치들을 모니터하고 프로그램하고 제어까지 할 수 있도록 수단을 제공한다.
		- 실제 컨트롤러는 논리적으로만 중앙 집중 형태
			-> 일반적으로 협업 능력과 확장성, 높은 이용성을 갖도록 몇 개의 서버에 구현
	2. SDN 네트워크 제어 애플리케이션들의 집합
		![[Pasted image 20250314100626.png]]
##### 프로그램이 가능한 네트워크
- 제어 평면의 네트워크 제어 애플리케이션으로 네트워크 프로그래밍 가능
- 애플리케이션은 SDN 컨트롤러 API를 통해 데이터 평면 제어
ex) 라우팅 애플리케이션이 다익스트라 알고리즘으로 경로 결정 
### 5.5.2 SDN 제어 평면
##### SDN 컨트롤러
- 컨트롤러의 기능은크게 3개의 계층으로 구성된다.
	1. 네트워크 제어 애플리케이션 계층과의 인터페이스
	2. 네트워크 전역 상태 관리 계층
	3. 통신 계층
		![[Pasted image 20250314101157.png]]
- 통신 계층 : SND 컨트롤러와 제어 받는 네트워크 장치들 사이의 통신
	- 사우스바운드 인터페이스를 통한 통신
	- OpenFlow 프로토콜 주로 사용
	- 장치에서 이벤트 정보를 수집하여 제어 명령을 전달한다.
- 네트워크 전역 상태 관리 계층
	- 네트워크 호스트, 링크, 스위치 등에 대한 최신 정보 유지
		- 플로우 테이블 복사본 관리
		- 분산 시스템에서의 상태 정보 일관성 유지
- 네트워크 제어 애플리케이션 계층과의 인터페이스
	- 노스바운드 인터페이스를 통한 상호작용
	- 애플리케이션이 네트워크 상태 정보와 플로우 테이블 접근 가능   
### 5.5.2 OpenFlow 프로토콜
##### OpenFlow 특징
- SDN 컨트롤러와 SDN 지원 장치 간 통신
- TCP 기반 통신 (기본 포트 6653)
##### 주요 메시지 유형

###### 컨트롤러 → 스위치
- **설정**: 스위치 설정 파라미터 문의/설정
- **상태 수정**: 플로우 테이블 엔트리 추가/제거/수정
- **상태 읽기**: 통계 정보와 카운터값 획득
- **패킷 전송**: 특정 포트로 패킷 송신 지시
###### 스위치 → 컨트롤러
- **플로우 제거**: 엔트리 삭제 알림
- **포트 상태**: 포트 상태 변화 알림
- **패킷 전달**: 플로우 테이블 매칭 실패 또는 특별 처리 필요 패킷 전달
### 5.5.3 데이터 평면과 제어 평면의 상호작용: 예제
아래 그림은 SDN의 제어를 받는 스위치와 SDN 컨트롤러 간의 상호작용에 대한 것이다.
- 여기서는 다익스트라 알고리즘이 최단 경로를 결정하기 위해 사용되는데,  
    다익스트라 알고리즘은 **패킷 스위치 외부에서** 별도의 애플리케이션으로 수행된다.
- 패킷 스위치들이 **링크 갱신 정보를** 서로 간이 아닌 **SDN 컨트롤러에게 전송한다.**
	![[Pasted image 20250314103437.png]]
##### 링크 단절 시나리오
- 스위치 s1과 s2 사이 링크 단절 상황
- 통신 계층 프로토콜: OpenFlow 사용
##### 대응 과정
1. **링크 단절 감지**: s1이 OpenFlow 포트 상태 메시지로 컨트롤러에 알림
2. **정보 갱신**: 컨트롤러가 링크 상태 관리자에 알리고 데이터베이스 갱신
3. **애플리케이션 알림**: 링크 상태 라우팅 애플리케이션이 변화 알림 수신
4. **경로 재계산**: 애플리케이션이 갱신된 링크 상태로 새로운 최소 비용 경로 계산
5. **테이블 갱신 결정**: 애플리케이션이 플로우 테이블 관리자와 협력
6. **스위치 업데이트**: OpenFlow로 영향받는 스위치들의 플로우 테이블 갱신

### 5.5.4 SDN: 과거와 미래
##### 과거
- SDN 기술적 뿌리는 데이터/제어 평면 분리의 오랜 개념에서 시작
- 주요 이정표:
    - 2004년: 여러 연구에서 네트워크 데이터/제어 평면 분리 주장
    - **에탄(Ethane) 프로젝트(2007)**: 플로우 기반 스위치, 중앙 컨트롤러, 패킷 전달 개념 개척
    - OpenFlow 프로젝트로 발전
##### 미래
- SDN 혁명: 단순 스위칭 하드웨어 + 정교한 소프트웨어 제어 평면
- **네트워크 기능 가상화(NFV)**: SDN의 일반화
    - 상용 서버, 스위칭, 저장소로 복잡한 미들박스 대체
    - 하드웨어와 소프트웨어 분리
- 연구 방향: SDN 개념을 AS 내부에서 AS 간 설정으로 확장
##### SDN 컨트롤러 사례연구
###### OpenDaylight 컨트롤러
- 오픈소스 프로젝트, 리눅스 재단과 공동 개발
- 주요 구성:
    - 기본 네트워크 서비스 기능 (컨트롤러 핵심부)
    - **서비스 추상 계층(SAL)**: 컴포넌트 간 통신 및 프로토콜 추상화
    - OpenFlow, SNMP, NETCONF 등 다양한 프로토콜 지원
    - 네트워크 조정 및 애플리케이션 계층
###### ONOS 컨트롤러
- Open Network Operating System
- 3개 주요 계층:
    1. **노스바운드 추상화**: 의도(intent) 프레임워크 제공
    2. **분산 코어**: 네트워크 상태 정보 유지, 논리적 중앙 집중형 서비스 제공
    3. **사우스바운드 추상화**: 하부 장치/프로토콜의 이질성 숨김
# 5.6 인터넷 제어 메시지 프로토콜(ICMP)
##### ICMP 개요
- **인터넷 제어 메시지 프로토콜** (Internet Control Message Protocol)
- 호스트와 라우터 간 네트워크 계층 정보 교환용으로 사용
- IP 바로 위에 위치하지만 IP 페이로드로 전송됨
- 상위 계층 프로토콜 번호: 1
##### ICMP 메시지 구조
- **타입(type)과 코드(code) 필드** 포함
- 오류 발생 원인이 된 IP 데이터그램 헤더와 첫 8바이트 포함
- 송신자가 문제 패킷 식별 가능
##### 주요 ICMP 메시지 타입
- ICMP는 오류 상태 알림 외에도 다양한 목적으로 사용
	![[Pasted image 20250314104120.png]]
##### ping 프로그램
- **타입 8, 코드 0** (에코 요청) 메시지 전송
- 목적지 호스트가 **타입 0, 코드 0** (에코 응답) 회신
- 대부분 운영체제에서 직접 지원 (별도 프로세스 아님)
##### 출발지 억제 메시지
- 원래 목적: 혼잡 제어
- 혼잡 라우터가 호스트에게 전송 속도 감소 요청
- 현재는 TCP의 자체 혼잡 제어로 잘 사용되지 않음
##### Traceroute 프로그램
- 출발지와 목적지 사이 라우터 경로 파악 방법:
    1. TTL 값을 1부터 증가시키며 UDP 데이터그램 전송
    2. 각 데이터그램에 타이머 시작
    3. n번째 라우터에서 TTL 만료 시 **ICMP 경고 메시지**(타입 11, 코드 0) 회신
    4. 회신으로 RTT와 라우터 정보 획득
    5. 목적지 도달 시 **포트 도달 불가능**(타입 3, 코드 3) 메시지로 종료

## 5.7 네트워크 관리와 SNMP, NETCONF/YANG

##### 네트워크 관리 정의

- 네트워크와 구성요소 자원을 감시, 테스트, 설정, 분석, 제어하는 활동
- 하드웨어, 소프트웨어, 인적 요소의 배치와 통합, 조정 포함

### 5.7.1 네트워크 관리 프레임워크

##### 핵심 구성요소

##### 관리 서버(Managing Server)
- NOC(Network Operations Center)의 중앙 집중형 관리 스테이션
- 네트워크 관리자(사람)와 상호작용하는 애플리케이션
- 네트워크 관리 정보 수집, 처리, 분석, 발송 제어
##### 피관리 장치(Managed Device)
- 관리 대상 네트워크의 장비들 (호스트, 라우터, 스위치 등)
- 관리 가능한 요소와 설정 매개변수 포함
##### 데이터(Data)
- 피관리 장치의 '상태(state)' 정보
- 유형:
    - **설정 데이터**: 관리자가 할당한 장치 정보 (IP 주소 등)
    - **동작 데이터**: 장치 동작 중 획득 정보 (OSPF 인접 항목 등)
    - **장치 통계**: 상태 표시기 및 계수기 (패킷 카운터 등)
##### 네트워크 관리 에이전트
- 피관리 장치 상의 소프트웨어 프로세스
- 관리 서버와 통신하며 장치 제어 수행
##### 네트워크 관리 프로토콜
- 관리 서버와 피관리 장치 간 통신
- 장치 상태 질의 및 행동 지시 기능
- 예외 사항 보고 기능
##### 네트워크 관리 방법
###### 1. CLI(Command Line Interface)
- 장치에 직접 명령 전송
- 콘솔 입력 또는 텔넷/SSH 연결 통한 전달
- 단점: 오류 발생 쉬움, 대규모 자동화 어려움
###### 2. SNMP/MIB
- SNMP로 장치 MIB 데이터 질의/설정
- 일부 데이터는 장치/공급업체별 상이
- 주로 모니터링 용도로 사용, 설정은 CLI 병행
###### 3. NETCONF/YANG
- 더 추상적이고 전체론적인 관리 방식
- 설정 관리에 중점
- YANG: 데이터 모델링 언어
- NETCONF: 원격 장치 간 통신 프로토콜
### 5.7.2 SNMP와 MIB
##### SNMP (Simple Network Management Protocol)
- 현재 버전: SNMPv3
- 관리 서버와 에이전트 간 정보/제어 메시지 전달
##### 요청-응답 모드
- 가장 일반적인 사용 방식
- 서버가 에이전트에 요청 송신
- 에이전트가 수행 후 응답
##### 트랩 메시지
- 에이전트가 비요청 시에도 서버에 전송
- 예외 상황(링크 상태 변화 등) 알림
##### SNMP PDU (Protocol Data Unit) 유형
- GetRequest, GetNextRequest, GetBulkRequest: 값 요청
- SetRequest: 값 설정
- Response: 요청에 대한 응답
- SNMPv2-Trap: 비동기적 알림
##### 전송 메커니즘
- 일반적으로 UDP 데이터그램으로 전송
- 신뢰성 부족 해결을 위한 요청 ID 필드 사용
##### MIB (Management Information Base)
- 관리 정보의 구조화된 집합
- SMI(Structure of Management Information)로 명세
- 다양한 정보 포함:
    - 카운터 (데이터그램 폐기 수 등)
    - 설명 정보 (소프트웨어 버전 등)
    - 상태 정보 (장치 동작 여부 등)
- 관련 객체들은 MIB 모듈로 그룹화
### 5.7.3 네트워크 설정 프로토콜(NETCONF)과 YANG
##### NETCONF
- 관리 서버와 피관리 장치 간 통신 프로토콜
- 주요 기능:
    1. 설정 데이터 검색/수정
    2. 동작 데이터/통계 질의
    3. 장치 알림 구독
- XML 문서 형식의 설정 내용 전송
- RPC(Remote Procedure Call) 패러다임 사용
- TLS 같은 안전한 연결 통한 통신
##### NETCONF 세션 절차

1. 보안 연결 설정
2. `<hello>` 메시지 교환 및 기능 알림
3. `<rpc>` 및 `<rpc-reply>` 메시지로 상호작용
4. `<close-session>` 메시지로 종료
##### 주요 NETCONF 작업
- `<get>`, `<get-config>`: 설정/상태 정보 검색
- `<edit-config>`: 설정 수정
- `<copy-config>`, `<delete-config>`: 설정 복사/삭제
- `<lock>`, `<unlock>`: 설정 잠금/해제
- `<create-subscription>`: 알림 구독
##### YANG
- 네트워크 관리 데이터 구조화를 위한 데이터 모델링 언어
- NETCONF가 사용하는 데이터 구조/구문/의미 정의
- 모든 정의는 모듈에 포함
- XML 문서 생성을 위한 템플릿 역할
##### 네트워크 관리의 발전 방향
- SDN과의 통합
- 인공지능/머신러닝 기반 자동화
- 의도 기반 네트워킹(Intent-Based Networking)
- 클라우드 네이티브 네트워크 관리