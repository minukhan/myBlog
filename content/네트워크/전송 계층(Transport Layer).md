> [!tldr] 개요
> 종단 간(end-to-end) 통신을 담당하는 계층. 각기 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 논리적 통신을 제공한다.

## 1. 다중화 & 역다중화

1. 목적지 호스트에서의 전송 계층은 바로 아래 네트워크 계층으로부터 세그먼트를 수신한다.
2. 전송 계층은 세그먼트를 중간 매개자인 소켓에게 전달한다.
	- 프로세스는 네트워크 애플리케이션의 한 부분으로서 소켓을 가지고 있다
	- 소켓은 쉽게 말해, 네트워크를 통해 데이터를 주고받을 수 있는 통로이며, 한 프로세스로부터 네트워크로 데이터를 전달한다.
	- 각각의 소켓은 하나의 유일한 식별자, **포트 번호(port number)** 를 가진다

> [!question] 세그먼트란?
> 전송 계층에서 사용하는 데이터 단위로, 특히 [[TCP]] 프로토콜에서 데이터를 전송할 때 사용하는 PDU(Protocol Data Unit)을 의미한다.

![](https://i.imgur.com/VkMRmOD.png)
#### 역다중화(demultiplexing)
- 전송 계층 세그먼트의 데이터를 **올바른 소켓으로 전달**하는 작업
- 원래의 개별 데이터 스트림으로 분리하여 해당 프로세스나 애플리케이션에 전달하는 과정이다.
###### 역다중화 서비스의 순서
1. 호스트의 각 소켓은 포트 번호를 할당받는다.
2. 세그먼트가 호스트에 도착하면,
	1. 전송 계층은 세그먼트 안의 **목적지 포트 번호**를 검사하고,
	2. 그에 상응하는 소켓으로 세그먼트를 보낸다.
3. 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다

==-> UDP의 기본적인 동작 방식과 같다.==
#### 다중화(multiplexing)
- 여러 개의 애플리케이션(프로세스)에서 보내는 데이터를 하나의 전송 계층 연결을 통해 전송하는 과정
- 즉, 상위 계층에서 오는 여러 데이터 스트림을 **하나의 통신 채널로 결합**하는 기술이다.
### 비연결형 다중화와 역다중화
> [!todo] UDP 소켓은 (목적지 IP 주소, 목적지 포트 번호)로 구성된 튜플에 의해 식별된다.

- [?] 만약 2개의 UDP 세그먼트가 같은 목적지 IP 주소와 목적지 포트번호를 가진다면...
	- 이 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향한다.

![](https://user-images.githubusercontent.com/86337233/211320120-b319557b-49d0-47d8-a7f5-671cb51131d8.png)
- 출발지 포트번호의 경우, **"회신"** 을 위한 용도로만 사용된다.
### 연결지향형 다중화와 역다중화
> [!todo] TCP 소켓은 4개 요소로 구성된 튜플에 의해 식별된다.
- 출발지 IP 주소
- 출발지 포트 번호
- 목적지 IP 주소
- 목적지 포트 번호

특히, 다른 출발지 IP 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향하게 된다. **-> 연결 지향형이기 때문**
- 단, 초기 연결 설정 요청을 전달하는 TCP는 제외된다.
- 서버가 처음에 연결을 기다릴 때(listen 상태)는 아직 출발지 정보 없이, 포트만 열어두기 때문이다.
#### TCP 연결 설정
1. TCP 서버 애플리케이션은 **Listening 소켓**(또는 Server 소켓이나 Welcome 소켓이라고 부르기도 한다)을 가지고 있다
	- 이 단계에서 소켓은 오직 (서버 IP, 서버 포트) 2가지 요소로만 식별된다
	- 이 소켓은 어떤 클라이언트가 연결할지 모르는 상태로, **모든 클라이언트로부터의 초기 연결 요청(SYN 패킷)을 받을 준비**가 되어 있다
2. TCP 클라이언트는 소켓을 생성하고, 연결 요청 세그먼트를 보낸다
	- 이 세그먼트는 출발지 포트 번호를 포함하며, 클라이언트가 선택한 번호를 의미한다
3. 서버 프로세스로 동작하는 컴퓨터의 호스트 운영체제가 목적지 포트(서버 포트)를 포함하는 연결 요청 세그먼트를 수신하면, 이 세그먼트를 연결 수락을 기다리는 서버 프로세스로 보낸다
4. 서버는 연결 요청 세그먼트의 4개 요소의 튜플에 주목한다
	- 새롭게 생성된 연결 소켓은 4개 요소의 튜플에 의해 식별된다
	- 따라서 그 다음에 도착하는 세그먼트의 4개 요소가 전부 일치하면, 그 세그먼트는 이 소켓으로 역다중화된다 

![](https://i.imgur.com/2qU8ZUQ.png)

---
## 2. TCP/UDP
1. UDP는 전송 계층 프로토콜이 할 수 있는 최소 기능으로 동작한다.
	- [[UDP|UDP 항목 참고]]
2. TCP는 데이터 전송을 보장하는 연결지향형 프로토콜이다.
	- [[TCP|TCP 항목 참고]]

---
## 3. 신뢰적인 데이터 전송의 원리

- 신뢰적인 채널에서는 전송된 데이터가 **손상되거나 손실 되지 않으며**,
- 모든 데이터는 전송된 **순서 그대로 전달**된다

-> **RDT**(Reliable Data Transfer Protocol)의 의무는 신뢰적인 채널의 서비스 추상화를 구현하는 것
- 단방향 데이터 전송의 경우인, 송신 측으로부터 수신 측까지의 데이터 전송만을 고려한다
- 실제로 존재하는 프로토콜은 아니다, 설명을 위한 가상의 프로토콜 설계를 다룬다
### RDT 1.0

> [!done] 완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송

rdt 1.0 송신자와 수신자에 대한 유한 상태 머신(FSM) 정리는 아래 그림과 같다

![](https://user-images.githubusercontent.com/86337233/211394885-cee89e54-814d-4772-9083-617648a91488.png)
#### 송신자
1. `rdt_send(data)` 이벤트에 의해
	1. 상위 계층으로부터 데이터를 받아들이고
	2. 데이터를 포함한 패킷을 생성(`make_pkt(data)`)한다
2. 그러고 난 후 패킷을 채널로 송신한다
#### 수신자
1. rdt는 `rdt_rcv(packet)` 이벤트에 의해 하위의 채널로부터 패킷을 수신한다
2. 패킷으로부터 데이터를 추출(`extract(packet, data)`)하고
3. 데이터를 상위 계층으로 전달(`deliver_data(data)`)한다

> [!important] RDT 1.0
> 완전히 신뢰적인 채널에서는 오류가 생길 수 없으므로 **수신 측이 송신 측에게 어떤 피드백도 제공할 필요가 없다**

### RDT 2.0

> [!done] 비트 오류가 있는 채널상에서의 신뢰적인 전송

이제 패킷 안의 비트들이 하위 채널에서 손상될 수 있다고 가정한다
- 일반적으로 이러한 비트 오류는 패킷이 전송, 또는 전파되거나 버퍼링될 때 네트워크의 물리적인 구성요소에서 발생할 수 있다
#### 자동 재전송 요구(ARQ : Automatic Repeat reQuest) 프로토콜
두 가지가 필요하다
1. 긍정 확인 응답
2. 부정 확인 응답

이러한 제어 메시지는 정확하게 수신되었는지 또는 잘못 수신되어 반복이 필요한지를 수신자가 송신자에게 알려줄 수 있게 한다
비트 오류를 처리하기 위해 기본적으로 다음과 같은 세 가지 부가 프로토콜 기능이 ARQ에 요구된다
#### 오류 검출
- 비트 오류가 발생했을 때 수신자가 검출할 수 있는 기능이 필요하다 -> checksum
#### 수신자 피드백
- 송신자가 수신자의 상태를 알기 위한 유일한 방법은 수신자가 송신자에게 피드백을 제공하는 것이다

> [!memo] RDT 2.0에서는 ACK와 NAK 패킷을 사용한다
> 이러한 패킷은 단지 한 비트 길이면 된다. (0 또는 1)
#### 재전송
- 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송 된다
#### 송신자
![](https://user-images.githubusercontent.com/86337233/211394874-2e37ba36-b8c3-454a-aa09-836435f51421.png)

1. 왼쪽 상태에서 송신 측 프로토콜은 상위 계층으로부터 데이터가 전달되기를 기다린다
	- `rdt_sent(data)` 이벤트가 발생하면,
	1. 송신자는 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷(sndpkt)을 생성하고,
	2. 그 패킷을 `udt_send(sndpkt)` 동작을 통해 전송
2. 오른쪽 상태에서 송신자 프로토콜은 수신자로부터의 ACK 또는 NAK 패킷을 기다린다
	1. 만약 ACK가 수신되면 (`rdt_rcv(rcvpkt) && isACK(rcvpkt)`)
		- 가장 최근에 전송된 패킷이 정확하게 수신되었음을 의미
		- 따라서 프로토콜은 상위 계층으로부터 데이터를 기다리는 상태(왼쪽 상태)로 돌아간다
	2. 만약 NAK가 수신되면
		- 프로토콜은 마지막 패킷을 재전송
		- 재전송된 데이터 패킷에 대한 응답으로 수신자에 의해 응답하는 ACK 또는 NAK를 기다린다

이와 같은 방식을 **전송 후 대기(stop-and-wait)** 프로토콜이라고 한다
- [f] 송신자가 ACK 또는 NAK를 기다리는 상태에 있을 때, 상위 계층으로부터 더 이상의 데이터를 전달 받을 수 없음
#### 수신자
![](https://user-images.githubusercontent.com/86337233/211394877-619eb70a-cbc0-4e6c-bd47-b29a80d28521.png)
1. 패킷이 도착했을 때, 수신자는 수신된 패킷이 손상되었는지 아닌지에 따라 ACK 또는 NAK로 응답한다
### RDT 2.1

> [!done] RDT 2.0의 결함을 해결한 전송
#### RDT 2.0의 결함?
ACK 또는 NAK 패킷 역시 손상될 수 있다
- 만약 ACK 또는 NAK가 손상되었다면, 송신자는 수신자가 전송된 데이터의 마지막 부분을 올바르게 수신했는지 알 수 없다

> [!todo] 해결책
> 데이터 패킷에 새로운 필드를 추가하고, 이 필드 안에 순서 번호(Sequence Number)를 삽입하는 방식으로 데이터 패킷에 송신자가 번호를 붙인다

#### 송신자
![](https://user-images.githubusercontent.com/86337233/211394879-965b1e5e-242d-43a3-a3e5-2981ae49fced.png)

아래의 2가지를 반영해야 하므로, RDT 2.0보다 두 배 많은 상태를 가진다
1. 프로토콜의 상태가 현재 전송되고 있는 지에 대한 반영
2. 수신자가 기다리고 있는 패킷이 순서 번호 0 또는 1을 가져야 하는 지에 대한 반영 
#### 수신자
![](https://user-images.githubusercontent.com/86337233/211394881-dc92f052-6cc5-44a5-a6ac-716c07f3b6dd.png)

프로토콜 rdt2.1은 수신자로부터 송신자까지의 **긍정 확인응답**과**부정 확인응답**을 모두 포함한다.
- 순서가 바뀐 패킷이 수신되면, 수신자는 이미 전에 수신한 패킷에 대한 긍정 확인 응답을 전송
- 손상된 패킷이 수신되면 수신자는 부정 확인 응답을 전송
### RDT 2.2

> [!done] RDT 2.1에서 NAK 없이, ACK만을 사용하도록 변경

NAK를 송신하는 것 대신에,  
**가장 최근에 정확하게 수신된 패킷에 대해 ACK를 송신함으로써** NAK를 송신한 것과 같은 효과를 얻을 수 있다.
- 즉, 같은 패킷에 대해 2개의 ACK를 수신(즉, *중복(duplicate) ACK*를 수신)한 송신자는 수신자가 두 번 ACK 한 패킷의 다음 패킷을 정확하게 수신하지 못했다는 것을 알 수 있다

#### 송신자
![](https://user-images.githubusercontent.com/86337233/211394883-973fc4cf-0f42-48e4-a1b5-42d72c818b9f.png)

1. 송신자는 수신된 ACK 메시지에 의해 확인 응답된 **패킷의 순서 번호를 반드시 검사**해야만 한다.
   이는 송신자 FSM의 `isACK()`에 `0` 또는 `1`인 인수를 넣어서 수행한다.
#### 수신자
![](https://user-images.githubusercontent.com/86337233/211394888-1ad9f22d-9166-487c-a8aa-f0a380e03cfd.png)

1. 수신자가 반드시 ACK 메시지에 의해 확인 응답되는 **패킷의 순서 번호를 포함**해야 한다.
   이는 수신자 FSM의 `make_pkt()`에 `ACK, 0` 또는 `ACK, 1`인 인수를 넣어서 수행한다.
### RDT 3.0

> [!done] 하위 채널이 패킷을 손실하는 경우에 대한 해결

다음과 같은 두 가지 부가 내용이 필요하다
1. **어떻게** 패킷 손실을 검출할 것인가?
2. 패킷 손실이 발생했을 때 **어떤 행동**을 할 것인가?

> [!important] 책임 부여
> **송신자**에게 손실된 패킷의 검출과 회복 책임을 부여한다.

송신자가 데이터 패킷을 전송하고, 패킷 또는 수신자의 패킷에 대한 ACK를 손실했다고 가정하면...
-> 어느 경우에서나 송신자에게는 **수신자로부터 어떠한 응답**도 없다
- 즉, 송신자는 데이터 패킷이 손실되었는지, ACK가 손실되었는지, 패킷 또는 ACK가 단순히 지나치게 지연된 것인지를 알지 못한다

**만약 송신자가 패킷을 잃어버렸다고 확신할 정도로 충분한 시간을 기다릴 수만 있다면,** 데이터 패킷은 간단하게 재전송될 수 있다
- 그러므로 송신자는 다음처럼 동작해야 한다.
	1. 매 패킷(첫 번째 또는 재전송 패킷)이 송신된 시간에 **타이머를 시작**한다.
	2. 타이머 인터럽트에 반응한다. (즉, 적당한 행동을 취함)
	3. 타이머를 멈춘다.
#### 송신자
![](https://user-images.githubusercontent.com/86337233/211394896-6188b35e-abc3-45a4-b3c1-2ad0fbc91738.png)

다음의 4가지 예시를 참고하자.
###### a. 무손실 동작
![](https://user-images.githubusercontent.com/86337233/211394899-41093893-28a0-4036-99ae-01bb820c7cc9.png)
###### b. 패킷 손실
![](https://user-images.githubusercontent.com/86337233/211394906-3176a415-2270-493e-92a1-528344a5e00a.png)
###### c. ACK 손실
![](https://user-images.githubusercontent.com/86337233/211394858-92791860-cacf-4f94-ab98-f9d7611f337f.png)
###### d. 조급한 타임아웃
![](https://user-images.githubusercontent.com/86337233/211394848-a1a0d5ce-2190-4bfe-a14f-734a8f23b284.png)

---
## 4. 신뢰적인 데이터 전송 프로토콜의 성능 높이기

rdt3.0의 핵심적인 성능 문제는 **전송 후 대기(stop-and-wait) 프로토콜**이라는 점 때문에 발생한다.
따라서 다음과 같은 방법으로 해결할 수 있다.
### a. 파이프라이닝

#### RDT 3.0 기본 동작
![](https://user-images.githubusercontent.com/86337233/211394842-0a9b9db2-f2a5-4668-b5e8-bc8d634c323e.png)
#### 파이프라이닝 적용
![](https://user-images.githubusercontent.com/86337233/211394851-46a5b475-2554-47f4-b33e-5699f909e4cb.png)
- 데이터를 파이프라이닝하여 한번에 보내게 되면, RTT 횟수가 줄어들게 된다
	- 즉, 같은 시간 내에 더 많은 데이터를 전송할 수 있다

> [!fail] 신뢰적인 데이터 전송을 위한 파이프라이닝 적용
> 1. 각각의 전송 중인 패킷은 유일한 순서 번호를 가져야 한다
> 2. 프로토콜의 송신 측과 수신 측은 패킷을 하나 이상 버퍼링 해야한다

따라서, RDT가 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 어떻게 응답하는 지가 중요하다
- 다음과 같은 방법으로 파이프라인 오류 회복을 할 수 있다
1. GBN([[TCP#Go-Back-N ARQ|Go-Back-N]])
2. SR([[TCP#선택적 재전송(Selective Repeat ARQ)|Selective Repeat]])