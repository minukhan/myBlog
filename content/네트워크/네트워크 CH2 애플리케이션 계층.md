## 2.1 네트워크 애플리케이션의 원리

네트워크 애플리케이션 개발의 중심은 
**다른 위치의 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램**을 작성하는 것
이러한 프로그램들은 일반적으로 사용자 장치(컴퓨터, 스마트폰 등)나 서버에서 실행

예를 들어, 웹 애플리케이션에는 서로 통신하는 `서버`(웹 서버 프로그램)와 `클라이언트`(사용자 호스트에서 실행되는 브라우저 프로그램)로 구별되는 두 가지 프로그램이 있음

*클라이언트-서버 모델의 예: 웹 애플리케이션
- **서버 측**: 웹 서버 프로그램은 데이터센터나 호스팅 서비스에 있는 컴퓨터에서 실행
- **클라이언트 측**: 웹 브라우저는 사용자의 컴퓨터나 모바일 장치에서 실행
- 두 프로그램은 HTTP 프로토콜을 사용하여 인터넷을 통해 통신

중요한 것은 우리가 **라우터나 링크 계층 스위치처럼 네트워크 코어 장비에서 실행되는 소프트웨어까지 작성할 필요는 없다**는 점 !!!
(그렇게 하고 싶더라도 네트워크 코어 장비는 애플리케이션 계층에서 기능하지 않기 때문에 그렇게 할 수 없다.)

### 2.1.1 네트워크 애플리케이션 구조

애플리케이션 구조는 네트워크 구조와 분명히 다르다.
애플리케이션 개발자 관점에서 네트워크 구조는 고정되어 있고, 해당 애플리케이션의 특정 서비스 집합을 제공한다.
반면, 애플리케이션 구조는 애플리케이션 개발자가 설계하며, 애플리케이션이 여러 종단 시스템에서 어떻게 조직되어야 하는지를 알려준다.


	네트워크는 여러 계층으로 구성되어 있으며, 각 계층은 특정 기능을 담당 :
	1. **애플리케이션 계층**: 사용자와 직접 상호작용하는 프로그램(웹 브라우저, 이메일 앱 등)
	2. **전송 계층**: 데이터 전송의 신뢰성 보장(TCP, UDP 등)
	3. **네트워크 계층**: 패킷의 라우팅(IP 프로토콜)
	4. **링크 계층**: 물리적 연결을 통한 데이터 전송(이더넷 등)
	5. **물리 계층**: 비트의 전송(케이블, 무선 신호 등)

#### 애플리케이션 개발자가 집중하는 부분

**네트워크 애플리케이션 개발자는 주로 애플리케이션 계층에서만 작업**한다는 것 :

1. **종단 시스템에 집중**: 개발자는 종단 시스템(사용자 기기, 서버)에서 실행되는 소프트웨어만 작성합니다.
2. **네트워크 코어는 건드리지 않음**: 라우터, 스위치와 같은 네트워크 코어 장비에서 실행되는 소프트웨어는 작성하지 않습니다. 그 이유는:
    - 이러한 장비들은 주로 네트워크 계층(라우터)이나 링크 계층(스위치)에서 동작합니다.
    - 네트워크 코어 장비는 애플리케이션 계층을 "인식"하지 못합니다 - 그들의 주요 임무는 패킷을 효율적으로 전달하는 것입니다.
    - 일반 개발자들은 이러한 장비에 접근 권한이 없습니다. 이 장비들은 통신사나 네트워크 관리자에 의해 관리됩니다.
3. **API 사용**: 대신 개발자는 운영체제가 제공하는 네트워크 API(소켓 등)를 사용하여 애플리케이션이 네트워크와 통신할 수 있게 합니다.

> [!note] 웹 개발자는 HTTP, WebSocket 등의 프로토콜만 이해하면 되고, 패킷이 어떻게 라우팅되는지, 스위치가 어떻게 프레임을 전달하는지 등의 복잡한 세부사항을 알 필요가 없습니다. 이는 "관심사의 분리"라는 소프트웨어 설계 원칙의 좋은 예입니다.

#### 잘 알려진 애플리케이션 구조 2가지

##### 클라이언트-서버(client-server) 구조

- **항상 동작하고 있는 서버가 존재하고, 클라이언트라는 다른 호스트들로부터 서비스 요청을 받는다.**
- 클라이언트는 서로 직접적으로 통신하지 않는다.
- 서버는 잘 알려진 고정 IP 주소를 갖는다.
- 서버가 클라이언트로부터 오는 모든 요청에 더 응답하는 것이 불가능할 때,  
    많은 수의 호스트를 갖춘 데이터 센터가 강력한 가상의 서버를 생성하는 역할로 사용된다. 보통, 10만개 정도의 서버를 갖추고 있다.

aws 서버 왜 쓰지 ? 가상 서버를 만들어서 줄이고 늘리고
컴퓨터 하드웨어 하나로만 하는건 아니고
가상화라고 하는 기술을 이용해서 하드웨어와 별개로 논리적인 컴퓨터 단위로 구성, 하나의 큰 서버로 만들게 되면 대규모의 사람들을 받아올 수 있다.

실제로 데이터 센터 -> 수많은 하드웨어들이 존재하고, 이를 하나로 묶어서 하나의 가상서버처럼 존재하게 된다

불이 난다던가 전력이 끊기면 박살이 날 수 있으므로 데이터센터도 이중화해서 여러개로 분리할 수 있음

-> 카카오톡 사태처럼 전체적으로 맛탱이가 갈 수도 있음

클라이언트-서버 구조는 마치 식당과 비슷 :
- **서버(식당)**: 항상 문을 열고 손님을 기다리고 있습니다
- **클라이언트(손님)**: 필요할 때만 식당에 와서 음식(서비스)을 요청합니다
- 손님들은 서로 직접 음식을 교환하지 않고, 항상 식당을 통해 서비스를 받습니다
- 식당은 항상 같은 장소(고정 IP 주소)에 있어서 누구나 찾아갈 수 있습니다
- 손님이 너무 많으면 하나의 식당으로는 감당이 안 되므로, 체인점(데이터 센터)을 여러 개 만들어 처리합니다

#실생활예시
- 유튜브: 서버(유튜브 서버)가 모든 동영상을 저장하고, 클라이언트(우리의 기기)는 그 서버에서 영상을 가져와 봅니다
- 이메일: 이메일 서버가 모든 메일을 관리하고, 우리는 이메일 앱으로 접속해서 확인합니다


##### P2P 구조 

- 항상 켜져있는 인프라스트럭처 서버에 최소로 의존한다. (혹은 의존하지 않는다.)
	- 두 단말에서만 전송이 일어난다는 말 = 웹소켓
	- 최소로 의존 = webRTC : 상태정도는 서버가 점검을 해줌
- 대신에 애플리케이션은 `peer`라는 **간헐적으로 연결된 호스트 쌍이 서로 직접 통신하게 한다.**
- peer는 흔히 알려진 클라이언트(개인 데스크톱과 랩톱 등등)이다.
- 자가 확장성을 가진다. 예를 들어, 파일 공유 애플리케이션에서는 각 피어들이 파일을 요구하여 작업 부하가 생기지만  
    각 피어들은 파일을 다른 피어들에게 분배하여 시스템에 서비스 능력을 갖춘다.
- 데이터 센터 등이 필요 없으므로 비용 효율적이다.

이웃간의 물물교환이나 공유 경제와 비슷한 느낌
- **중앙 서버 없음**: 큰 식당이나 상점 없이, 이웃들끼리 직접 물건을 교환합니다
- **직접 연결**: 필요한 것이 있으면 그것을 가진 다른 사람(peer)과 직접 연결해 교환합니다
- **간헐적 연결**: 모든 사람이 항상 연결되어 있지는 않고, 필요할 때만 연결됩니다
- **자가 확장**: 사람이 많아질수록 공유할 수 있는 물건(자원)도 많아집니다
    - 예: 파일 공유 시, 100명이 각각 5개 파일을 가지고 있다면 총 500개의 파일이 공유됩니다
- **비용 효율적**: 큰 창고나 상점을 운영할 필요가 없어 비용이 절감됩니다

#실생활예시
- 토렌트(BitTorrent): 중앙 서버 없이 사용자들끼리 직접 파일을 주고받습니다
- 스카이프(초기 버전): 통화가 직접 사용자 간에 이루어지고 중앙 서버는 최소한의 역할만 함
- 블록체인 -> P2P를 따름 하나의 중앙서버에 데이터를 두면 보안적으로도 문제가된다...!!! 사용자가 peer 2 peer 로 연결 (완전히 p2p는 아닌데 중앙 집중식이 아니다~라는 의미)

그래서 과연 실제로는 어떤 구조를 많이 쓸까요????
-> 음~ 두 구조의 장점을 혼합한 하이브리드 형태로 운영되는 경우가 많답니다 ^^


### 2.1.2 프로세스 간 통신

> 실제 통신하는 것은 프로그램이 아니라, 실행되고 있는 프로그램인 프로세스이다.

2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메시지 교환으로 서로 통신한다.
송신 프로세스는 메시지를 만들어서 보내고 수신 프로세스는 메시지를 받고 역으로 메시지를 보냄으로써 응답한다.
##### 프로세스란?

프로세스는 단순히 "실행 중인 프로그램"
우리가 웹 브라우저나 메신저 앱을 실행하면, 그것이 프로세스가 됨

하지만 여기서 !! *컴공스러운* 답변을 하려면 어떻게 말해야할까???

> [!note] 잠만 이거 맞는지 다시 정확한 확인 필요
> 프로그램이 메인메모리에 적재돼서 메모리에 존재하는 상태 
> → 램에 올라갔다 = CPU가 실제로 접근할 수 있는 상태가 된다. 
> 자원할당받고 (CPU GPU) 할당받을 수 있는 상태가 되려면 주기억장치(메인메모리)에 올라가야됨. 
> 메인메모리에 올라간 프로그램 = 프로세스

 프로그램은 처음에 하드디스크나 SSD 같은 보조기억장치에 저장되어 있습니다.
 
	1. 실행 명령이 내려지면 프로그램은 주기억장치(RAM, 메인 메모리)에 적재됩니다.
	2. 메인 메모리에 적재된 프로그램은 이제 '프로세스'라고 부릅니다. 프로세스란 '실행 중인 프로그램'을 의미합니다.
	3. CPU는 메인 메모리에 있는 프로세스에 접근하여 명령어를 하나씩 실행합니다.
	4. 프로세스는 CPU, 메모리 등의 시스템 자원을 할당받아 작업을 수행합니다.
	
	즉, 프로그램이 메인 메모리에 올라가야만 CPU가 접근할 수 있고, 이 상태가 되어야 비로소 실행 가능한 '프로세스'가 됩니다. 프로세스는 또한 PCB(Process Control Block)라는 자료구조를 통해 관리되며, 여기에는 프로세스의 상태, 프로그램 카운터, 레지스터 값, 메모리 정보 등이 저장됩니다.

두 컴퓨터 간 통신은 사실 두 프로그램이 아닌, 두 "프로세스" 사이에서 일어남 :
- **송신 프로세스**: 메시지를 만들고 보내는 쪽
- **수신 프로세스**: 메시지를 받고 응답하는 쪽

#### 클라이언트와 서버 프로세스

클라이언트와 서버 프로세스를 다음과 같이 정의

> 💡 두 프로세스 간의 통신 세션에서  
> **통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스**를 `클라이언트(client)`라 하고,  
> **세션을 시작하기 위해 접속을 기다리는 프로세스**를 `서버(server)`라고 한다.

- **클라이언트**: 통신을 시작하는 프로세스 (요청을 보냄)
    - "안녕하세요, 연결할게요!" 라고 먼저 말을 거는 쪽
    - 예: 웹 브라우저, 카카오톡 앱
- **서버**: 연결 요청을 기다리는 프로세스 (요청을 받음)
    - "누가 연결해 오려나?" 하며 기다리는 쪽
    - 예: 웹서버, 카카오톡 서버

🔍 **쉬운 예시**: 식당에서 손님(클라이언트)이 주문을 시작하고, 점원(서버)은 주문이 들어오길 기다립니다.

P2P 구조에서도 봤듯이 클라이언트도 서버 프로세스가 될 수 있고, 서버도 클라이언트 프로세스가 될 수 있음
-> 각 피어들이 연결할 때 클라이언트가 될수도, 서버가 될수도있음

#### 프로세스와 컴퓨터 네트워크 사이의 인터페이스
##### 소켓 (Socket): 프로세스와 네트워크의 연결고리
프로세스는 `소켓(socket)`을 통해 네트워크로 메시지를 보내고 받음

네트워크에서 프로세스를 집(실행중인 프로그램이니까) 이라 한다면,
소켓은 프로세스가 네트워크와 통신하는 "문"과 같다고 보면 되는데 :
![](https://i.imgur.com/YSMTzpx.png)

`프로세스 (애플리케이션) → 소켓 → 네트워크 (트랜스포트 계층)`

- 소켓은 애플리케이션 계층과 트랜스포트 계층 사이의 인터페이스
- 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로, **애플리케이션과 네트워크 사이의 API**라고도 함
- 개발자는 소켓의 애플리케이션 쪽은 마음대로 제어할 수 있지만, 트랜스포트 쪽은 제한적입니다

💡 **비유**: 소켓은 마치 우체통과 같습니다. 여러분(애플리케이션)은 편지를 넣을 수 있지만, 그 이후 배달 과정(트랜스포트)은 우체국에 맡깁니다.

#### 프로세스 주소 배정

네트워크에서 프로세스에 메시지를 보내려면 두 가지 정보가 필요 :

1. **IP 주소**: 어느 컴퓨터(호스트)인지
    - 예: 192.168.1.100 (특정 컴퓨터의 주소)
2. **포트 번호**: 그 컴퓨터의 어느 프로세스인지 (그 호스트 내의 수신 프로세스를 명시하는 식별자)
    - 예: 80 (웹 서버), 443 (보안 웹 서버), 25 (이메일 서버)

🏠 **비유**: IP 주소는 아파트 주소, 포트 번호는 몇 동 몇 호인지 알려주는 것과 같음


### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스

송신 측의 애플리케이션은 소켓을 통해 메시지를 보내고,  
트랜스포트 프로토콜은 **네트워크를 통해 그 메시지를 수신 프로세스의 소켓으로 이동시킬 책임**이 있다.

트랜스포트 프로토콜은 네트워크를 통해 메시지를 전달하는 책임을 가진 중요한 역할을 함
이제 트랜스포트 프로토콜이 애플리케이션에 제공하는 4가지 주요 서비스를 쉽게 알아보자 !!!

#### 1. 신뢰적 데이터 전송 (Data Integrity)

##### 기본 개념
- 데이터가 손실 없이 정확하게 도착하도록 보장하는 서비스
- 프로토콜이 보장된 데이터 전송 서비스를 제공함

#쉬운비유 
📬 **우체국 서비스**의 두 종류로 생각해 볼 수 있습니다:

- **등기 우편**(신뢰적): 배달 확인과 추적이 가능
- **일반 우편**(비신뢰적): 가끔 편지가 분실될 수도 있음

#실제활용
- **신뢰적 전송이 필요한 경우**: 파일 전송, 웹 브라우징, 이메일
    - 데이터가 하나라도 손실되면 문제가 생깁니다!
- **신뢰적 전송이 덜 중요한 경우** (손실 허용 애플리케이션):
    - 화상 통화, 실시간 스트리밍
    - 몇 프레임이 누락되어도 전체 경험에 큰 영향을 주지 않습니다.

#### 2. 처리율 (Throughput)

##### 기본 개념
- 단위 시간당 전송할 수 있는 데이터의 양
- 트랜스포트 프로토콜은 어느 명시된 속도에서 **보장된 가용 처리율**을 제공

#쉬운비유
🚗 **고속도로**를 생각해보세요:

- 차선이 많을수록(대역폭이 클수록) 더 많은 차량(데이터)이 동시에 지나갈 수 있음
- 하지만 교통량(다른 사용자)이 많으면 속도가 떨어질 수 있음

##### 애플리케이션 유형

1. **대역폭 민감 애플리케이션**:
    - 최소한의 처리율이 보장되어야 작동하는 서비스
    - 예: 넷플릭스, 유튜브, 온라인 게임 -> 많은 멀티미디어 애플리케이션이 대역폭에 민감
    - 단, 너무 처리율이 낮으면 전화같은 서비스가 불가능함
2. **탄력적 애플리케이션**:
    - 가용 처리율에 맞춰 작동할 수 있는 서비스
    - 느려도 동작은 함
    - 예: 이메일, 파일 다운로드 (느려도 결국 받아지긴 함)

 > **넷플릭스 예시**
 > 
> 넷플릭스 같은 스트리밍 서비스는 대역폭 민감 애플리케이션의 대표적인 예입니다. 이런 서비스들이 원활하게 작동하기 위해서는 일정 수준 이상의 처리율(대역폭)이 지속적으로 유지되어야 합니다.
> 
> 스트리밍 중 로딩 현상이 발생하는 이유는:
> 1. 네트워크 대역폭이 일시적으로 감소
> 2.  시청 중인 영상의 품질에 필요한 최소 처리율 미달
> 3. (미리 다운로드해 놓은 영상)의 소진
> 
> 넷플릭스는 실시간으로 네트워크 상태를 감지하고 있다가 대역폭이 낮아지면:
> 	- 먼저 버퍼에 저장된 영상을 재생
> 	- 버퍼가 소진되면 로딩 아이콘을 표시하며 대기
> 	- 그래도 상황이 개선되지 않으면 자동으로 영상 품질을 낮추어 대역폭 요구사항을 줄임

#### 3. 시간 (Timing)

##### 기본 개념
- 데이터가 얼마나 빨리 도착하는지에 대한 보장

#쉬운비유
⏱️ **피자 배달**로 생각해보세요:

- "30분 내 배달 보장" - 특정 시간 내에 도착을 보장합니다.

#실제활용 
- **실시간 애플리케이션**에서 중요:
    - 온라인 게임: 버튼을 누르면 즉시 반응해야 함
    - 화상 회의: 대화 지연이 적어야 함
    - 원격 의료 시스템: 의사의 명령이 빠르게 전달되어야 함

#### 4. 보안 (Security)

##### 기본 개념
- 데이터를 암호화하여 외부에서 읽을 수 없게 만드는 서비스
- 송신 호스트에서 트랜스포트 프로토콜은 모든 데이터를 암호화할 수 있고, 수신 호스트에서 트랜스포트 프로토콜은 모두 해독할 수 있음

#쉬운비유
🔒 **비밀 편지**:

- 특별한 잉크로 쓰면 오직 특정 용액을 가진 사람만 읽을 수 있습니다.

#실제구현
- TCP를 강화한 **TLS(Transport Layer Security)** 가 널리 사용됨
- 웹사이트 주소가 `https://`로 시작하면 TLS를 사용하는 것임 (한얼이가 더 자세하게 설명해줄것 ㅇㅇ)
- 주요 기능:
    - 데이터 암호화: 제3자가 읽을 수 없게 함
    - 인증: 실제로 원하는 서버와 통신하고 있는지 확인
    - 데이터 무결성: 전송 중 변조되지 않았음을 보장


### 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

#### TCP 서비스

TCP(Transmission Control Protocol)는 신뢰성이 높은 연결 중심의 프로토콜
마치 전화 통화처럼 연결을 먼저 설정하고 대화하는 방식

##### 연결 지향형 서비스
애플리케이션 계층 메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환

-> **핸드셰이킹(Handshaking)** 과정이란?
- 데이터를 주고받기 전에 먼저 "안녕, 통신할 준비 됐어?"라고 확인하는 과정
- 마치 비즈니스 미팅에서 악수를 먼저 하는 것과 같음
- 이 클라이언트와 서버에 패킷이 곧 도달할테니 준비하라고 알려주는 역할

핸드셰이킹 단계를 지나면, TCP 연결이 두 프로세스의 소켓 사이에 존재한다고 말함
**전이중 연결(Full-duplex Connection)** 이란?
- 양쪽이 동시에 데이터를 주고받을 수 있는 연결
- 마치 양방향 도로처럼 양쪽에서 동시에 차가 다닐 수 있는 구조

##### 신뢰적인 데이터 전송 서비스
TCP는 데이터 전송의 "안전 요원"과 같음:

- **완전성 보장**: 모든 데이터가 손실 없이 전달됩니다.
- **순서 보장**: 보낸 순서대로 도착합니다.
- **중복 방지**: 같은 데이터가 두 번 전송되지 않습니다.

📚 **간단한 비유**:
- 페이지 번호가 적힌 책의 페이지들을 순서대로 전달하는 것과 같음 ㅇㅇ 페이지가 누락되거나 순서가 바뀌면 바로 재요청
- TCP는 애플리케이션의 한 쪽이 바이트 스트림을 소켓으로 전달하면, 그 바이트 스트림이 손실되거나 중복되지 않게 수신 소켓으로 전달

##### 혼잡 제어 방식

TCP는 교통 경찰과 같은 역할을 함:

- 네트워크가 혼잡할 때 데이터 전송 속도를 줄입니다.
- 이를 통해 모든 사용자가 공정하게 네트워크를 사용할 수 있습니다.

🚦 **간단한 비유**:
- 고속도로가 막히면 더 많은 차량이 진입하지 못하도록 진입로에서 차량을 통제하는 것과 비슷합니다.


#### UDP 서비스

UDP(User Datagram Protocol)는 간단하고 빠른 프로토콜 
마치 우편엽서를 보내는 것과 같이 그냥 보내고 확인하지 않는 방식

##### 비연결형 서비스
- **핸드셰이킹 없음**: "준비됐니?"라고 묻지 않고 바로 데이터를 전송함
- **오버헤드 감소**: 연결 설정에 시간을 소비하지 않아 빠름

##### 비신뢰적인 데이터 전송
- **전달 보장 없음**: 데이터가 목적지에 도착할 것이라는 보장이 없음
- **순서 보장 없음**: 데이터가 보낸 순서와 다르게 도착할 수도 있음

🎬 **간단한 비유**:
- 실시간 영상 스트리밍에서 몇 프레임이 누락되어도 전체 경험에는 큰 영향이 없는 것과 같습니다.

##### 혼잡 제어 없음
- UDP는 네트워크 상태와 관계없이 일정한 속도로 데이터를 전송합니다. -> 프로스세의 속도 저하 없이 네트워크 이용 가능
- 이는 실시간 애플리케이션에 유리하지만, 혼잡한 네트워크에서는 많은 패킷이 손실될 수 있습니다.
- 또한 혼잡으로 인해 처리율이 낮아져서 속도가 오히려 더 낮아질 수도 있음

🏎️ **간단한 비유**:
- 제한 속도를 신경 쓰지 않고 계속 달리는 자동차와 같습니다. 빠르게 갈 수 있지만 교통 체증이 심하면 결국 사고(패킷 손실)가 날 가능성이 높아집니다.


#### 인터넷 트랜스포트 프로토콜이 제공하지 않는 서비스

TCP와 UDP 모두 제공하지 않는 서비스

##### 처리율 보장 없음
- **원하는 속도로 데이터를 전송할 수 있다는 보장이 없습니다.**
- 네트워크 상황에 따라 전송 속도가 변할 수 있습니다.

##### 시간 보장 없음
- **데이터가 특정 시간 내에 도착한다는 보장이 없습니다.**
- 네트워크 상황에 따라 지연 시간이 달라질 수 있습니다.

#### TCP와 UDP의 활용 예시

##### TCP를 사용하는 애플리케이션
- 웹 브라우징 (HTTP/HTTPS)
- 이메일 (SMTP)
- 파일 전송 (FTP)
- 원격 접속 (SSH)

##### UDP를 사용하는 애플리케이션
- 실시간 스트리밍 (일부 비디오/오디오)
- 온라인 게임
- DNS 쿼리
- VoIP (인터넷 전화)


### 2.1.5 애플리케이션 계층 프로토콜

> 💡 애플리케이션 계층 프로토콜은 다른 종단 시스템에서 실행되는 **애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의함

이는 다음과 같은 내용을 정의
- 교환 메시지의 타입
- 여러 메시지 타입의 `문법(syntax)`
- 필드의 의미, 즉 필드에 있는 정보의 `의미(semantics)`
- 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지를 결정하는 규칙

  
여러 애플리케이션 계층 프로토콜은 RFC에 명시되어 있어 공중 도메인에서 찾을 수 있다.

예를 들어, 만약 브라우저 개발자가 HTTP 규칙을 따른다면, HTTP 규칙을 따른 어떠한 웹 서버로부터도 웹페이지를 가져올 수 있다.
다른 많은 애플리케이션 계층 프로토콜은 독점이며 공중 도메인에서 찾을 수 없다.


애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 **한 요소**일 뿐이다.
예를 들어, 웹 애플리케이션은 문서 포맷 표준, 웹 브라우저, 웹 서버, 웹 애플리케이션 계층 프로토콜(HTTP)을 포함하는 여러 요소들로 구성된다.

## 2.2 웹과 HTTP

웹은 `온디맨드(on-demand) 방식`으로 **사용자가 원할 때 원하는 것을 수신한다.**
즉, TV 방송처럼 정해진 시간에 정해진 내용이 나오는 것이 아니라, 사용자가 필요할 때 필요한 정보를 요청하고 받아볼 수 있다는 것.

개인은 또한, 웹 상에서 많은 정보를 얻고 상호작용할 수 있다.

### 2.2.1 HTTP 개요

`웹 애플리케이션 계층 프로토콜`은 웹의 중심
RFC 1945, RFC 7230, RFC 7540에 정의되어 있다.

`HTTP`는 **메시지의 구조** 및 **클라이언트와 서버가 메시지를 어떻게 교환하는지**에 대해 정의하고 있음

#### 간단한 웹에 대한 용어 
-> 알아서 공부하기!!!

#### HTTP와 TCP

##### HTTP의 이해
HTTP(HyperText Transfer Protocol)는 **웹에서 정보를 주고받는 약속(프로토콜)**
	웹 브라우저와 웹 서버
	1. **웹 브라우저(클라이언트)**: 사용자가 웹을 탐색하는 도구
	    - Chrome, Firefox, Safari 등이 대표적인 예
	    - HTTP의 클라이언트 측을 구현함
	2. **웹 서버**: 웹 페이지와 자원을 저장하고 제공하는 컴퓨터
	    - 사용자가: "이 페이지 보여줘" 하고 요청하면
	    - 서버는: "여기 있어" 하고 페이지 데이터를 보내줌

##### HTTP와 TCP의 관계
HTTP는 TCP 위에서 동작 = > HTTP는 `TCP`를 전송 프로토콜로 사용 :

1. **연결 설정**: 브라우저가 서버에 TCP 연결을 먼저 맺습니다 (악수를 하는 과정)
2. **소켓 통신**: 연결이 성공하면 양쪽은 소켓(통신 창구)을 통해 데이터를 주고받습니다
	1. 연결이 이루어지면, 브라우저와 서버 프로세스는 각각의 소켓 인터페이스를 통해 TCP로 접속한다.
	2. 클라이언트는 `HTTP 요청 메시지`를 소켓 인터페이스로 보내고, 소켓 인터페이스로부터 `HTTP 응답 메시지`를 받는다. 마찬가지로, HTTP 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.
3. **신뢰성 보장**: TCP는 패킷 손실, 순서 뒤바뀜 등의 문제를 자동으로 처리해 줍니다
    - 마치 우체국에서 택배를 보낼 때 추적 번호를 부여하고, 분실되면 다시 보내는 것과 비슷합니다
    - 덕분에 HTTP는 데이터 전송의 신뢰성에 신경 쓸 필요가 없습니다

> *HTTP 통신 과정 예시*
> 실제 웹 페이지를 불러오는 과정을 쉽게 설명하면:
>
>1. 사용자가 브라우저에 URL(`www.example.com`)을 입력합니다
>2. 브라우저는 `www.example.com` 서버에 TCP 연결을 맺습니다
>3. 브라우저가 서버에 HTTP 요청 메시지를 보냅니다: "index.html 페이지 주세요"
>4. 서버는 요청을 받고 해당 파일을 찾습니다
>5. 서버는 HTTP 응답 메시지와 함께 HTML 파일을 보냅니다: "여기 있어요"
>6. 브라우저가 HTML을 받아 화면에 표시하기 시작합니다
>7. HTML 내에 이미지, CSS, JavaScript 등 다른 객체에 대한 참조가 있으면, 각각에 대해 2~6단계를 반복합니다
>8. 모든 객체가 로드되면 웹 페이지 표시가 완료됩니다

#### 비상태(stateless) 프로토콜

HTTP의 중요한 특성 중 하나는 **상태를 유지하지 않는다**는 점 :
- 서버는 이전 요청에 대한 정보를 기억하지 않음
- 같은 사용자가 같은 페이지를 짧은 시간 내에 두 번 요청해도, 서버는 "아까 보냈는데?"라고 하지 않고 다시 보냄
- 이것은 마치 햄버거 가게에서 같은 손님이 5분 전에 햄버거를 사 갔어도, 다시 와서 주문하면 또 햄버거를 주는 것과 같음
- 이런 특성 때문에 웹사이트에서 로그인 상태를 유지하려면 쿠키나 세션 같은 추가 기술이 필요 ㅇㅇ!!!!

### 2.2.2 비지속 연결과 지속 연결

HTTP 1.0 -> 비지속 연결임 (이거에 대해서도 좀 더 정리하기)


### 2.2.4 사용자와 서버 간의 상호 작용 : 쿠키 (cookie)

HTTP는 기본적으로 상태를 유지하지 않는(stateless) 프로토콜이지만,
많은 웹 서비스는 사용자 맞춤 경험을 제공하기 위해 사용자를 식별할 필요가 있음
이를 위한 해결책이 바로 **쿠키(cookie)**
내가만든쿠키~~

![](https://i.imgur.com/U91ADIT.png)

#### 쿠키가 필요한 이유

웹 서버가 사용자 상태를 기억해야 하는 상황은 생각보다 많음 !! :
- 사용자별 맞춤 콘텐츠 제공 (예: 추천 상품)
- 로그인 상태 유지
- 장바구니 정보 저장
- 사용자 활동 추적
- 접속 제한 (예: 하루 최대 방문 횟수)

#### 쿠키 동작 과정 (상세 설명)

##### 1. 최초 방문 시

사용자가 웹사이트에 처음 방문하면:

1. **사용자의 요청 전송**:
    - 브라우저가 웹 서버에 HTTP 요청을 보냅니다.
    - 이 시점에는 쿠키가 없으므로 서버는 이 사용자가 누구인지 모릅니다.
2. **서버의 사용자 식별 작업**:
    - 서버는 "이 사용자를 기억하기 위한" 고유 식별 번호(ID)를 생성합니다.
    - 이 ID는 서버의 데이터베이스에 저장됩니다 (예: 사용자 ID: 12345).
    - 이 데이터베이스에는 해당 사용자에 관한 정보를 저장할 수 있습니다.
3. **쿠키 생성 및 전송**:
    - 서버는 HTTP 응답 메시지의 헤더에 `Set-cookie: 12345(식별변호)`와 같은 형태로 쿠키를 포함시킵니다.
    - 이것은 "당신의 ID 카드 번호는 12345입니다. 다음에 올 때 가져오세요"라고 말하는 것과 같습니다.
4. **브라우저의 쿠키 저장**:
    - 브라우저는 응답에서 `Set-cookie` 헤더를 발견하면 자체 쿠키 저장소에 이 정보를 저장합니다.
    - 쿠키에는 일반적으로 도메인 정보도 포함되어 있어, 어떤 웹사이트에 대한 쿠키인지 구분합니다.

##### 2. 재방문 시

사용자가 같은 웹사이트를 다시 방문하면:

5. **쿠키 포함 요청**:
    - 브라우저는 해당 사이트에 대한 쿠키를 자동으로 찾습니다.
    - 요청 메시지의 헤더에 `Cookie: 12345`와 같은 형태로 쿠키를 포함시킵니다.
    - 이것은 "안녕하세요, 제 ID 카드 번호는 12345입니다"라고 말하는 것과 같습니다.
6. **서버의 사용자 식별**:
    - 서버는 쿠키 값(12345)을 보고 데이터베이스에서 해당 사용자 정보를 조회합니다.
    - 이를 통해 서버는 "아, 이 사용자는 지난번에 방문했던 사람이구나"라고 인식합니다.
    - 저장된 사용자 정보에 기반하여 맞춤형 콘텐츠를 제공할 수 있습니다.

서드파티쿠키에 대해서 알아서 하기.. (to me)

### 2.2.5 웹 캐싱

웹 캐시(Web Cache) 또는 프록시 서버(Proxy Server)는 원본 웹 서버와 사용자 사이에 위치하여 웹 콘텐츠의 임시 저장소 역할을 하는 시스템


근데 여기서는 웹캐시랑 프록시 서버를 혼용해서 사용했는데 실제 네트워크 교과서나 HTTP 관련 문헌에는 둘을 동의어처럼 사용하는 경우가 많다...
왜냐하면 웹 캐시의 주요 구현이 프록시 서버 형태로 이루어지기 때문
-> 웹 캐시는 프록시 서버의 일종이다! 라고 말하는 것이 정확하다
-> 하지만 ! 프록시 서버는 웹캐시이다 라고 일반화하는 것은 정확하지 않음!!

#### 웹 캐시의 기본개념

- 최근에 요청된 웹 페이지, 이미지, 파일 등의 **복사본을 저장**
- 동일한 콘텐츠에 대한 **추후 요청 시 원본 서버에 접속하지 않고** 저장된 복사본을 제공
- 일종의 **"중간 창고"** 역할을 함으로써 데이터 전송 경로를 단축


![](https://i.imgur.com/zcO8ySL.png)

#### 웹 캐시 (프록시 서버) 동작과정
##### 1. 캐시에 콘텐츠가 있는 경우 (캐시 히트)
1. **요청 전송**:
    - 사용자가 브라우저에서 (TCP 연결로) 웹 페이지를 요청합니다(예: [www.example.com의](http://www.example.com%EC%9D%98) 이미지)
    - 이 요청은 웹 캐시로 전달됩니다
2. **캐시 확인**:
    - 웹 캐시는 자신의 저장소를 확인합니다
    - 이미지 있을 경우 "아, 이 이미지가 있네요!"
3. **응답 전송**:
    - 웹 캐시는 저장된 복사본을 바로 사용자에게 전송합니다
    - 원본 서버는 이 과정에 전혀 관여하지 않습니다

##### 2. 캐시에 콘텐츠가 없는 경우 (캐시 미스)
1. **요청 전송**:
    - 사용자가 브라우저에서 웹 페이지를 요청합니다
    - 요청이 웹 캐시로 전달됩니다
2. **캐시 확인**:
    - 웹 캐시는 저장소를 확인합니다
    - "이 콘텐츠는 저장되어 있지 않네요"
3. **원본 서버 접속**:
    - 웹 캐시는 원본 웹 서버에 TCP 연결을 설정합니다 
    - 웹 캐시가 원본 서버에 해당 콘텐츠를 요청합니다 -> 객체에 대한 HTTP 요청 보냄
4. **응답 수신 및 저장**:
    - 원본 서버가 요청된 콘텐츠를 웹 캐시에 전송합니다
    - 웹 캐시는 이 콘텐츠를 자신의 저장소에 복사해 저장합니다
5. **사용자에게 전달**:
    - 웹 캐시는 받은 콘텐츠를 사용자에게 전달합니다 -> 이때 이미 설정된 TCP 통해서 보냄
    - 다음에 동일한 요청이 오면 원본 서버에 접속하지 않고 바로 제공할 수 있습니다

CDN에 대해 공부를 하세요 -> 2.6에 있음 정리못해서죄송요
#### 웹 캐시의 설치 위치

웹 캐시는 다양한 위치에 설치될 수 있음:
- **기업 네트워크**: 회사 내부와 인터넷 사이의 경계에 설치
- **대학 캠퍼스**: 학교 네트워크와 인터넷 사이에 설치
- **ISP(인터넷 서비스 제공업체)**: 가정용 인터넷과 더 큰 인터넷 사이에 설치
- **콘텐츠 전송 네트워크(CDN)**: 전 세계 여러 지역에 분산 설치

#### 웹 캐싱의 주요 이점

##### 1. 응답 시간 단축
- 사용자와 웹 캐시 사이의 거리는 보통 사용자와 원본 서버 사이의 거리보다 짧습니다
- 따라서 캐시에서 콘텐츠를 가져오는 것이 더 빠릅니다
- 예: 한국에 있는 사용자가 미국 서버의 콘텐츠를 요청할 때, 한국에 있는 캐시가 이미 해당 콘텐츠를 가지고 있다면 미국까지 가지 않고도 빠르게 콘텐츠를 받을 수 있습니다

##### 2. 네트워크 트래픽 감소
- 동일한 콘텐츠에 대한 반복 요청이 원본 서버까지 가지 않아도 됩니다
- 이는 조직의 인터넷 연결 대역폭 사용량을 크게 줄여줍니다
- 예: 대학에서 인기 있는 비디오를 100명이 시청할 때, 첫 번째 요청 후에는 외부 인터넷으로 나가지 않고 캠퍼스 내부에서 처리할 수 있습니다

##### 3. 전체 인터넷 효율성 향상
- 전 세계적으로 웹 캐시 사용이 늘어나면 인터넷 전체의 트래픽이 줄어듭니다
- 이는 모든 웹 애플리케이션의 성능을 개선합니다
- 인터넷 백본(주요 간선망) 부하가 감소합니다

#### 캐시 유효성 관리

웹 콘텐츠는 시간이 지나면 변경될 수 있으므로, 캐시된 콘텐츠의 유효성을 관리하는 방법 필요 :

1. **만료 시간(TTL)**: 각 콘텐츠에 "유통기한"을 설정
2. **조건부 GET**: 캐시가 원본 서버에 "이 콘텐츠가 변경되었나요?"라고 물어보는 방식
	마지막으로 수정된 날짜 -> 중요
3. **캐시 제어 헤더**: 웹 서버가 콘텐츠의 캐싱 가능 여부를 지정하는 방식

### 2.2.6 HTTP/2

- 2020년 기준 주요 웹사이트의 약 40%가 HTTP/2 지원
- 주요 목표: 하나의 TCP 연결로 여러 요청/응답을 효율적으로 처리
-> 요청 우선순위화, 서버 푸시, HTTP 헤더 필드 등의 효율적인 압축 기능 제공

#### 기존 HTTP/1.1의 문제점

지속적인 연결을 사용할 때 **웹 페이지당 오직 하나의 TCP 연결**을 가짐으로써,  
아래 설명하듯이 서버에서의 소켓 수를 줄이며 전송되는 각 웹 페이지는 공정한 네트워크 대역폭을 가질 수 있다.

하지만 ... 최대 한 개의 메시지를 보내고 바로 닫히는 문제점이 있음 -> 매우 비효율적

그러나 하나의 TCP 상에서 모든 웹페이지를 보내면 `HOL(Head of Line) 블로킹 문제`가 발생할 수 있다.

- **HOL(Head of Line) 블로킹**: 큰 파일(예: 비디오) 전송 시 작은 파일들이 뒤에서 대기해야 함
	- 슈퍼마켓에서 첫번째 고객이 장바구니 가득 물건을 샀고 (큰 비디오파일) 그 뒤에 여러 고객들이 우유 한팩씩만 (작은 웹 객체들) 샀는데도 앞 고객의 물건을 계산하는 동안 (병목구간을 통과하는 시간) 뒷 고객들은 하염없이 한참을 자기차례될때까지 기다려야함
- 해결책으로 여러 TCP 연결(보통 6개)을 병렬로 사용했으나 이는 일종의 '꼼수' -> 일종의 속임수로 링크 대역폭의 많은 부분을 받게됨
- 서버 리소스 낭비와 TCP 혼잡 제어의 효율성 저하 문제 발생

#### HTTP/2의 주요 개선점

##### 1. 프레이밍(Framing)

- HTTP 메시지를 작은 프레임으로 분할하고 인터리빙(끼워넣기)하여 전송
- 예: 큰 비디오(1000개 프레임)와 작은 객체들(각 2개 프레임)을 번갈아가며 전송
- 하나의 TCP 연결만으로도 HOL 블로킹 문제 해결
- 바이너리 인코딩으로 효율성 및 오류 내구성 향상 -> 바이너리 프로토콜은 파싱하기에 효율적이고, 더 작은 프레임 크기를 갖고, 에러에 강함

##### 2. 메시지 우선순위화

- 발자들로 하여금 요청들의 상대적 우선 순위를 조정할 수 있게 함으로써 애플리케이션의 성능을 최적화할 수 있게 해줌
- 요청에 1-256 사이의 우선순위 부여 가능 -> 높은 수치일수록 높은 우선순위 가짐
- 중요한 리소스(CSS, JS 등)를 먼저 전송하도록 설정 가능
- 메시지 간 의존성도 지정 가능

##### 3. 서버 푸싱

-  서버로 하여금 **특정 클라이언트 요청에 대해 여러 개의 응답을 보낼 수 있게 해줌**
- 클라이언트 요청 전에 서버가 필요한 리소스를 미리 전송
- 예: HTML 페이지를 요청하면 서버가 관련 CSS, JS 파일도 함께 전송
- 이는 HTML 기반 페이지가 웹 페이지를 **완벽하게 구동시킬 필요가 있는 객체들을 가리킬 수 있기에** 가능한 것!
- 클라이언트의 요청-응답 지연 시간 단축

#### HTTP/3

- QUIC 프로토콜 기반의 차세대 HTTP
- 현재 표준화 진행 중
1. 구글 이 미친 사람들이 만들었음 ㄱ-
2. TCP 위에서 도니까 느린 거임 !!!!
3. 그래서 **UDP 위에서 돌아간다**
4. 그냥 UDP 는 아니고 udp와 quic 사이에 별의 별 설정을 다 해놨음 ㄷㄷ
5. 그래서 공식적으로 채택된게 HTTP/3.0 이다


## 2.3 인터넷 전자메일
이 부분은 알아서 공부하는 걸로 합시다 ㅠ...ㅠ


## 2.4 DNS: 인터넷의 디렉터리 서비스

#### 호스트명(Hostname)과 IP 주소의 관계

호스트명(예: www.google.com )은 **사람이 기억하기 쉽게 만들어진 이름**임
But 두 가지 정도의 문제가 있음

1. 위치 정보 부재: 이름만으로는 해당 컴퓨터가 인터넷 상에서 어디에 있는지 알 수 없음
2. 처리 어려움: 길이가 일정하지 않고 문자와 숫자가 섞여 있어 컴퓨터(라우터)가 효율적으로 처리하기 어려움

#### IP 주소

IP 주소(예: 121.7.106.83)는 컴퓨터가 인터넷에서 서로를 찾는 데 사용하는 **실제 주소** !!! 

1. 고정된 형식: 항상 4개의 숫자(0~255)로 구성되며 점(.)으로 구분됨 -> 각각 4바이트로 구성됨
2. 계층적 구조: 주소의 각 부분이 위치에 대한 힌트를 제공 (자세한건 4장이래)

### 2.4.1 DNS (Domain Name System)가 제공하는 서비스

사람은 호스트 네임을 선호하지만, *라우터* 는 고정 길이의 계층구조를 가진 IP 주소를 선호
> 이 차이를 절충하기 위해 **호스트 이름을 IP 주소로 변환해주는** 디렉터리(directory) 서비스가 필요

이 서비스가 인터넷 **`DNS(Domain name system)`** 의 주요 임무
(`hostname translations, address resolutions`)

#### DNS (Domain Name System)의 구조

DNS는 다음과 같은 주요 특징을 가짐:

1. **분산 데이터베이스**: 전 세계에 분산된 서버들로 구성됨
2. **계층적 구조**: 루트 서버 → 최상위 도메인(TLD) 서버 → 권한 있는 네임서버 등 여러 계층으로 구성됨
	1. TLD : Top Level Domain -> .com이나 .kr 같이 맨 뒤에 있는 최상단 도메인 (네임 서버의 가장 큰 도메인을 제공해준다)
3. **애플리케이션 계층 프로토콜**: OSI 7계층 중 애플리케이션 계층에서 동작
4. **UDP 사용**: DNS는 주로 UDP 프로토콜의 53번 포트를 사용

#### DNS가 UDP를 사용하는 이유

1. **빠른 속도**:
    - TCP는 연결 설정에 3-way 핸드셰이킹이 필요하지만, UDP는 이러한 과정 없이 바로 데이터를 전송합니다.
    - DNS 쿼리는 일반적으로 매우 작은 데이터(512바이트 이하)를 주고받기 때문에 UDP가 효율적입니다.
    - **패킷이 손실되더라도 다시 요청하면 되므로 신뢰성보다 속도가 중요합니다.**
2. **서버 리소스 절약**:
    - UDP는 연결 상태를 유지하지 않으므로 서버 메모리를 절약할 수 있습니다.
    - DNS 서버는 수많은 클라이언트 요청을 처리해야 하므로, 연결 상태 관리가 필요 없는 UDP가 유리합니다.

#### DNS 작동 과정
##### 사용자의 호스트에서 수행하는 브라우저가 URL을 검색했을 때 발생하는 일
= 웹 브라우저에 URL을 입력했을 때 발생하는 일:

1. 브라우저가 URL에서 호스트 이름(예: [www.example.com])을 추출
2. 운영체제의 DNS 클라이언트가 이 호스트 이름을 DNS 서버에 질의 -> (client queries to DNS server)
3. DNS 서버가 호스트 이름에 해당하는 IP 주소를 찾아 응답
4. 브라우저가 DNS로부터 IP 주소를 받으면, 이 IP 주소를 사용해 웹 서버(일반적으로 80번 포트)에 TCP 연결을 시도함
5. 연결이 성공하면 브라우저는 HTTP 요청을 보내고 웹 페이지를 로드

DNS는 위 예시에서 알 수 있듯이 추가 지연을 주지만,  
가까운 DNS 서버에 **`캐싱`** 되어 있어서 평균 DNS 지연 뿐만 아니라 DNS 네크워크 트래픽 감소에 도움을 줌 !!

뭔말이냐하믄
> DNS 서버는 한번 찾은 정보를 일정 시간 동안 저장(캐싱)합니다. 이를 통해:
> - 불필요한 DNS 쿼리를 줄여 네트워크 트래픽을 감소시킵니다.
> - 사용자가 웹 사이트에 더 빠르게 접속할 수 있습니다.


#### DNS의 추가 기능 (호스트 이름을 IP 주소로 변환하는 것 이외의 서비스)

1. **호스트 에일리어싱(별명 지정)** -> cname
    - 복잡한 정식 호스트 이름(canonical hostname)에 간단한 별명을 부여할 수 있음
    - 예: relay1.west-coast.enterprise.com(정식 이름) → enterprise.com(별명)
2. **메일 서버 에일리어싱** -> mx
    - 이메일 주소는 간단하게 유지하면서 복잡한 메일 서버 호스트 이름을 사용할 수 있음
    - 전자 메일 주소는 간단하지만 그 서버의 호스트 네임은 일반적으로 더 복잡함
    - 예: [info@company.com](mailto:info@company.com)이 실제로는 mail-server-03.region2.company.com으로 연결됩니다.
3. **부하 분산** **(load distribution)** -> 도메인 네임과 ip는 매핑이됨 *n:m임*
    - 인기 있는 웹사이트는 여러 서버에 분산되어 있을 수 있음 -> 각 서버가 다른 종단 시스템에서 수행되고 다른 IP 주소를 갖는다는 뜻
    - DNS는 하나의 도메인 이름에 여러 IP 주소를 연결할 수 있음
    - 클라이언트가 도메인 이름을 요청하면, DNS 서버는 연결된 IP 주소들을 순환식(round-robin)으로 제공할 수 있음
    - 이를 통해 서버 간에 트래픽이 자연스럽게 분산됨


### 2.4.2 DNS 동작 원리 개요

DNS가 도메인 이름을 IP 주소로 변환하는 과정은 다음과 같음
1. **요청 시작**: 컴퓨터에서 실행 중인 애플리케이션(예: 웹 브라우저)이 호스트 (도메인) 이름을 사용해 DNS 클라이언트를 호출
2. **질의 전송**: 컴퓨터의 DNS 클라이언트가 UDP 프로토콜의 53번 포트를 통해 DNS 서버에 질의 메시지를 보냅니다. -> 모든 질의와 응답 메시지는 `포트 53의 UDP 데이터그램` 으로 보내짐
3. **응답 수신**: DNS 서버가 IP 주소를 찾아서 응답하면, 이 정보가 애플리케이션에 전달됩니다.

이 과정은 간단해 보이지만, 실제로는 전 세계에 분산된 수많은 DNS 서버들 사이의 복잡한 통신이 이루어짐

#### 중앙 집중식 DNS의 문제점

왜 DNS는 하나의 큰 서버가 아닌 분산 시스템으로 설계되었을까? 

만약 전 세계의 모든 도메인 이름과 IP 주소를 하나의 대형 데이터베이스에 저장한다면:
1. **단일 장애점(Single Point of Failure)**: 이 하나의 서버가 고장나면 인터넷 전체가 마비됨
2. **트래픽 과부하**: 전 세계 모든 사용자의 DNS 요청을 하나의 서버가 처리하는 것은 불가능함 -> 단일 DNS가 모든 질의를 해결? 불가능.
3. **물리적 거리로 인한 지연**: 사용자와 중앙 서버 간의 거리가 멀수록 응답 시간이 길어짐
4. **관리의 어려움**:
    - 수십억 개의 호스트 정보를 한 곳에서 관리하는 것은 비현실적
    - 새로운 호스트가 등록될 때마다 데이터베이스를 갱신해야함
    - 호스트 등록 과정에서 보안 및 인증 문제가 발생

이러한 이유로 DNS는 **"확장성(scalability)"** 을 고려하여 **분산 계층 구조**로 설계된 것이다.

#### DNS의 분산 계층 구조

![](https://i.imgur.com/WsbaqgJ.png)

DNS는 전 세계에 분산된 여러 서버들이 계층적으로 구성되어 있음

##### 1. 루트(Root) DNS 서버
- 인터넷의 최상위에 위치한 서버들로, 전 세계에 약 1,000개 이상(복사본들이 많음)의 인스턴스 흩어져있음
- TLD(최상위 도메인) 서버들의 IP 주소 정보를 제공합니
- 인터넷 할당 번호 관리기관 -> ICANN(Internet Corporation for Assigned Names and Numbers)이라는 기관에 의해 관리되고 조정됨

##### 2. TLD(Top-Level Domain) DNS 서버
- `.com`, `.org`, `.net`과 같은 일반 최상위 도메인이나 `.kr`, `.uk`와 같은 국가 코드 최상위 도메인을 관리
- 각 도메인에 속한 책임 DNS 서버들의 IP 주소를 제공

##### 3. 책임(Authoritative) DNS 서버
- 특정 조직이나 서비스의 도메인에 속한 호스트들의 **실제 IP 주소 정보**를 보유함
- 기관이나 기업은 직접 이 서버를 운영하거나, DNS 호스팅 서비스를 이용할 수 있습니다.
- 예: `google.com`에 대한 책임 DNS 서버는 구글이 관리합니다.
- 기관은 직접 자신의 책임 DNS 서버의 구현을 선택할 수 있고, 일부 서비스 제공자의 책임 DNS 서버에 이 레코드를 저장하도록 비용을 지불함

-> 가비아라고 생각하면 됨 

##### 4. 로컬(Local) DNS 서버
- 계층 구조에 공식적으로 속하지는 않지만, DNS 시스템의 중요한 부분
- 인터넷 서비스 제공업체(ISP)나 조직 네트워크에서 운영 -> ISP는 로컬 DNS 서버를 갖고, 로컬 DNS 서버로부터 IP 주소를 호스트에게 제공함
- 사용자와 가장 가까이 위치해 빠른 응답 속도를 제공

![](https://i.imgur.com/Ym2GLFn.png)
###### 예시 정리 !!!!!

재귀적 질의 반복적 질의 -> 다시 정리필요
재귀적 질의 : local DNS로부터 바로 받음 직접 물어와서 다시 받음???
반복적 질의 : 내가 다시 root DNS로 감

대부분은 반복적 질의를 사용한다
재귀적 질의는 리소스 사용 비용이 너무 큼

#### DNS 캐싱

실제로는 DNS 지연 성능 향상과 네트워크의 DNS 메시지 수를 줄이기 위해 `캐싱(caching)`을 사용

> 질의 사슬에서 **DNS 서버는 DNS 응답을 받았을 때 로컬 메모리에 응답에 대한 정보를 저장할 수 있다.**

#DNS캐싱 
DNS 캐싱은 한번 조회한 도메인 이름과 IP 주소의 매핑 정보를 DNS 서버나 클라이언트의 메모리에 일정 기간 저장해두는 것
이는 마치 자주 가는 장소의 주소를 메모장에 적어두는 것과 비슷하다 생각하면 됨

##### DNS 캐싱의 작동 방식

1. **정보 저장**: DNS 서버가 도메인 이름에 대한 IP 주소를 찾으면, 이 정보를 자신의 로컬 메모리(캐시)에 저장합니다.
2. **캐시 활용**: 다른 사용자가 같은 도메인 이름에 대한 IP 주소를 요청하면, DNS 서버는 전체 조회 과정을 다시 수행하지 않고 캐시에서 바로 정보를 제공합니다.
3. **권한 없는 응답**: 중요한 점은 DNS 서버가 해당 도메인에 대한 공식적인 책임(authority)이 없더라도 캐시된 정보를 제공할 수 있다는 것입니다.

##### DNS 캐싱의 이점

1. **응답 속도 향상**: 캐시된 정보는 즉시 제공되므로, 사용자는 더 빠르게 웹사이트에 접속할 수 있습니다.
2. **네트워크 트래픽 감소**: 매번 전체 DNS 조회 과정을 수행하지 않기 때문에, DNS 메시지의 수가 줄어들어 전체 네트워크 부하가 감소합니다.
3. **DNS 서버 부하 감소**: 특히 루트 및 TLD DNS 서버는 모든 질의에 응답할 필요가 없어져 과부하를 방지할 수 있습니다.

##### TTL(Time To Live)의 역할

캐시된 DNS 정보는 영원히 유효하지 않음!!!
why? -> IP 주소는 변경될 수 있기 때문

1. **만료 시간 설정**: 각 DNS 레코드에는 TTL(Time To Live) 값이 설정되어 있습니다. 이는 해당 정보가 캐시에 얼마나 오래 유지될지를 초 단위로 지정합니다.
2. **정보 갱신**: TTL이 만료되면 DNS 서버는 해당 정보를 캐시에서 제거하고, 다음 요청 시 새로운 정보를 가져옵니다.
3. **균형 조정**: TTL 값은 다음의 균형을 맞추는 역할을 합니다:
    - 너무 짧은 TTL: 캐싱의 이점이 줄어듭니다
    - 너무 긴 TTL: IP 주소가 변경되었을 때 오래된 정보가 계속 사용될 수 있습니다


### 2.4.3 DNS 레코드와 메시지

각 DNS는 하나 이상의 자원 레코드를 가진 메시지로 응답한다

#### DNS 자원 레코드

DNS(Domain Name System)는 사람이 읽기 쉬운 도메인 이름(예: google.com)을 IP 주소(예: 172.217.164.110)로 변환해주는 시스템
DNS 서버는 이 변환 정보를 **자원 레코드(Resource Records)** 형태로 저장

각 자원 레코드는 `(Name, Value, Type, TTL)` 형식의 4개 요소로 구성됨

- **Name**: 도메인 이름이나 호스트 이름
- **Value**: 해당 이름에 대한 정보(IP 주소 등)
- **Type**: 레코드 유형(A, NS, CNAME, MX 등)
- **TTL**: Time to Live - 레코드가 캐시에 저장되는 시간(초 단위) -> 자원 레코드의 생존 기간

#### 주요 DNS 레코드 유형

##### 1. A 레코드 (Address Record)

- **용도**: 호스트 이름을 IP 주소로 매핑
- **Name**: 호스트 이름 (예: [www.example.com](http://www.example.com))
- **Value**: 호스트 이름에 대한 IP 주소 -> IPv4 주소 (예: 192.168.1.1)
- **예시**: `(www.example.com, 192.168.1.1, A, 3600)`

	*도메인 네임으로 IP 매핑해주는 것* (우리가 걍 쓰는 것임) -> 그러므로 중요 ㅇㅇ
##### 2. NS 레코드 (Name Server)

- **용도**: 특정 도메인의 책임 DNS 서버 지정
- **Name**: 도메인 이름 (예: example.com)
- **Value**: 해당 도메인의 DNS 서버 호스트 이름 (예: ns1.example.com)
- **예시**: `(example.com, ns1.example.com, NS, 86400)`

	걍 이런게 있다~~~ 정도만 알아도됨

##### 3. CNAME 레코드 (Canonical NAME)

- **용도**: 호스트 이름에 대한 별칭(alias) 생성
- **Name**: 별칭 이름 (예: mail.example.com)
- **Value**: 정식(canonical) 호스트 이름 (예: server1.example.com)
- **예시**: `(mail.example.com, server1.example.com, CNAME, 86400)`

	즉 , 별칭 도메인을 써도 정식 도메인으로 가도록 할 수 있음

##### 4. MX 레코드 (Mail Exchange)

- **용도**: 도메인의 메일 서버 지정 -> 메일 서버의 정식 이름
- **Name**: 도메인 이름 (예: example.com)
- **Value**: 메일 서버의 호스트 이름 (예: mail.example.com)
- **예시**: `(example.com, mail.example.com, MX, 86400)`


메일 서버의 정식 이름을 얻기 위해서는 MX 레코드에 대한 질의를 해야 하고, 다른 서버의 정식 이름을 얻기 위해선 CNAME 레코드에 대한 질의를 한다

#### DNS 메시지 구조 -> 알 필요 없대 ㅠㅅㅠ

DNS 메시지는 질의(query)와 응답(response) 모두 동일한 구조를 가짐

![](https://i.imgur.com/NEHvNd9.png)

##### 헤더 영역 (12바이트)
1. **식별자(16비트)**: 질의와 응답을 매칭하는 ID 번호
2. **플래그 필드**:
    - **질의/응답 플래그(1비트)**: 0=질의, 1=응답
    - **책임 플래그(1비트)**: 이 서버가 질의된 도메인에 대한 책임 서버인지 표시
    - **재귀 요구 플래그(1비트)**: 클라이언트가 재귀적 질의를 원하는지 표시
    - **재귀 가능 필드(1비트)**: 서버가 재귀 질의를 지원하는지 표시
3. **개수 필드**: 페이로드 영역의 각 섹션에 있는 레코드 수를 나타냄

##### 페이로드 영역
1. **질문 영역**: 질의하는 도메인 이름과 레코드 타입 포함
2. **답변 영역**: 질의에 대한 자원 레코드들 포함
    - 하나의 질의에 여러 자원 레코드가 포함될 수 있음(예: 부하 분산을 위한 여러 IP 주소)
3. **책임 영역**: 다른 책임 서버에 대한 정보
4. **추가 영역**: 부가적인 도움 정보(예: MX 레코드에 대한 응답에서 메일 서버의 IP 주소 제공)


#### DNS 데이터베이스에 레코드 삽입

새로운 도메인 `networkutopia.com`을 `등록 기관(DNS registrar)` 에 등록하는 과정

1. **도메인 등록 기관(Registrar)에 등록**:
    - 도메인 이름 유일성 확인
    - 비용 지불
    - 주책임 서버와 부책임 서버 정보 제공
2. **TLD(Top-Level Domain) 서버에 정보 등록**: 등록 기관은 `.com` TLD 서버에 다음 레코드를 등록합니다:
    - NS 레코드: `(networkutopia.com, dns1.networkutopia.com, NS)`
    - A 레코드: `(dns1.networkutopia.com, 212.212.212.1, A)`
    - 부책임 서버에 대한 레코드도 유사하게 등록
3. **책임 DNS 서버에 호스트 정보 등록**:
    - 웹 서버의 A 레코드: `(www.networkutopia.com, 웹서버IP주소, A)`
    - 메일 서버의 MX 레코드: `(networkutopia.com, mail.networkutopia.com, MX)`
    - 메일 서버의 A 레코드: `(mail.networkutopia.com, 메일서버IP주소, A)`

이 모든 설정이 완료되면 사람들이 도메인 이름을 사용하여 웹사이트 방문과 이메일 통신이 가능해짐

뭐 이건 우리 많이 해봣자나 그치?


#### DNS 취약점 -> 알아만 두면 됨ㅇㅇ

##### DDoS 대역폭 플러딩 공격
###### 간단한 설명
이 공격은 마치 한 전화번호로 수천 명이 동시에 전화를 걸어 정상적인 전화 통화를 불가능하게 만드는 것과 같습니다.

###### 작동 방식
1. **공격자의 목표**: DNS 서버를 마비시켜 정상적인 도메인 이름 조회가 불가능하게 만듭니다.
2. **공격 방법**: 수많은 컴퓨터(보통 해킹된 기기들)가 DNS 서버에 동시에 대량의 요청을 보냅니다.
3. **결과**: 서버가 과부하되어 정상적인 사용자의 요청을 처리할 수 없게 됩니다.

###### 실제 사례
- 공격자들이 DNS 루트 서버(인터넷의 최상위 DNS 서버)를 공격했지만, 두 가지 이유로 큰 피해가 없었습니다:
    1. 많은 서버들이 이미 패킷 필터로 보호되고 있었습니다.
    2. 대부분의 로컬 DNS 서버가 중요 정보를 이미 캐시(임시 저장)하고 있었습니다.
- 그러나 Dyn이라는 주요 DNS 서비스 제공업체가 공격받았을 때는 Netflix, Twitter 같은 유명 서비스들이 일시적으로 접속 불가능해졌습니다.

  

##### DNS 중독 공격
###### 간단한 설명
이 공격은 우체국 직원이 배달 주소를 몰래 바꿔서 여러분의 우편물이 엉뚱한 곳으로 가게 만드는 것과 비슷합니다.

###### 작동 방식
1. **공격자의 목표**: DNS 서버의 캐시(임시 저장소)에 가짜 정보를 삽입합니다.
2. **속임수 방법**: 진짜처럼 보이는 거짓 DNS 응답을 DNS 서버에 보냅니다.
3. **결과**: DNS 서버가 이 거짓 정보를 저장하고, 사용자들을 실제 웹사이트가 아닌 공격자의 가짜 웹사이트로 안내합니다.

###### 공격의 위험성
- 사용자들은 자신이 가짜 웹사이트에 접속했다는 사실을 알아차리기 어렵습니다.
- 가짜 웹사이트는 진짜처럼 보이면서 사용자의 개인정보(로그인 정보, 신용카드 번호 등)를 훔칠 수 있습니다.

###### 방어 방법
- **DNSSEC**(DNS Security Extensions): DNS 정보에 디지털 서명을 추가하여 정보의 출처와 무결성을 검증하는 보안 프로토콜입니다.
    - 쉽게 말해, 각 DNS 응답에 위조할 수 없는 '신분증'을 부착하는 것과 같습니다.


## 2.6 비디오 스트리밍과 콘텐츠 분배 네트워크

### CDN 콘텐츠 분배 네트워크


### Dash 프로토콜 -> 넷플릭스


http , dns, cdn 이용 (Dash까지) **전체적인 흐름을 구상**해봐라


## 2.7 소켓 프로그래밍 : 네트워크 애플리케이션 생성

소켓이 뭔지 알아두고, 좀 알아두면 좋음
소켓 인터페이스 통해서 구현
이거에 대한 이야기임


