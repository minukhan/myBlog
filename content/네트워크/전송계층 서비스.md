
> 보내는건 하나의 STream 으로 보냄.




### UDP : 목적지만 기억한다. (한번 보내면 끝)
- 목적지 포트번호
- 목적지 IP 주소

8byte
DNS 가 UDP 사용
HTTP 3.0  퀵 

장점 : 빠르다, 오버헤드가 적다, 데이터를 실시간성을 보장.
단점 : 혼잡 제어를 하지 않는다. (데이터 이동중에 무슨일이 일어났는지 알 수 없음.)

최소기능 : 간단한 오류검사 ( UDP 체크섬 )

### TCP : 출발지, 목적지 모두 기억한다. (계속 연결중)

- 출발지 포트번호 
- 출발지 IP 주소
- 목적지 포트번호
- 목적지 IP 주소

20byte + a


- 연결을 짓기 위해서 리스닝소켓이란게 있다. 
- 이 리스닝소켓이 처음에 요청이 들어왔을때 그 출발지와 소통하는 소켓을 만들어줌.


1.0 : 모든게 신뢰적인 상태일 경우

어플리케이션에서 데이터를 받아서 보내면 끝.

2.0 : 패킷 안에있는 비트가 오류가 생길 수 있다. 

손상이 있으면 다시 받아야한다. ( 자동 재 전송 ) ARQ
 - ACK, NAK

2.1 : ACK, NAK 에 있는 비트에서도 오류가 날 수 있다. 

이를 해결하고자 나온 버전

2.2 : 상태를 기억하고있으면 NAK 를 없애도 될것이다. 

3.0 : 타이머를 달아서 비트 손실된것을 파악함.



기본적으로 TCP는 GO BACK N 을 사용한다. 

그 이유는 뒤에것들은 앞에것이 오기전까지는 데이터링크에서 올라갈 수 없음 근데 그렇게 커지다보면 큐가 커지게 되고 하드웨어 부족문제.

Go Back N : 오류가 생기면 그 오류가 생긴 지점부터 뒤에까지 다 날리고 다시 시작.

Selective Repeat : 오류가 생긴거 그거 하나만 다시 요청하는 것. 

어디까지 수신했다를 바이트로 계산.



## TCP 더 자세히

3way 핸드쉐이크
![](https://velog.velcdn.com/images%2Faverycode%2Fpost%2F22a2bab1-c8dd-4559-88b2-62d03cbff927%2F%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8-5.jpg)

 종료할때 4way 핸드쉐이크
![](https://velog.velcdn.com/images%2Faverycode%2Fpost%2F3ec34c06-3d54-45f3-a6fb-bc5bfb415001%2F%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8-6%202.jpg)



1. 흐름제어 : 송신 수신 속도를 맞춰주는 것 .
2. 오류제어 : 뭔가 이상하면 재전송 (ARQ)
3. 타임아웃 : 패킷이 손실되었을때를 알아채도록 하는것. 
4. 혼잡제어 : 혼잡하다 판단하면 적게보냄. 이게다임.



데이터 평면 


포워딩 테이블 : 전달을 할때 어떤 출력 포트로 갈지 판단하게끔 해주는 놈
라우터 내부에서 일어나는 일 

라우팅 테이블 : 다음 라우터로 어디로 가야하는지를 정하는 것. 


제어 평면 


# 인터넷 프로토콜(IP): IPv4, IPv6

IPv4 : 20byte 

