
### HTTP 란?

- 가장 중요한 키워드 비연결성, stateless
- WWW (월드 와이드 웹) 에서 데이터를 주고받기 위한 애플리케이션 계층의 프로토콜
- 클라이언트와 서버간에 메시지 형식을 어떻게 지정하고 전송할지, 다양한 명령어에 대해 어떤 동작을 수행해야할지 정의하는 규칙의 집합. 

- 치명적인 한계?
	- 모든 데이터를 평문으로 전송한다는 점. 
	- 이는 경로상의 어떠한 중개자들이 전송되는 데이터를 쉽게 엿보거나 변조할 수 있음을 의미. 
	- 비밀번호, 신용카드 정보같은 데이터를 HTTP로 전송하는건 매우 위험. 
	- 그래서 등장한게 HTTPS

### HTTPS 를 사용하면 안전한 이유? 

- HTTP + TLS(암호화) 를 섞어놓아서 안전하다!
- 평문으로 전송하는게 아니라 암호화 시켜서 전송.

- 각 레코드에 인증 태그가 부텅서 누군가 패킷을 몰래 바꾸면 검증이 실패됨.
- 변조가 방지된다. 

- 서버는 인증서를 제시하고, 그 인증서를 CA(인증기관)의 서명으로 증명함. 
- 그래서 중간에 위장 서버같은거를 안되게끔 보안적으로 방어. 

### 공개키, 대칭키 두가지 핵심 암호화 기법

##### 대칭키 암호화 

- 암호화와 복호화에 동일한 하나의 비밀키를 사용하는 방식.
- 암호화, 복호화 연산 속도가 매우 빨라서 대용량 데이터를 암호화 하는데 효율적
-  그러나 키 교환 문제가 발생.
	- 통신을 시작하기 전에 어떻게 안전하게 동일한 비밀키를 공유할까??
	- 중간에 탈취하면 끝이네?? 

### 비대칭키 암호화

- 수학적으로 밀접하게 연관된 한 쌍의 키(공개키, 개인키) 를 사용하는 방식

- 공개키는 누구에게나 공개될 수 있음. 
- 그러나 개인키는 소유자만이 안전하게 보관해야한다. 
- 개인키를 가지고있는 소유자만 내용을 볼 수 있음. 
- 이러면 키를 전송해서 생기는 문제를 해결함. 상대방의 공개키로 데이터를 암호화해서 보내면 개인키를 가진 상대방만이 안전하게 복호화 할 수 있음. 
- 그러나 매우 복잡해서 훨씬 느리다. 대용량 데이터를 암호화하는데는 적합하지 않음.

> 여기서 느끼는점. 암호화 하면서 생기는 속도 문제는 보안이랑 반비례하는듯. 
> 속도가 빠르면 보안이 낮아지고, 속도가 빠르면 보안이 높아지는 구조. 


### 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?

- *HTTPS 핸드셰이크(Handshake)**라는 과정을 통해 수립
- 공개키 암호화 방식으로는 중간자 공격에 취약하다. 
- 이 문제를 해결하기 위해 **디지털 인증서(Digital Certificate)**와 **인증 기관(Certificate Authority, CA)**이 사용

- **디지털 인증서**: 신뢰할 수 있는 제3자인 CA가 특정 도메인의 소유권을 확인한 후, 해당 서버의 공개키에 전자 서명을 하여 발급하는 일종의 신분증입니다.  
    
- **인증 기관 (CA)**: 공인된 신뢰 기관으로, 이들의 공개키는 대부분의 웹 브라우저에 미리 내장되어 있습니다.

#### HTTPS (SSL/TLS) 핸드셰이크 과정

1. **Client Hello**: 클라이언트가 서버에 접속을 시도하며, 자신이 지원하는 TLS 버전, 암호화 알고리즘 목그리고 무작위 바이트 문자열을 전송합니다.  

2. **Server Hello**: 서버는 클라이언트가 제시한 목록 중에서 하나의 암호화 알고리즘을 선택하고, 자신의 **디지털 인증서**와 또 다른 무작위 바이트 문자열을 클라이언트에게 전송합니다.  
    
3. **인증서 검증**
	- 클라이언트는 서버로부터 받은 인증서를 검증
	- 브라우저에 내장된 CA의 공개키를 이용해 인증서의 전자 서명을 확인
	- 서명이 유효하다면, 클라이언트는 이 인증서가 신뢰할 수 있는 CA에 의해 발급되었으며, 인증서에 포함된 공개키가 통신하려는 서버의 것임을 신뢰하게 됨
	- **이 단계가 중간자 공격을 방지하는 핵심 과정**.  
    
4. **키 교환**
	- 클라이언트는 이제 신뢰하게 된 서버의 공개키를 사용하여, 앞으로의 통신에 사용할 대칭키를 생성하기 위한 기반 데이터를 암호화하여 서버로 전송합니다.  
    
5. **세션키 생성**
	- 서버는 자신의 개인키를 사용해야만 클라이언트가 보낸 암호화된 데이터를 복호화 가능. 
	- 복호화에 성공하면 서버는 'pre-master secret' 값을 얻게 됨. 
	- 이제 클라이언트와 서버는 각자 맨 처음 교환했던 무작위 바이트 문자열들과 'pre-master secret' 값을 조합하여, 양측 모두 동일한 **세션키**를 생성. 이 세션키는 **대칭키** 인것.  
    
6. **보안 통신 시작**: 핸드셰이크 과정이 완료되면, 양측은 공유된 대칭키인 세션키를 사용하여 모든 후속 데이터를 암호화하고 복호화하며 통신을 시작하게됨.

### SSL과 TLS의 차이는 무엇인가요?

##### SSL (Secure Sockets Layer)
- 초창기 보안 프로토콜
- 심각한 보안 취약점이 발견되었음

##### TLS
- SSL을 기반으로 표준화한 후속 프로토콜 
- TLS 1.0
	- 사실상 SSL 3.0의 개선버전. 
- 그리고 나서 점차 개선해나가서 1.1, 1.2 등 그리고 현재에는 1.3으로 널리 발전하면서
- 보안이 강화되고 성능이 개선되었다고 함. 


> [!note] 정리
> 주요 차어짐은 TLS 가 SSL 에 비해서 더 강력한 암호화 알고리즘을 지원한다. 
> 그리고 핸드셰이크 과정을 개선했으며, 취약점 해결. 
> 현재는 SSL 안전하지 않아서 중단되었다고 함. 
> SSL, SSL 인증서 라는 용어는 관용적으로 사용하는거지 실제 기술로는 TLS를 사용한다고 함.



