
### JSON 웹 토큰 (JWT)

- 현대적인 인증 및 인가 시스템을 논하기 전에 JSON 웹 토큰(JWT) 에 대해 알아야함. 
- JWT 는 복잡한 인증, 인가 흐름을 가능하게 하는 핵심적인 기술.


### JWT에 대해서

- JWT는 두 당사자 간에 요청을 안전하게 전송하기 위해서 간결하고 URL-safe 한 방법을 제공
- JWT의 가장 큰 장점은 상태 비저장 특성이다. 
- 토큰 수신자는 토큰 자체에 포함된 정보만으로 유효성을 검증할 수 있다. 
- 그래서 별도의 데이터베이스 조회나 세션 저장소에 의존할 필요가 없다. 
	- 시스템 확장성, 분산환경에서의 유연성을 크게 향상시킨다. 

### 헤더

- 헤더는 토큰 자체에 대한 메타데이터, 특히 어떻게 토큰을 검증해야 하는지에 대한 정보를 담고있다. 
- 이는 JSON 객체를 Base64Url 로 인코딩한 형태이다. 

- `typ` (Type): 
	- 이 필드는 객체가 JWT임을 명시하며, 일반적으로 값은 "JWT"로 고정이라 함. 
- `alg` (Algorithm):
	- 서명 암호화에 사용된 알고리즘을 지정하는 필드. 
	- 헤더에서 가장 중요한 보안 관련 필드임
	- 이 값을 통해서 수신자는 어떤 방식으로 서명을 검증할지 알 수 있는것. 

### 페이로드 (클레임)

- 페이로드는 토큰의 핵심으로 전송하고자 하는 실제 데이터인 클레임을 포함한다. 
- JWT 페이로드 안에 UserId 같은 최소 식별자를 넣어놓고 토큰을 전달해서
- 인증 처리를 진행한다. 

### 서명 

- 서명은 JWT 무결성과 인증을 보장하는 암호학적 구성요소
- 이게 공식이라고 한다. 
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

- 검증 과정
	- 서버가 토큰을 받으면 같은 방식으로 다시 서명을 계산한다. 
	- 클라이언트가 보낸 서명과 비교한다. 
	- 일치하면 위변조 없는거고 다르면 위조됐다고 판단


### JWS 서명 알고리즘 비교 분석 

- 헤더의 alg 파라미터 선택은 시스템 보안 아키텍처에 중요한 결정임. 

##### 대칭키 (HS256)

- 서명과 검증에 동일한 하나의 공유 비밀키를 사용한다. 
- 토큰 발급자와 검증자가 동일한 서비스나, 서로를 완전히 신뢰하는, 긴밀하게 결합된 시스템에 이상적이다. 
- 비대칭 알고리즘보다 빠르지만 공유키의 안전한 관리 및 배포가 있어야함.
- 
##### 비대칭키 (RS256, ES256)

- 서명에는 개인키를, 검증에는 해당 개인키와 쌍을 이루는 공개키를 사용한다. 
- 분산 시스템 MSA 에 필수적이다. 
- 인증 서버만이 개인 키를 안전하게 보관하고 수많은 리소스 서버들은 공개키만으로 토큰을 독립적으로 검증한다. 
- 비대칭 알고리즘이 현대적인 애플리케이션의 권장 표준으로 자리잡음. 
- 발급자, 검증자를 명확하게 분리해서 보안을 크게 향상시키기 떄문. 
- 이는 분산 아키텍처가 지금 확산되고 있는 가운데 맞물려서 표준으로 굳어지는중. 


### 어떤 공격들이 있었을까??

##### alg  = none 취약점

- 과거에 존재했던 심각한 취약점.
- alg 를 none 으로 수정한다음에 서명을 제거해서 서버에 전송하는 방식. 
- 이 토큰을 유요하게 오인하는 경우가 있었다고 함. 

### JWT 를 수신하는 서버나 서비스는 검증이 필요함.

- 올바른 공개키를 사용해서 토큰의 서명을 검증한다. 
- 예상된 발급자와 일치하는지 확인한다.
- 자기 자신의 식별자가 포함되어있는지 확인한다. 
- 토큰이 만료되지 않았는지 확인한다. 
- 너무 오래된 토큰의 사용을 방지한다. 
- 재전송 공격을 방어한다. 

### 키관리 

- 비대칭 키의 경우 정기적인 키 교체, 안전하게 키를 관리 하는게 중요.
- JWT는 한번 발급되면 만료 시간까지 유효하다. 
- JWT를 강제로 죽이는것은 쉽지 않다고 함. 그래서 폐기전략이 필요하다고 함. 


### OAuth 2.0

- JWT와 같은 토큰을 사용해서 위임된 인가를 수행하는 프로토콜
- OAuth 2.0 이 사용자를 인증하는게 아니라, 특정 리소스에 대한 접근 권한을 부여하는데 초첨을 맞췄다. 

### 용어정리

- 리소스 소유자 :
	- 데이터의 소유자인 사용자. (나)
- 클라이언드 :
	- 리소스 소유자의 데이터에 접근하고자 하는 애플리케이션(웹 앱, 모바일 앱)
- 인증서버 : 
	- 리소스 소유자를 인증하고 동의를 얻어서 클라이언트에게 액세스 토큰을 발급하는 서버. 
	- OAuth 2.0 흐름의 심장부라고 함. 
	- 벡엔드(로그인 담당 서비스)
- 리소스 서버 : 
	- 보호된 리소스를 호스팅하고, 클라이언트로부터 받은 액세스 토큰을 검증하는 서버 
	- 벡앤드(데이터 제공 담당 서비스)

### 위임된 인가 

- OAuth 2.0의 핵심 아이디어는 사용자가 자신의 자격증명을 클라이언트에 직접 주지 않고, 대신 ‘토큰’을 통해 접근 권한을 위임한다. 

- **사용자 → 인증 서버**
    
    - 사용자는 자신의 **아이디/비밀번호를 클라이언트가 아니라 인증 서버**(예: 구글 로그인 페이지)에 입력
    - 이 과정에서 클라이언트는 사용자의 비밀번호를 전혀 알 수 없음
        
- **인증 서버 → 토큰 발급**
    
    - 인증 서버가 로그인 확인 후 **Access Token** 발급
    - 이 토큰은 “사용자가 특정 리소스에 접근할 권한이 있다”를 증명
        
- **토큰 전달 → 클라이언트**
    
    - 인증 서버가 토큰을 클라이언트에게 전달
    - 클라이언트는 **토큰만 가지고 API 요청 가능**
    - 비밀번호는 클라이언트가 알 필요가 없음
        
- **클라이언트 → 리소스 서버**
    
    - 클라이언트는 토큰을 들고 **리소스 서버(API)**에 요청
    - 리소스 서버는 토큰 검증 후, 사용자가 접근 권한이 있는 데이터 반환
