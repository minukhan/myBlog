> [!tldr] 트랜잭션(Transaction)이란?
> 데이터베이스의 무결성과 일관성을 보장하는 핵심 메커니즘으로, 여러 데이터베이스 작업을 하나의 논리적 단위로 묶어 처리한다.

관련 개념: [[공유락 , 베타락]], [[낙관적 락, 비관적 락]], [[교착상태 (DeadLock)]], [[MySQL]], [[PostgreSQL]]
## 1. 트랜잭션의 의미
트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위이다. 트랜잭션은 "모 아니면 도" 방식으로 **완전히 실행되거나 전혀 실행되지 않아야 한다.**

트랜잭션은 **ACID 속성**으로 정의된다.
- [*] **원자성(Atomicity)**: 트랜잭션의 모든 연산이 완전히 수행되거나 전혀 수행되지 않아야 한다.
- [*] **일관성(Consistency)**: 트랜잭션 실행 전후에 데이터베이스는 일관된 상태를 유지해야 한다.
- [*] **격리성(Isolation)**: 동시에 실행되는 트랜잭션들이 서로 간섭하지 않아야 한다.
- [*] **지속성(Durability)**: 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다.

트랜잭션은 BEGIN(또는 START TRANSACTION)으로 시작하여 COMMIT(성공적 완료) 또는 ROLLBACK(취소)으로 종료된다. 일부 데이터베이스 시스템에서는 각 SQL 문이 자동으로 트랜잭션으로 처리되는 "자동 커밋" 모드가 기본값이다.
## 2. SQL문 레벨에서의 롤백

> [!question] 롤백(Rollback)이란?
> 트랜잭션에서 수행된 모든 변경사항을 취소하고 트랜잭션 시작 전 상태로 되돌리는 작업

```sql
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B';

-- 오류 발생 시 또는 의도적으로 트랜잭션을 취소할 경우
ROLLBACK;
```

롤백이 발생하는 경우는 다음과 같다.
1. 명시적 ROLLBACK 명령 실행
2. 데이터베이스 시스템 오류 (시스템 크래시 등)
3. 트랜잭션 내 SQL 오류 (제약조건 위반 등)
4. 데드락 발생으로 인한 트랜잭션 중단

롤백 처리는 내부적으로 "undo 로그"를 사용하여 구현된다. 이 로그는 데이터 변경 전의 값을 기록하여 필요 시 원래 상태로 복원할 수 있게 한다.

한 개의 SQL문이라 하더라도 내부에서는 복수의 작업을 수행하므로 반드시 트랜잭션은 존재해야한다.
![](https://i.imgur.com/xnxLqNj.png)
## 3. 무정지성 확보하기

> [!question] 무정지성(High Availability)이란?
> 시스템이 장애 상황에서도 계속 작동할 수 있는 능력.

다음과 같은 방법으로 무정지성을 확보할 수 있다.
1. **클러스터링**: 여러 서버가 하나의 시스템처럼 작동하여 한 서버 장애 시 다른 서버가 자동으로 대체
2. **복제**: 데이터를 여러 서버에 복사하여 장애 발생 시 대체 서버로 전환
3. **로드 밸런싱**: 여러 서버에 작업을 분산하여 단일 서버 장애의 영향 최소화
4. **자동 장애 조치(Automatic Failover)**: 주 서버 장애 감지 시 보조 서버로 자동 전환

무정지성 설계에서는 "단일 장애점(Single Point of Failure)"을 제거하는 것이 중요합니다. 이를 위해 중요 구성 요소(전원, 네트워크, 스토리지 등)의 이중화가 필요하다.
## 4. 트랜잭션 격리 수준(Transaction Isolation Level)

> [!question] 트랜잭션 격리 수준이란? 여러 트랜잭션이 동시에 실행될 때 한 트랜잭션이 다른 트랜잭션에 미치는 영향을 제어하는 수준
#### 4.1. ANSI/ISO SQL 표준에서는 네 가지 격리 수준을 정의한다

1. **READ UNCOMMITTED**
	- 가장 낮은 격리 수준으로, 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경 내용을 읽을 수 있다.
	- "더티 리드(Dirty Read)" 현상 발생 가능
2. **READ COMMITTED**
	 - 커밋된 데이터만 읽을 수 있다. 하지만 한 트랜잭션 내에서 같은 쿼리를 두 번 실행할 때 다른 결과가 나올 수 있다.
	 - "반복 불가능한 읽기(Non-repeatable Read)" 현상 발생 가능
3. **REPEATABLE READ**
	- 트랜잭션 내에서 같은 SELECT 쿼리를 여러 번 실행해도 같은 결과를 보장한다.
	- 하지만 다른 트랜잭션이 새 행을 삽입하면 "팬텀 읽기(Phantom Read)" 현상이 발생할 수 있다.
4. **SERIALIZABLE**
	- 가장 높은 격리 수준이다. 트랜잭션이 완전히 독립적으로 실행되어 모든 동시성 문제를 방지한다.
	- 가장 안전하지만 성능 저하가 크다.

#### 4.2. 각 격리 수준에서 발생 가능한 문제

|격리 수준|더티 리드|반복 불가능한 읽기|팬텀 읽기|
|---|---|---|---|
|READ UNCOMMITTED|가능|가능|가능|
|READ COMMITTED|불가능|가능|가능|
|REPEATABLE READ|불가능|불가능|가능|
|SERIALIZABLE|불가능|불가능|불가능|
- **더티 리드(Dirty Read)**: 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경 데이터를 읽는 현상
- **반복 불가능한 읽기(Non-repeatable Read)**: 한 트랜잭션 내에서 같은 쿼리를 여러 번 실행했을 때 다른 결과가 나오는 현상
- **팬텀 읽기(Phantom Read)**: 한 트랜잭션이 특정 조건의 데이터를 여러 번 읽을 때, 다른 트랜잭션의 삽입이나 삭제로 인해 이전에 없던 행이 나타나거나 있던 행이 사라지는 현상
#### 4.3. 격리 수준 설정 예시(MySQL)

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- 또는 세션 전체 설정
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```
## 5. 락(Lock)과 데드락(Deadlock)

> [!question] 락(Lock)이란? 데이터 일관성과 무결성을 보장하기 위해 데이터베이스의 자원에 대한 동시 접근을 제어하는 메커니즘
#### 5.1. 락의 종류
1. **공유 락(Shared Lock, S Lock)**: 읽기 작업에 사용한다. 여러 트랜잭션이 동시에 공유 락을 획득 가능하다.
2. **배타적 락(Exclusive Lock, X Lock)**: 쓰기 작업에 사용한다. 한 트랜잭션만 획득 가능하며 다른 모든 락과 호환되지 않는다.
3. **의도 락(Intention Lock)**: 계층적 락킹에 사용되며, 하위 수준에서 특정 유형의 락을 획득할 의도를 표시한다.
4. **갱신 락(Update Lock)**: 읽은 후 나중에 수정할 가능성이 있는 데이터에 사용한다.

#### 5.2. 락의 범위
1. **행 수준 락(Row-level Lock)**: 테이블의 특정 행만 잠근다.
2. **페이지 수준 락(Page-level Lock)**: 데이터베이스 페이지 단위로 잠근다.
3. **테이블 수준 락(Table-level Lock)**: 테이블 전체를 잠근다.
4. **데이터베이스 수준 락(Database-level Lock)**: 데이터베이스 전체를 잠근다.

#### 5.3. 비관적 락과 낙관적 락
###### 비관적 락(Pessimistic Locking)
```sql
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
```
- 트랜잭션이 시작될 때 즉시 락을 획득한다.
- 다른 트랜잭션의 접근을 차단하여 충돌을 미연에 방지한다.
- 경쟁이 심한 환경에서 효율적이다.
- 데드락 발생 가능성이 높다.
###### 낙관적 락(Optimistic Locking)
```sql
-- 버전 확인 후 업데이트
UPDATE accounts SET balance = 500, version = version + 1 
WHERE id = 1 AND version = 10;
```
- 실제 락을 사용하지 않고 버전 번호나 타임스탬프를 통해 충돌을 감지한다.
- 읽기 시점에는 락을 획득하지 않고, 수정 시점에 데이터 변경 여부를 확인한다.
- 읽기가 많고 쓰기 충돌이 적은 환경에서 효율적이다.

#### 5.4. 데드락(Deadlock)

> [!warning] 데드락이란? 두 개 이상의 트랜잭션이 서로 상대방이 필요로 하는 자원을 보유한 채 무한정 대기하는 상태
###### 데드락 해결 방법
1. **타임아웃(Timeout)**: 일정 시간 동안 락을 획득하지 못하면 트랜잭션 롤백한다.
2. **데드락 감지(Deadlock Detection)**: 주기적으로 대기 그래프를 분석하여 데드락 발견 시 하나의 트랜잭션을 희생(롤백)한다.
3. **데드락 예방(Deadlock Prevention)**: 트랜잭션이 모든 필요한 락을 한번에 획득하도록 설계한다.
###### 데드락 최소화 방법
1. 트랜잭션을 짧게 유지한다.
2. 일관된 순서로 테이블에 접근한다.
3. 필요한 경우에만 배타적 락을 사용한다.
4. 읽기 전용 트랜잭션에는 격리 수준을 낮게 설정한다.

