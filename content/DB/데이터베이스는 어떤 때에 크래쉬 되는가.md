# 크래쉬란 무엇인가?

크래쉬(crash)는 데이터베이스 시스템이 갑작스럽게 중단되거나 비정상적으로 종료되는 상황을 의미한다.
- 마치 컴퓨터 프로그램이 튕겨나가듯 데이터베이스가 예기치 않게 작동을 멈추는 것
크래쉬가 발생하면..
1. 진행 중이던 작업들이 중단되고, 
2. 메모리에 있는 데이터가 손실될 수 있으며, 
3. 최악의 경우 데이터 파일이 손상될 수 있다.

---
# 대표적인 장애 패턴

> [!bug] 장애 대책
> 먼저 어떤 장애 패턴이 있는지를 정리하여 각각에 대해 적절한 대책을 마련하는 것이 중요하다.

다음과 같은 장애 패턴이 있다.
1. [[#소프트웨어 장애]]
2. [[#OS 장애]]
3. [[#하드웨어 장애]]
4. [[#조작 실수]]
## 소프트웨어 장애

> [!example] **소프트웨어 주변의 결함**으로 인해 서비스를 제공할 수 없는 유형의 장애
> 문제의 심각성에 따라 데이터 자체가 파괴되어 다시 시작하지 않는 등 치명상이 될 수 있다.
#### 소프트웨어 장애의 심각성
소프트웨어 장애는 그 소프트웨어의 품질이 장애 빈도와 심각성에 결정적인 영향을 미친다.
- 오픈소스 / 상용 제품에 관계 없이 실적이 있고 노하우도 갖춘 제품을 사용하는 것이 중요
	- 기능과 성능 뿐 아니라 품질도 중요한 지표
#### 주요 원인
- **버그** : 데이터베이스 소프트웨어 내의 프로그래밍 오류
- **메모리 누수** : 시간이 지남에 따라 점진적으로 메모리가 소모되어 결국 시스템이 불안정해짐
- **교착 상태(Deadlock)** : 두 개 이상의 트랜잭션이 서로 상대방이 점유한 자원을 기다리며 무한정 대기하는 상황
- **버퍼 오버플로우** : 할당된 메모리 영역을 초과하여 데이터가 쓰여질 때 발생
- **인덱스 손상** : 인덱스 구조가 깨져 검색 성능 저하 및 쿼리 오류 발생
#### 영향 범위
- 특정 기능만 작동하지 않는 경우부터 전체 데이터베이스 서비스가 중단되는 경우까지 다양하다.
- 데이터 일관성 훼손으로 이어질 수 있어 매우 위험할 수 있다.
## OS 장애

> [!example] **OS 주변의 장애**로 인하여 서비스를 제공할 수 없게 되는 패턴 Windows의 블루 스크린이나 Linux의 커널 패닉 등이 대표적인 예이다.
#### OS 장애의 특성
OS 장애는 데이터베이스 서버의 기반이 되는 운영체제에 문제가 생겨 발생하는 장애이다.
- 문제 해결에는 OS 및 하드웨어 주변의 고급 기술이 요구되므로 RDBMS와 같은 미들웨어 장애와는 또 다른 어려움이 존재한다.
- 장치 드라이버의 버그가 발생 빈도가 높은 문제이므로 최신 드라이버 업데이트가 중요하다.
- 검증된 기술과 안정적인 OS 버전을 사용하는 것이 중요하다.
#### 주요 원인
- **커널 패닉** : 운영체제 핵심부의 심각한 오류로 시스템이 완전히 멈춤
- **리소스 고갈** : 파일 핸들, 프로세스 테이블 공간, 세마포어 등 OS 리소스가 부족해져 발생
- **드라이버 충돌** : 디스크나 네트워크 장치 드라이버의 오류로 인한 시스템 불안정
- **OS 패치 문제** : 새로운 OS 업데이트가 데이터베이스 소프트웨어와 호환성 문제를 일으킴
- **스케줄링 문제** : CPU 시간 할당 문제로 데이터베이스 프로세스가 적절히 실행되지 못함
#### 영향 범위
- 서버 전체가 다운되어 모든 서비스가 중단될 수 있다.
- 재부팅이 필요한 경우가 많아 서비스 복구 시간이 길어질 수 있다.
- 시스템 로그만 남기고 다운되는 경우가 많아 원인 파악이 어려울 수 있다.
## 하드웨어 장애

> [!example] **물리적 컴포넌트의 문제**로 인한 장애 HDD와 같은 물리적 장치의 수명은 2~3년 정도로 그다지 길지 않아 예방이 어렵다.
#### 하드웨어 장애의 특성
하드웨어 장애는 물리적인 기기의 고장으로 인해 발생하는 장애로, 예측하기 어려운 경우가 많다.
- 서버 내 모든 물리적 컴포넌트는 수명이 제한되어 있으며, 특히 움직이는 부품(HDD)은 더 취약하다.
- 사전 조치를 잘 취해놓았다고 하더라도 하드웨어 장애를 완전히 피하는 것은 불가능하다.
- 정기적인 장비 점검과 교체 계획이 필요하다.
#### 주요 원인
- **디스크 장애** : 하드 디스크나 SSD의 물리적 고장, 섹터 불량으로 데이터 접근 불가
- **메모리 오류** : RAM 모듈 손상, 비트 플립, ECC(Error-Correcting Code) 오류
- **CPU 문제** : 프로세서 과열, 물리적 손상, 성능 저하
- **전원 문제** : 정전, 전압 불안정, 전원 공급 장치 고장, UPS 오작동
- **네트워크 하드웨어 장애** : 네트워크 카드, 케이블, 스위치, 라우터 등의 물리적 장애
#### 영향 범위
- 데이터 손실 위험이 매우 높으며, 특히 디스크 장애는 영구적 데이터 손실로 이어질 수 있다.
- 물리적 부품 교체가 필요한 경우 복구 시간이 길어진다.
- 하드웨어 이중화가 되어 있지 않은 경우 서비스 전체 중단으로 이어진다.
## 조작 실수

> [!example] **인적 오류**로 인한 장애 잘못해서 테이블을 지워버리는 등의 조작 실수는 빈번하게 발생할 수 있는 장애 유형이다.
#### 조작 실수의 특성
조작 실수는 관리자나 개발자의 인적 오류로 인한 장애로, 가장 흔하면서도 예방이 가능한 장애 유형이다.
- 물론 방지할 수 있으면 방지하는 것이 좋지만, 많은 사람들이 데이터베이스를 조작할수록 이런 문제가 일어날 확률이 높아진다.
- 인적 오류는 기술적 문제가 아니라 프로세스와 교육의 문제이므로 다른 접근이 필요하다.
- 백업과 권한 관리가 핵심 대응 전략이다.
#### 주요 원인
- **잘못된 SQL 실행** : WHERE 절 없는 DELETE 문 실행, 대량 데이터 변경 등 부주의한 쿼리 실행
- **구성 파일 오류** : 데이터베이스 설정 파일의 잘못된 수정으로 인한 설정 오류
- **권한 관리 실수** : 필요 이상의 권한 부여로 인한 보안 위험 또는 필요한 권한이 없어 작업 실패
- **백업 없는 변경** : 테이블 구조 변경, 중요 데이터 수정 등을 백업 없이 진행
- **스크립트 오류** : 자동화 스크립트의 로직 오류로 의도치 않은 작업 실행
#### 영향 범위
- 데이터 손실이나 손상이 광범위할 수 있으며, 백업에서 복구해야 하는 상황이 발생한다.
- 사용자에게 직접적인 영향을 주는 경우가 많으며, 비즈니스 연속성을 해칠 수 있다.
- 복구 과정에서 추가적인 실수가 발생할 위험이 있다.

---
#  장애 대응 전략
## 디스크 이중화(RAID)

> [!tldr] RAID(Redundant Array of Independent Disks)란?
> 여러 개의 디스크를 하나의 논리적 단위로 구성하여 데이터 안정성과 성능을 향상시키는 기술
#### RAID 0 (스트라이핑)
- 데이터를 여러 디스크에 분산 저장하여 읽기/쓰기 성능을 향상
- 중복성이 없어 하나의 디스크가 고장나면 전체 데이터 손실
- 데이터베이스 환경에서는 임시 데이터나 로그 저장용으로만 제한적 사용
#### RAID 1 (미러링)
- 동일한 데이터를 두 개 이상의 디스크에 똑같이 기록
- 한 디스크가 고장나도 다른 디스크에서 계속 서비스 가능
- 디스크 용량 효율이 **50%로 낮지만 안정성이 높음**
- 읽기 성능은 향상되나 쓰기 성능은 단일 디스크와 유사
#### RAID 5 (패리티 분산)
- 데이터와 패리티 정보를 모든 디스크에 분산 저장
- 하나의 디스크 장애까지 견딜 수 있음
- **저장 효율이 높고(N-1)/N, 읽기 성능도 우수**
- 쓰기 작업 시 패리티 계산으로 인한 오버헤드 발생
#### RAID 10 (RAID 1+0)
- RAID 1의 미러링과 RAID 0의 스트라이핑을 결합
- 높은 성능과 안정성을 동시에 제공
- 최소 4개의 디스크가 필요하며 50% 용량 효율
- 미션 크리티컬한 데이터베이스에 적합

> [!question] 미션 크리티컬(Mission Critical)이란?
> **"임무 수행에 있어 매우 중요하여 실패가 허용되지 않는"** 시스템이나 서비스를 의미한다. 대표적으로 은행의 핵심 뱅킹 시스템, 결제 시스템, 의료 정보 시스템 등이 있다.
> 
> 미션 크리티컬한 시스템은 다음을 보장해야 한다.
> 1. 고가용성(High Acailability) : 거의 항상 99.9%의 업타입을 가져야 한다
> 2. 내결함성(Fault Tolerance) : 장애가 발생해도 전체 시스템은 계속 작동해야 한다
> 3. 데이터 무결성(Data Integrity) : 어떠한 상황에서도 데이터 손실/손상이 발생해서는 안된다
> 4. 실시간 성능(Real-Time Performance) : 일정한 응답 시간 내에 완료되어야 한다
## 복제(Replication) 방식

> [!tldr] 복제(Replication)이란?
> 데이터베이스의 내용을 여러 서버에 복사하여 가용성, 성능, 데이터 안전성을 높이는 핵심 기술
### 복제 방향성에 따른 분류
#### 1. 단방향 비동기 복제 (Asynchronous Replication)
![](https://i.imgur.com/PfHVVSl.jpeg)
- Primary(주 서버 : Master)의 변경 사항이 Secondary(보조 서버 : Slave)로 시간 차를 두고 전송되는 방식
###### 작동 원리
1. Primary 서버에서 트랜잭션이 커밋
2. 변경 내용이 로그(예: 바이너리 로그)에 기록
3. Primary 서버는 즉시 클라이언트에 트랜잭션 완료를 알림
4. 별도의 비동기 프로세스가 로그 내용을 Secondary 서버로 전송
5. Secondary 서버는 수신한 변경 사항을 자신의 데이터에 적용
###### 장점
- [p] Primary 서버의 성능에 미치는 영향 최소화
- [p] 지리적으로 분산된 환경에서도 효율적으로 작동
- [p] 네트워크 지연이 심하거나 일시적인 연결 문제가 있어도 Primary 서버는 계속 작동
###### 단점
- [c] Primary 서버에 장애가 발생할 경우, 아직 복제되지 않은 트랜잭션은 손실될 수 있음
- [c] 두 서버 간에 데이터 일관성이 일시적으로 깨질 수 있음(eventual consistency).
- [c] 복제 지연이 발생할 경우 Secondary 서버의 데이터가 최신 상태가 아닐 수 있음
###### 언제 사용하면 좋은가?
- 읽기 성능 확장이 중요한 환경
- 일부 데이터 손실이 용인되는 웹 애플리케이션
- 지리적으로 분산된 재해 복구 시스템
#### 2. 단방향 준동기 복제 (Semi-synchronous Replication)
- 비동기와 동기 사이의 중간 지점으로, Primary 서버가 트랜잭션 완료 후 최소 하나의 Secondary 서버의 응답을 일정 시간 기다린다.
###### 작동 원리
1. Primary 서버에서 트랜잭션이 커밋
2. Primary 서버는 변경 내용을 로그에 기록하고 Secondary 서버로 전송
3. Primary 서버는 최소 하나의 Secondary 서버가 로그를 수신했다는 확인을 기다림(적용 완료는 아님).
4. 확인을 받거나 타임아웃이 발생하면 클라이언트에 트랜잭션 완료를 알림
5. 타임아웃 발생 시 비동기 모드로 일시적 전환이 가능
###### 장점
- [p] 비동기 복제보다 데이터 손실 가능성이 낮음
- [p] 동기 복제보다 성능 저하가 적음
- [p] 네트워크 문제 발생 시 비동기 모드로 전환하여 가용성을 유지 가능
###### 단점
- [c] 설정에 따라 시스템 복잡도가 증가
- [c] 비동기와 동기 모드 전환 시 일관성 보장이 어려워질 수 있음
- [c] Secondary 서버의 응답 지연 시 트랜잭션 지연이 발생 가능
###### 언제 사용하면 좋은가?
- 데이터 일관성과 성능 사이의 균형이 필요한 경우
- 일정 수준의 데이터 안전성이 필요하지만 성능도 중요한 시스템
- MySQL의 세미 동기(Semi-synchronous) 복제가 이에 해당한다.
#### 3. 단방향 동기 복제 (Synchronous Replication)
- Primary 서버의 트랜잭션이 Secondary 서버에 완전히 적용된 후에만 완료로 간주하는 방식
###### 작동 원리
1. Primary 서버에서 트랜잭션이 커밋
2. 변경 내용이 로그에 기록되고 Secondary 서버로 전송
3. Secondary 서버가 변경 내용을 자신의 데이터에 적용
4. Secondary 서버가 적용 완료를 Primary 서버에 알림
5. Primary 서버는 이 확인을 받은 후에야 클라이언트에 트랜잭션 완료를 알림
###### 장점
- [p] 데이터 손실 위험이 최소화
- [p] 항상 최신 데이터로 Secondary 서버가 유지
- [p] 장애 발생 시 빠른 전환(failover)이 가능
###### 단점
- [c] Primary 서버의 성능이 크게 저하될 수 있음
- [c] 네트워크 지연에 매우 민감
- [c] Secondary 서버 장애 시 Primary 서버도 트랜잭션을 완료할 수 없어 가용성 문제가 발생
###### 언제 사용하면 좋은가?
- 금융 거래와 같이 데이터 손실이 절대 허용되지 않는 환경
- Primary와 Secondary 서버가 지리적으로 가까운 경우
- 데이터 일관성이 성능보다 중요한 시스템
#### 4. 양방향 복제 (Bidirectional Replication)
![](https://i.imgur.com/BCd6V6C.jpeg)
- 두 서버가 모두 읽기/쓰기 작업을 수행하고 상호 간에 변경 사항을 복제하는 방식
- 기술적으로 구현이 어렵다.
	- 특히 **업데이트가 서로 충돌하면 어떻게 할 것인가**라는 문제가 중요
	- 이를 방지하기 위해 **분산형 배타 제어**의 구조가 필요하다.
- 이에 대해 데이터베이스 제품에 따라서는 **여러 서버에 각각 업데이트를 할 수 있으며, 자동 동기화되는 구조**를 가진 것이 있다.
- 오픈 소스의 경우 [MySQL Cluster](https://www.mysql.com/products/cluster/)라는 제품이 이러한 양방향 복제의 구조를 가지고 있다.
### 데이터베이스 시점 복구
![](https://i.imgur.com/KY5tTZW.jpeg)
- 복제와 같은 실시간 이중화 기술은 인위적 실수에 강하지 않다
    - 마스터에서 지워 버린 테이블은 슬레이브에 즉시 반영되어 슬레이브가 같이 지워져 버리기 때문이다
- 인위적 실수는 일으키지 않는 것이 가장 좋지만, 그래도 발생하는 일이 종종 있으므로 그때를 대비하여 **백업**을 해두어야 한다
    - 백업을 정기적으로 해두면 모든 DB 서버에서 데이터가 손실된 경우라 할지라도 백업 시점으로 복구할 수 있다
- 백업이란 전체 데이터베이스를 복사하는 무거운 작업이므로 대개는 새벽 4시 등 부하가 적은 시간대에 하루에 한 번만 실행하는 방법으로 백업을 수행한다
- [f] 그러나 백업만으로는 백업 시점과 장애 발생 시점 사이에 생성된 데이터는 복구할 수는 없다.
- 이 문제를 해결하기 위해 데이터베이스의 **시점 복구(Point In Time Recovery, PITR)** 기능을 제공한다.
#### 시점 복구 작동 방식
1. **백업 복원**: 먼저 가장 최근의 전체 백업을 복원
2. **로그 적용**: 백업 시점부터 원하는 복구 시점까지의 트랜잭션 로그를 순차적으로 적용
3. **복구 시점 지정**: 특정 시간, 로그 시퀀스 번호, 또는 특정 트랜잭션 ID를 기준으로 복구 시점을 지정 가능

이를 통해 데이터베이스 관리자는 실수가 발생하기 직전의 상태로 정확하게 데이터베이스를 복원할 수 있다.
### 고의로 지연시킨 복제 (Delayed Replication)

> [!todo] 지연 복제란?
> 의도적으로 복제 과정에 시간 지연을 두어 인적 오류나 논리적 손상으로부터 데이터를 보호하는 방식

- Primary 서버에서 수행한 업데이트를 즉시 Secondary 서버에 반영하지 않고, 1시간 등 **어느 정도의 시간이 지난 후에 반영하는 방식**
    - 만약 Primary 서버에서 잘못된 작업을 수행하는 경우는 그 지연되고 있는 Secondary 서버를 Primary로 승격하게 된다
    - 이 작업만 한다면 1시간만큼의 업데이트 결과가 반영되지 않은 상태이므로 원래의 Primary 서버에 있는 업데이트 로그 중에서 문제가 있는 쿼리만을 제거하여 별도로 반영하는 수법을 취할 수 있을 것이다
- [!] 단, 이 방법은 대상 Secondary 서버가 항상 지연된 상태이므로 애플리케이션에서의 참조 쿼리를 돌릴 수 없다는 점에 주의해야 한다

### 복제 형식에 따른 분류
복제 형식은 데이터베이스의 변경 사항을 어떻게 기록하고 전달할지를 결정한다.
#### 문장 기반 복제 (Statement-Based Replication)
- SQL 문장 자체를 그대로 복제하는 방식
###### 장점
- [p] 로그 크기가 작아 네트워크 대역폭을 적게 사용
- [p] SQL 문장만 전송하므로 구현이 상대적으로 간단
- [p] 대량의 행을 변경하는 작업에서 효율적
###### 단점
- [c] NOW(), RAND()와 같은 비결정적 함수를 사용할 경우 문제가 발생할 수 있음
- [c] 트리거, 저장 프로시저 등에서 서버 간 일관성을 보장하기 어려울 수 있음
- [c] 행 수준의 필터링이 어려움
#### 행 기반 복제 (Row-Based Replication)
- 변경된 행의 실제 데이터를 복제하는 방식
###### 장점
- [p] 비결정적 함수나 트리거에 영향을 받지 않음
- [p] 모든 변경 사항이 정확하게 복제됨
- [p] 특정 행만 변경하는 경우 효율적
###### 단점
- [c] 대량의 행이 변경될 경우 로그 크기가 매우 커질 수 있음
- [c] 네트워크 대역폭을 더 많이 사용
- [c] Binary 형태의 로그라 사람이 직접 읽고 분석하기 어려움
#### 혼합 복제 (Mixed Replication)
- 문장 기반과 행 기반 복제를 상황에 따라 자동으로 선택하여 사용하는 방식
###### 장점
- [p] 두 방식의 장점을 모두 활용할 수 있음
- [p] 상황에 따라 최적의 복제 방식을 자동 선택
- [p] 로그 크기와 복제 정확성 사이의 균형을 유지
###### 단점
- [c] 복제 형식 전환 시점을 예측하기 어려울 수 있음
- [c] 설정 및 관리가 더 복잡해질 수 있음
- [c] 디버깅이 어려울 수 있음
### 논리적 복제 (Logical Replication)
- 스키마나 테이블 단위로 선택적 복제가 가능한 고급 복제 방식
###### 장점
- [p] 특정 스키마나 테이블만 선택적으로 복제할 수 있음
- [p] 서로 다른 버전의 데이터베이스 간에도 복제가 가능
- [p] 필터링, 변환, 집계 등의 고급 기능을 지원
###### 단점
- [c] 설정 및 관리가 복잡
- [c] 전체 복제보다 오버헤드가 클 수 있음
- [c] 특정 데이터 유형이나 DDL(Data Definition Language) 명령어에 제한이 있을 수 있음