
## 1. 데이터 모델링 기술의 중요성

**데이터 모델링** : 주어진 개념으로부터 논리적인 데이터 모델을 구성하는 작업
즉, 현실 세계의 데이터를 논리적으로 구조화하고 체계적으로 표현하는 과정

> [!note] 데이터 모델링의 3단계
> 1. 개념적 데이터 모델
> 	**비즈니스 관점에서 데이터와 그 관계를 정의**하는 단계
> 	주로 ERD를 사용하여 엔티티와 관계를 표현함
> 	**주요 요소**:
> 	-  엔티티(Entity): 시스템에서 관리할 대상 (예: 고객, 주문, 상품)
> 	-  속성(Attribute): 엔티티의 특성 (예: 고객 이름, 주문 날짜)
> 	-  관계(Relationship): 엔티티 간의 연관성 (예: "고객은 주문을 한다")
> 		  
> 1. 논리적 데이터모델
>    개념적 모델을 데이터베이스의 논리적인 구조로 변환하는 단계
>    정규화를 수행하여 데이터 중복을 제거하고 일관성 유지
>    주로 데이터 타입, 제약 조건, 정규화 수행
>    **주요 요소**:
> 	   - 테이블(Table) 설계
> 	   - 키(Key) 정의 (Primary Key, Foreign Key)
> 	   - 정규화 수행 (1NF, 2NF, 3NF 등)
>1. 물리적 데이터모델
>   논리적 모델을 실제 데이터베이스에 구현하는 단계
>   DBMS에 맞는 테이블, 인덱스, 파티셔닝, 성능 최적화 요소를 반영
>   **주요 요소**:
>	- 데이터 타입 선정 (VARCHAR, INT 등) 
>	- 인덱스(Index) 설정
>	- 파티셔닝(Partitioning) 및 샤딩(Sharding) 전략
>	- 저장소 엔진(MySQL InnoDB, PostgreSQL, Oracle 등) 결정


- 애플리케이션을 만들 때 중요한 것 : "어떤 데이터 항목이 필요한가?"를 제대로 파악하는 것
	- 애플리케이션 가동 후에 항목(=열) 추가하는 것은 쉽지 않다
- 기능 추가가 자주 발생하는 애플리케이션에서 데이터 항목을 미리 밝혀내는 것은 불가능
	- 데이터 항목을 추가하기 용이한 디자인도 중요

## 2. 예제를 사용하여 생각해보기

### 직원과 소속조직/부서를 취급하는 애플리케이션
-> 필요한 데이터 항목을 파악하여 적절하게 테이블 설계에 도입하는 과정

예제의 요구사항

> - 직원은 고유의 사원 번호를 가진다.
> - 같은 이름의 사원이 있는 경우가 있다.
> - 이름의 한자가 다르다 해도 발음이 같은 직원이 있는 경우가 있다. (참고로 원저자가 일본인이다)
> - 직원은 메일 주소가 부여된다. 메일 주소는 중복되지 않는다.
> - 경력 사원 등 수속 절차에 따라 메일 주소의 부여가 지연될 수 있으며, 이 경우는 당분간 메일 주소가 없는 상태가 된다.
> - 직원은 최소한 하나 이상의 부서에 소속된다.
> - 부서 이름은 중복될 수 있다.
> - 부서 전화번호가 가지각색이므로 이것도 관리하고 싶다.

-> 이러한 요구사항에 필요한 데이터 항목을 나열하고 설계에 도입해 나가는 작업 : **데이터 모델링**

#### 테이블 만들기

![](https://i.imgur.com/XILFdON.png)

- 행과 열로 구성됨
- 행 : 직원 
- 열 : 관리해야 할 각 항목들


테이블 설계에선 **행을 고유하게 식별하기 위한 식별자**를 도입하는 것이 일반적
: 우리가 흔히 아는 **기본 키** (Primary Key)

![](https://i.imgur.com/7p1hlmW.png)

3-1 그림처럼 테이블을 설계한 후, 3-2처럼 데이터가 쌓이면 중복값에 대한 문제가 발생하는 것을 확인 할 수 있음
- dept_name (부서 이름)이 겹치는 것 확인 가능
동일한 문자열을 다시 입력해야 할 수도 있고, 입력 실수가 발생하더라도 확인하기 어려움


현재 부서명과 부서 전화번호가 반복적으로 저장되고 있는데

예시) 만약 **부서 전화번호**가 변경될 경우, 모든 (행) row 일일이 수정해야 함
-  예를 들어, 인사부의 전화번호가 `03-1234-5678`에서 `03-9876-5432`로 변경되면 `dept_name = '인사부'`인 모든 레코드에서 `dept_tel`을 변경해야 함
    - 하지만 만약 실수로 몇 개의 레코드만 변경된다면, **데이터 불일치(일관성 문제)** 가 발생할 수 있음
- 이렇게 중복된 부서 번호 데이터를 모두 찾아 수정하게 되면 UPDATE 쿼리의 부하 또한 증가


##### 그럼 어떻게 해결?

## 3. 포인트 1: 테이블 관계를 도입

![](https://i.imgur.com/quDQ48L.png)

그림 3-3은 부서를 관리하는 테이블 (dept 테이블)
- dept 테이블에서 부서이름 (dept_name)은 키가 되고, 부서 번호가 고유의 값으로 결정됨
- 여러 직원이 같은 부서에 소속되어 있어도 부서 이름이나 부서 전화번호를 중복해서 등록하지 않아도 ok

-> But 비즈니스적으로 조직 이름이 바뀌는 일이 자주 있으므로 **변경되지 않는 ID**를 도입하고 그것을 기본키로 하는 것이 좋음

![](https://i.imgur.com/Jnk4gXr.jpeg)

dept_id가 변경되지 않는 ID로 바뀜 100, 101 이런 식으로


![](https://i.imgur.com/Z9Xupp3.png)

#### 참고 무결성 제약 

직원이 소속된 부서 코드가 잘못되지 않았다는 것을 어떻게 보장할 수 있을까?
- 예컨대 부서 코드에 100을 입력해야 하는데 실수로 1000을 입력

이런 자그마한 어느 정도의 실수는 db의 표준 기능인
*참조 무결성 제약 (Referential Integrity)* 에 의해 감지할 수 있음

> [!important]
> **개체 무결성 제약** : 기본 키에 속해있는 속성은 `Null` 값을 가질 수 없다
> **참조 무결성 제약** : 외래 키 값은 `Null`이거나 참조된 릴레이션의 기본키 값과 동일해야 한다

- 개체 무결성 제약은 모든 테이블(relation 릴레이션)은 각 행을 유일하게 식별할 수 있도록 기본 키 PK를 가져야 함
	- 기본 키는 데이터를 식별하는 유일한 값이어야 하므로, Null을 허용하면 X

- 참조 무결성 제약은 외래 키는 `Null`이거나, 참조된 테이블의 기본 키 값과 동일해야 함
	- 외래키는 다른 테이블의 기본키를 참조해야함
	- 즉, 외래키에 저장된 값은 반드시 **참조하는 테이블의 기본키에 존재해야 함**
	- 특정한 경우에는 Null을 허용할 수도 있음
> 왜 참조 무결성이 필요할까?
	- 참조 무결성이 없으면 존재하지 않는 데이터를 참조할 가능성 있음

참조 무결성 제약이 적용되면 emp 테이블에 부서 번호를 입력할 때 그 값이 dept 테이블에 있는지에 대한 여부를 자동으로 체크해줌 -> 즉, **데이터의 무결성**(데이터가 오류 없이 정확하고 일관된 상태를 유지하는 것)을 자동으로 관리해줌

##### 참조 무결성 제약이 모든 경우를 해결할 수 없는 이유

> "테이블이 다른 서버에 분리되어 있으면 존재 체크가 불가능하므로 참조 무결성 제약을 적용할 수 없다."  
>
> ✔ 참조 무결성 제약(FK)는 같은 데이터베이스(DB) 내에서만 적용 가능  
> ✔ 다른 서버에 있는 테이블을 직접 참조(FK)할 수 없음

-> 체크 처리의 기본은 특정 식별자가 관련 테이블에 존재하는지에 대한 여부를 확인 하는 것
참조 처리는 매우 고속으로 끝나야하므로 대상 열에는 인덱스가 사실상 필수


## 4. 포인트 2: 테이블 설계의 타당성 검증하기

![](https://i.imgur.com/0PexTkT.jpeg)

이렇게 emp 테이블과 dept 테이블이 분리되어있어도 
"사원이 두 개 이상의 부서에 속할 수 있다 = 겸임을 맡을 수 있다" 라는 요구사항이 있을 때 
현재 테이블 구조로선 대응하기 힘듦

어떻게 변경? 
### 연속적인 번호의 열 도입하기

![](https://i.imgur.com/g7ycWDj.jpeg)

dept_id1, dept_id2, dept_id3 이런 식으로 부서에 대한 열을 여러 개 준비하는 접근 방식

열 수가 끊임없이 증가해 나갈 경우 어떻게 해? -> 권장 X
열 값이 없더라도 Null 값을 가지고 있어, 물리적인 공간도 소비하고 있음

![](https://i.imgur.com/Otw28tl.png)

그렇다고 하나의 열에 여러 부서의 정보를 등록하는 것은??
dept_id 정수형 이므로 이를 하나의 열에 담기 위해선 SET형이라는 집합형을 도입해야 함
SET 지원하지 않는 데이터베이스도 있고, SET형이 인덱스 즉 검색 조건으로 사용하기 어려우므로 도입하기 어려움

### 1:N 관계를 두 개 도입하기

![](https://i.imgur.com/oyIBnSH.jpeg)

겸임 정보 -> 직원 ID와 부서 ID가 정해지면 고유의 의미를 갖게됨
두 열을 기본키로 가진 테이블을 도입할 수 있음 = **매핑 테이블**
(즉, 다대다 관계로 변환)
이렇게 하면 직원 한 명이 여러 부서에 소속될 수 있음
- 매핑 테이블은 데이터 모델링 과정에서 자주 나옴
- 수십 개에 걸친 테이블을 매핑하는 경우도 있음

매핑 테이블의 특징
기본 키 값이 자주 바뀜
- 매핑테이블은 전근 등이 발생했을 때 기본 키 값이 변경됨
- 또는 기존의 열을 지우고 새로운 열을 등록하는 대신 겸임 시작일/종료일 등의 열을 추가하여 기본 키를 변경하지 않는 형태, 즉 **항상 추가로 기록해 나가는 형태**를 취하는 경우도 많음

레코드 수가 많음
- 매핑 테이블의 레코드 수는 매핑의 소스가 되는 두 개(혹은 그 이상)의 테이블보다 많음 -> 데이터의 양이 빠르게 증가
- 한 개의 서버로 데이터를 수용할 수 없을 때는 **테이블을 분할**하여 복수의 데이터베이스 서버에서 데이터를 갖고 있도록 하는 접근 방식이 사용될 수도 있음


## 5. 정규화 이론의 기본을 파악해 두자

위의 예제는 데이터베이스 이론의 **정규화**에 해당

### 제1정규형

테이블 구성에서 중복 또는 반복, 복합값 등을 포함한 구조를 제1정규형이 아닌 테이블
각 열이 오직 원자적 값만을 가져야 한다는 원칙
*한 열에 여러 개의 값을 저장해서는 안 되고 모든 속성은 더 이상 쪼갤 수 없는 원자값*

![](https://i.imgur.com/JEqbw3I.png)
- 부서 이름 중복 (일관성 깨짐)

![](https://i.imgur.com/wGYEbCV.jpeg)
- 열의 중복

![](https://i.imgur.com/1EyV6qT.png)
- 부서 ID 복합값 (집합형을 취급해야됨)

### 제2정규형

기본 키가 여러 열로 구성되어 있고 그 중 일부 열의 값에 의해서만 결정되는 열이 있는 경우, 해당 테이블은 제2정규형이 아닌 테이블
제1정규형을 만족하면서, 기본 키의 일부만을 참조하는 속성이 존재하지 않도록 하는 것
*기본 키 전체에 대해 완전 함수 종속을 가져야 함*

![](https://i.imgur.com/HUn4cUz.png)

등록일은 직원 ID, 부서 ID 두 가지 사항을 모르면 특정할 수 없지만, 부서 이름은 부서 ID만 정해지면 확인할 수 있으므로 이 테이블에 속하는 것이 적절하지 않음
- 즉, 동일 부서 ID인데 부서명이 서로 다른 레코드가 등록될 가능성이 있다는(충돌하는) 것

✔ **기본 키(Primary Key) = (`emp_id`, `dept_id`)**  
✔ **`dept_name` 속성은 `dept_id`만으로 결정됨**
✔ 즉, `dept_name`은 기본 키 전체 (`emp_id`, `dept_id`)에 종속된 것이 아니라, **기본 키의 일부(`dept_id`)에만 종속됨**
✔ **따라서 부분 함수 종속이 발생하며, 제2정규형(2NF)을 위반하고 있음.**

어떤 x가 y를 정확하게 식별된다는 얘기
부분 함수 종속 -> 내부 하나의 값으로 다른 값이 결정이 된다면? 이걸 그냥 따로 빼는 게 좋지 않나

x에 2가 들어가면 y는 3이 튀어나와야돼 라는 함수 관계를 만족할 때
식별자가 하나가 존재할 때 학생번호가 있을 때 학생번호로 학생 이름이 식별됨 -> 함수적 종속성 
학생 이름을 넣으면 학번이 튀어나오냐?? ㄴㄴ 동명이인이 있을 수 있음 -> 함수적 종속성이 X

완전 함수 종속성
집합 중에서 단일값 하나에 의해서만 결정된다면 부분적 함수 종속성 -> 왜 문제?
새로운 부서번호가 생겼음 개발부서 -> 이거에 대한 id 새로 줌
개발부 101번 모든 사원들한테 다 고쳐줘야함
무결성 깨짐
부서 번호와 부서 이름을 따로 빼서 관리를 함

### 제3정규형

원칙적으로 테이블의 모든 열은 기본 키 값에 따라 하나로 결정되어야 함
- 반대로 기본 키의 열 값이 기본 키가 아닌 열에 의해 결정되는 상태도 문제가 될 수 있으므로 제거 필요
- 레코드 간의 일관성이 없는 상태가 되는 등의 문제 발생

제2정규형을 만족한 상태에서, 기본 키가 아닌 컬럼이 다른 일반 컬럼에 종속되지 않아야함
*모든 속성은 반드시 기본 키에만 종속되어야 하며, 다른 일반 컬럼을 통해 결정되면 안 됨*

![](https://i.imgur.com/sKhXJdQ.png)

부서 번호의 경우 기본 키가 아닌데 부서 이름은 부서 번호에 따라 결정됨
PK인 직원 ID와는 직접 관련이 없음
-> 같은 부서 번호임에도 불구하고 다른 부서 이름을 등록할 수 있다는 점에서 문제가 됨

**이행적 함수 종속**이 발생한다고 함
이행적 함수 종속 : chaining A가 B를 결정 B C를 결정 A가 C도 결정
연결고리가 chaining 되어있으면 문제가 생길 수 있음
chaining을 쪼개기

![](https://i.imgur.com/Dy0GHNd.png)

dept_name이 dept_id에만 종속되도록 테이블 하나 빼주기


### BCNF (Boyce-codd Normal Form)

BCNF는 3차 정규화를 조금 더 강화한 버전
이는 3차 정규화에서 해결할 수 없는 이상현상을 해결할 수 있음

BCNF란 **3차 정규화를 만족하면서 모든 결정자가 후보키 집합에 속한 정규형**
모든 결정자는 후보키여야 한다 !!

- **결정자(Determinant)**: 다른 속성을 유일하게 결정하는 속성(또는 속성들의 집합)
- **후보키(Candidate Key)**: 테이블의 모든 행을 유일하게 식별할 수 있는 속성(또는 속성들의 집합)

##### 학생강의 테이블
--------------
학생ID (기본키 일부)
과목코드 (기본키 일부)
교수번호
강의실

- (학생ID, 과목코드)가 기본키
- 하나의 과목은 한 명의 교수만 가르침
- 교수는 한 강의실에서만 강의함

여기서 "과목코드 → 교수번호"라는 함수적 종속성이 있고, 
"교수번호 → 강의실"이라는 함수적 종속성도 있음

문제점 : 교수번호가 결정자이지만 후보키가 아님
이것이 BCNF 위반



##### 과목교수 테이블
-------------
과목코드 (기본키)
교수번호

##### 교수강의실 테이블
--------------
교수번호 (기본키)
강의실

##### 학생수강 테이블
------------
학생ID (기본키 일부)
과목코드 (기본키 일부)


이렇게 분리하면 모든 결정자가 후보키가 되어 BCNF 만족함

어떤 이상 현상이 일어날 수 있는가?  **왜** 터지는가?
어떤 케이스에서 어떤 게 일어날 수 있는가?
삽입 이상 
갱신 이상
삭제 이상
데이터 중복

### 정규형은 어디까지 이해해야 하는가?

과연 정말 제3정규형이면 충분할까?
현업 데이터베이스 설계에서는 **다양한 조합의 결함에 주의하여 테이블 간의 관계**를 밝혀내야함


Join이 점점 많아져서 뭐 하나 조회하는데 성능이 저하됨
삽입 삭제 갱신이상을 해결 
조회하는거에 대해서 너무 성능적으로 문제가 되면 좋지 X

어느쪽에 초점을 두는지에 따라서 달라짐 !!!!!
- 이 릴레이션이 삽입이나 삭제같은 빈번한 데이터의 변경이 있을거 같아 **무결성** 보장해야돼 -> 정규화 빡세게 잡기
- **Read**가 젤 중요해 -> 정규화 하지 말거나 반정규화/비정규화 하기


그래서 정규화가 왜 필요한데? 언제 정규화를 하면 안되는데? -> 잘 정리해두기
BE의 입장에서도 잘 알아야함