
1장은 데이터 베이스가 필요한 이유에 대해서 설명을 하고있고 
2장은 B+Tree Index 에 대해서 설명하고, RDBMS 에서는 어떻게 최적화를 실현하고 있는가 등을 설명하고 있습니다.  
## 데이터 베이스가 없으면 뭐가 불편할 것인가? 

1. 대량의 데이터 중에서 필요한 것을 빨리 반환할 수 없다. 
	 -> : 필요한 데이터를 빠르게 찾기 어렵고
	 
	 - 그래서 데이터베이스는 **B+Tree 인덱스**, 해시 인덱스와 같은 구조를 통해 빠른 검색을 지원합니다. 
	 -  **B+Tree 인덱스**는 마치 도서관의 색인(일정한 순서로 나열한 목록) 처럼, 필요한 정보를 빠르게 찾을 수 있도록 도와줘.
	- 검색 엔진이 수십억 개의 웹페이지에서 몇 초 만에 결과를 보여줄 수 있는 이유도 이런 인덱스 덕분이야!

2. 대량의 데이터를 메모리 내에서만으로는 취급할 수 없다. 
	-> 메모리는 휘발성이므로 메모리에만 저장하면 데이터가 날아갈 위험이 있음.
	
	예를 들어 은행 시스템에서 고객 계좌 정보를 메모리에만 저장하고 있다면…  
	 정전이 나거나 서버가 꺼지는 순간 **모든 정보가 사라진다**! 

	데이터베이스는 이런 문제를 방지하기 위해 **디스크(HDD, SSD)에 데이터를 저장**해.
	
	데이터베이스는 기본적으로 디스크를 활용한 데이터 구조를 전제하고 있다

	---
	최신 기술로 메모리 기반 데이터베이스도 있지만, 기본적으로 데이터는 디스크에 안전하게 보관돼.

	### > 메모리 기반 데이터베이스  Redis, Memcached(멤캐시드),  H2 Database, Apache Ignite (아파치 이그나이트), SAP HANA (SAP 하나), VoltDB (볼트DB)
	
	### **1) 속도가 빠르다** 

	- 디스크는 데이터를 읽고 쓰는 데 시간이 걸려. (특히 HDD는 더 느림)
	- 반면, RAM은 **훨씬 빠르게 데이터를 처리**할 수 있어.

	### **2) 데이터가 휘발성이다** 
	
	- RAM은 전원이 꺼지면 저장된 데이터가 **사라지는(휘발성)** 특징이 있어.
	- 만약 전원이 꺼지면? → **데이터가 다 날아감** 
	- 그래서 메모리 기반 DB는 보통 **데이터를 주기적으로 디스크에 백업(스냅샷 저장)하거나 복제(replication)해서 대비**해.

	### **3) 트랜잭션 기능을 제공할 수도 있다**
	
	- 일반적인 DB처럼 **ACID(원자성, 일관성, 고립성, 지속성) 지원하는 것도 있음!**
	- 예를 들어, **Redis는 단순 캐시처럼 쓰이지만, 트랜잭션도 지원**해.


		>[!note] 추가적인 메모리 DB
		
	### **1️ Redis (레디스) **
	
	- 가장 많이 쓰이는 In-Memory DB 중 하나
	- **Key-Value 저장 방식**을 사용하며, **캐시, 세션 저장, 실시간 데이터 처리** 등에 최적화
	- 데이터를 휘발되지 않게 하려면 **스냅샷(RDB) 저장, AOF 로그 방식**을 사용 가능
	- **트랜잭션 지원, Pub/Sub 기능, Lua 스크립트 실행 가능**
	
	** 속도 빠름**  
	 **데이터 지속성 가능 (AOF, RDB 옵션 제공)**  
	 **분산 시스템 지원 (Sentinel, Cluster 모드 제공)**
	
	---
	
	### **2️ Memcached (멤캐시드) **
	
	- **가장 가벼운 메모리 기반 캐시 DB**
	- **Redis보다 구조가 단순하고, 캐싱 목적**으로 주로 사용됨
	- **디스크 저장 기능 없음** → 데이터를 휘발성으로 사용

	 **초고속 캐싱**  
	 **구조가 단순해서 빠르고 가벼움**  
	 **데이터 지속성 없음 (전원이 꺼지면 데이터 날아감)**

	---

	**3️ H2 Database **
	
	- **Java 애플리케이션에서 많이 쓰이는 내장형 메모리 DB**
	- **테스트용으로 주로 사용**
	- 필요하면 디스크 기반으로도 동작 가능
	
	 **빠른 속도 & 가벼운 크기**  
	 **테스트 환경에서 사용하기 좋음**  
	 **대용량 데이터 처리에는 적합하지 않음**
	
	---
	
	### **4️ Apache Ignite (아파치 이그나이트) **
	
	- **분산 환경에서 빠른 데이터 처리를 위한 메모리 DB**
	- **SQL 지원, ACID 트랜잭션 제공**
	- **인메모리 캐싱, 스트리밍, 머신러닝 기능 제공**
	
	 **분산 시스템 지원 (수천 개의 노드에서도 작동 가능)**  
	 **SQL 및 트랜잭션 지원**  
	 **고성능 분석 및 스트리밍 가능**
	
	---
	
	### **5️ SAP HANA (SAP 하나) **
	
	- **기업용 인메모리 데이터베이스**
	- **대용량 데이터 분석 & 트랜잭션 처리 가능**
	- **빅데이터, AI 분석, 금융 시스템에서 많이 사용**
	
	 **ACID 트랜잭션 지원**  
	 **빅데이터 분석 최적화**  
	 **SQL 및 NoSQL 지원**
	
	---
	
	### **6️ VoltDB (볼트DB) **
	
	- **고성능 트랜잭션을 위한 인메모리 데이터베이스**
	- **일관성과 신뢰성이 필요한 금융, IoT, 광고 시스템에서 사용**
	- **ACID 트랜잭션 지원 & 초고속 SQL 처리 가능**
	
	 **밀리초 수준의 빠른 트랜잭션 처리**  
	 **데이터 복제 및 분산 처리 가능**  
	 **SQL 지원**
--- 

3. 장애가 발생했을 때 빠른 복구가 어렵다.
	-> 장애 발생 시 복구도 쉽지 않고
	
	### **3) 장애 발생 시 빠른 복구가 어렵다 (내장애성 문제 )**
	
	백업 파일을 만들면 데이터를 보관할 순 있지만, 백업만으로 해결되지 않는 문제들이 있어.
	
	1. **백업 후 변경된 데이터는 복구 불가**
	    - 백업한 이후에 추가된 데이터는? → **다 날아간다**.
	2. **백업 파일을 복원하는 데 시간이 걸림**
	    - 백업 복구 중에는 시스템이 멈출 수도 있어.
	3. **백업 중 업데이트하면 백업 파일이 망가질 수도 있음**
	
	데이터베이스는 이런 문제를 해결하기 위해 **트랜잭션(Transaction)**을 사용해!
	
	- 트랜잭션은 "작업 묶음" 같은 개념이야.
	- 작업이 **완전히 끝나지 않으면(실패하면) 아예 적용되지 않도록** 해서 데이터가 꼬이지 않도록 해.
	- 만약 시스템이 **중간에 고장 나도 자동으로 복구**하는 기능이 있어.
	
	예를 들어, 은행에서 돈을 송금하는 중에 서버가 다운됐다면?  
	→ 데이터베이스는 **"돈이 빠져나갔지만 도착하지 않았다"** 같은 오류를 막아줘!

4) 병렬성 제어가 어렵다
	->여러 명이 동시에 데이터를 수정하면 충돌이 생긴다
	
	### **4) 여러 명이 동시에 데이터를 수정하면 충돌이 생긴다 (병렬성 문제 )**
	
	예를 들어, 쇼핑몰에서 **한정판 신발을 100개 판다**고 하자.
	
	- A, B, C 세 사람이 동시에 구매 버튼을 눌렀는데,
	- 시스템이 **동시에 처리하다 보니** 실제 재고는 **100개인데 102개가 팔림** 

	이걸 해결하려면 **"잠금(Lock)"** 같은 기술이 필요해.
	
	- 데이터베이스는 **배타적 제어(동시에 여러 사람이 같은 데이터를 수정하지 못하게 막음)**를 지원해서 이런 문제를 방지해.

5. 데이터 무결성을 보장하는 것은 어렵다.
	-> 데이터 자체의 일관성을 유지하기도 어렵다
	
	데이터의 일관성이 깨지지 않도록 지켜주는 규칙이 **무결성(Integrity)**이야.
	
	 **1. 개체 무결성(Entity Integrity)**
	
	- 기본 키(Primary Key)는 **항상 값이 있어야 해(null이면 안 됨)**
	- 예: 학생 데이터에서 `학번`이 기본 키라면, **어떤 학생도 학번이 없을 수 없음!**
	
	 **2. 참조 무결성(Referential Integrity)**
	
	- 외래 키(Foreign Key)는 **다른 테이블의 기본 키 값과 같아야 해**
	- 예: 수강신청 테이블에서 `학생 ID`가 있다면, **실제 존재하는 학생 ID만 저장 가능!**
	- 존재하지 않는 학생 ID를 추가할 수 없도록 제한해야 해.
	
	데이터베이스는 이런 무결성 규칙을 **자동으로 강제**해서 데이터가 꼬이지 않도록 도와줘!

**그래서 우리는 데이터베이스(DBMS)를 사용한다!**



### ** 로그 데이터 저장 방식**

1. **데이터베이스(DB) 저장**
    
    - 여러 사람이 공유하고 관리할 때 사용
    - 쿼리로 검색이 용이
    - 관계형 데이터베이스(RDBMS) 또는 NoSQL 사용
2. **파일 시스템(Filesystem) 저장**
    
    - 단독 사용 시 DB가 필요하지 않을 수도 있음
    - 대량 데이터 처리에 유리 (정적 저장소로 활용)
    - 성능 최적화 가능 (예: 로그 파일, CSV, JSON, XML)

---

###  데이터베이스 종류 및 특징**

#### **1. SQLite (SQL Lite)**

- 파일 기반의 로컬 데이터베이스
- 안드로이드, IoT 기기에서 많이 사용됨
- 가볍고 설치가 필요 없음
- 트랜잭션 지원

#### **2. InfluxDB**

- **시계열(Time-series) 데이터**에 특화된 NoSQL DB
- **IoT, 모니터링, 로그 데이터 저장** 등에 적합
- 시간 기반 데이터 저장 및 분석 최적화

#### **3. MongoDB**

- **NoSQL 기반 문서(Document)형 데이터베이스**
- JSON과 유사한 **BSON(Binary JSON) 포맷** 사용
- **스키마 유연성** → 구조를 자주 변경하는 데이터에 적합
- **수평 확장(Sharding) 가능** → 대량 데이터 처리에 강점

---

### ** ORM (객체지향 + 데이터베이스)**

- **ORM (Object-Relational Mapping)**
    - 객체지향 프로그래밍과 관계형 DB를 연결하는 기술
    - **예제: JPA, Hibernate, MyBatis**
    - **장점**  
         객체 모델을 사용해 코드 가독성이 높아짐  
         SQL 문을 직접 작성하지 않아도 됨 (자동 SQL 생성)  
         유지보수가 용이

---

### ** RDBMS (관계형 데이터베이스)**

- 데이터를 **테이블 형식**으로 저장
- **스키마(구조) 고정** → 데이터 무결성 보장
- 대표적인 DBMS: **MySQL, PostgreSQL, Oracle, MS SQL**
- 사람들이 데이터를 쉽게 이해하고 관리 가능



## ERD 

1. 개념적 설계 (Conceptual Design)

	**주요 작업:**
	
	- **E-R 다이어그램(Entity-Relationship Diagram, ERD) 작성**
	    - 엔터티(Entity) 식별 (예: `사용자`, `영화`, `리뷰`)
	    - 엔터티 간 관계 정의 (예: `사용자`는 `리뷰`를 작성함)
	    - 주요 속성(Attribute) 정의 (예: `사용자`의 `이름`, `이메일`)
	- **비즈니스 규칙 반영** (예: 하나의 사용자는 여러 개의 리뷰를 작성할 수 있음)

2.  논리적 설계 (Logical Design)

	**주요 작업:**

	- **정규화(Normalization) 수행**
	    - 데이터 중복을 최소화하고 무결성을 유지하기 위해 1NF, 2NF, 3NF 등의 정규화 적용
	- **ERD 작성**
	    - 실제 데이터베이스에서 사용할 관계형 테이블 설계
	    - 엔티티를 테이블로 변환 (예: `User` → `users` 테이블)
	    - 속성을 컬럼으로 정의 (예: `email`, `password` 컬럼 추가)
	    - 관계를 외래키(Foreign Key)로 설정
	- **제약조건(Constraints) 정의**
	    - 기본 키(Primary Key, PK), 외래 키(Foreign Key, FK) 설정
	    - NOT NULL, UNIQUE, CHECK 등의 무결성 제약 조건 설정

3. 물리적 설계 (Physical Design)

	**주요 작업:**
	
	- **DBMS 선택** (예: MySQL, PostgreSQL, MongoDB 등)
	- **테이블 및 컬럼의 데이터 타입 정의**
	    - `VARCHAR(255)`, `INT`, `BIGINT`, `DECIMAL(5,2)`, `TIMESTAMP` 등
	- **인덱스(Index) 설정**
	    - 조회 성능 향상을 위한 인덱스 생성 (예: `CREATE INDEX idx_user_email ON users(email);`)
	- **테이블 스키마 생성 및 적용**
	    - SQL을 이용한 테이블 생성 (예: `CREATE TABLE users (...)`)
	- **파티셔닝(Partitioning) 및 샤딩(Sharding) 고려**
	    - 대용량 데이터를 효율적으로 관리하기 위한 데이터 분할 전략 적용

---
# 2장

## **1️. 선형 탐색(Linear Search)의 문제점** (Full table sacn)

 데이터를 처음부터 끝까지 하나씩 확인하는 방식.  
 선형 복잡도 **O(N)** → 데이터가 많아질수록 시간이 **비례적으로 증가**함.  
 **비효율적**이므로 대량의 데이터를 검색하는 데 적합하지 않음.

 **예시:**  
 10개의 데이터가 있을 때, 최악의 경우 10번 확인해야 함.  
 1억 개의 데이터라면? **최악의 경우 1억 번 확인해야 함!** 

---

## **2️. 원하는 데이터에 빠르게 접근하는 방법**

### ** (1) 배열을 이용한 위치 계산**

 **데이터를 고정 크기로 저장**하면 위치를 계산할 수 있음.  
 **[PK(기본 키) X 행 크기]** 를 이용해 특정 데이터를 빠르게 찾을 수 있음.

 **하지만 문제점이 있음!**  
 모든 데이터가 **고정 크기**일 거란 보장이 없음.  
 새로운 속성을 추가할 때 **확장하기 어려움**.  
 **공간 낭비**가 심할 수 있음.

 **그래서 등장한 해결책이 바로 "인덱스"**

---

## **3️. 인덱스(Index) 구조 도입하기**

 책의 **색인(키워드 - 페이지 번호)**처럼 **"키 - 데이터 위치"**를 저장함.  
 데이터의 실제 내용과 **독립적으로 관리됨**.  
 검색 속도를 **대폭 향상**시킬 수 있음! 

 **인덱스 방식의 장점**  
[키 값, 바이트 위치]를 저장 → 빠르게 원하는 데이터를 찾을 수 있음.  
 **고정 크기 포맷** 사용 가능 → 저장 효율이 좋음.  
 새로운 속성이 추가되어도 **인덱스 크기가 무한정 커지지 않음**.

 **단점**  
 데이터를 수정할 때 **인덱스도 함께 업데이트해야 함** → 업데이트 비용 증가.  
 인덱스 접근 후 **데이터를 한 번 더 읽어야 함(2단계 접근 필요)**.

---

## **4️. 해시 인덱스 (Hash Index)**

 **키 값 → 해시 함수**를 거쳐 **해시 값 & 데이터 위치를 저장**.  
 해시 함수 덕분에 검색 속도가 **상수 시간(O(1))**으로 매우 빠름.  
 데이터량이 증가해도 평균 처리 시간이 **서서히 증가**하는 정도임.

 **단점 (B+Tree 인덱스가 필요한 경우)**  
 **범위 검색**이 어려움 → 해시는 특정 값을 바로 찾는 데 최적화됨.  
 **정렬이 불가능** → 해시 값이 순서를 보장하지 않음.  
 **해시 충돌 가능성** → 같은 해시 값이 나오면 처리가 복잡해질 수 있음.

 **이런 경우에는 B+Tree 인덱스를 사용해야 함.**


## 5. B+Tree

B+Tree는 **3가지 노드**로 구성돼 있어.

 **① 루트 노드(Root Node)**

- 트리의 시작점 (최상위 노드)
- 검색 시 가장 먼저 탐색됨

 **② 브랜치 노드(Branch Node)**

- 중간 단계 역할
- **어떤 방향으로 내려가야 할지 결정하는 역할**

 **③ 리프 노드(Leaf Node)**

- **실제 데이터를 저장하는 노드**
- **모든 리프 노드는 서로 연결 리스트로 연결되어 있음** → 범위 검색에 유리함 

### **검색 과정 예시**

1. **루트 노드**에서 키 값 확인 후 적절한 **브랜치 노드**로 이동
2. **브랜치 노드**에서 다시 키 값을 비교하며 탐색 진행
3. 마지막 **리프 노드**에서 데이터를 찾아서 반환
---

레코드의 양에 따라 트리의 구성은 달라질 수 있다

- 레코드 수가 적으면 루트가 브랜치를 겸하며, 루트와 리프밖에 없는 패턴도 존재한다
- 레코드 수가 매우 많은 경우엔 브랜치 아래에 브랜치가 들어가는 4계층 이상의 구성이 될 수도 있다
- 레코드 수가 많아질 수록 브랜치 층도 늘어나고 계층도 늘어나게 될 것이다
---

## **6. B+Tree vs. B-Tree 차이점**

- BTree 인덱스는 여러 종류가 있지만 RDBMS에서는 끝단의 리프 노드에서만 값을 관리하는 B+Tree 구조를 가장 사용되고 있다
- B-Tree라는 인덱스 구조가 있는데, 가장 큰 차이점은 **리프 노드만 아니라 브랜치 노드에서도 값을 가질 수 있는 데이터 구조**다


 **B+Tree의 특징 (RDBMS 표준)**  
 **리프 노드에만 데이터 저장** (브랜치 노드는 검색용)  
 **리프 노드끼리 연결 리스트로 연결** → **범위 검색에 유리함**  
 **트리의 높이가 낮음** → 검색 속도 빠름

 **B-Tree의 특징**  
 **브랜치 노드에도 데이터 저장**  
 **범위 검색이 어려움** (리프 노드가 정렬되어 있지 않음)  
 **인덱스 크기가 커질 가능성**

 **결론:**  
 **B+Tree가 검색과 범위 조회에 유리하기 때문에 RDBMS에서 가장 많이 사용됨!** 

### RDBMS에서의 최적화 방법

#### 1) 고유성 보장 (Unique Index)

인덱스는 데이터를 빠르게 찾는 것뿐만 아니라 **고유성을 보장**하는 데에도 사용된다.

- **해시 인덱스**는 같은 키 값이면 항상 동일한 해시값을 가지므로, PK 중복 여부를 쉽게 확인할 수 있다.
- **B+Tree 인덱스**는 같은 키 값을 가진 데이터가 동일한 리프 노드에 저장되므로, 중복 체크가 효율적이다.

인덱스의 종류에는 고유인덱스, 비고유 인덱스가 있다. 

 **고유 인덱스(Unique Index)**: 중복된 값이 들어가지 않도록 보장하는 인덱스  
 **비고유 인덱스(Non-Unique Index)**: 단순 검색 속도를 높이는 용도의 인덱스

보통 PK(Primary Key)나 Unique 제약 조건이 걸린 컬럼에는 **고유 인덱스**가 자동으로 생성된다.

---

#### 2) 멀티 칼럼 인덱스 (Composite Index)

여러 개의 컬럼을 조합해서 하나의 인덱스를 만들 수도 있다.  
예를 들어, `user_id`와 `last_updated`를 함께 검색하는 경우, **두 개의 컬럼을 묶어서 인덱스를 생성**하면 검색 속도가 더 빨라진다.

대부분의 RDBMS는 멀티 칼럼 인덱스를 지원하고 있으며, 위와 같은 AND 조건에서 검색을 가속화할 수 있다

---

#### 3) 인덱스만을 읽는 검색 (Covering Index)

일반적인 인덱스 검색 과정은 **① 인덱스에서 PK 찾기 → ② PK를 이용해 본 데이터 조회**로 진행된다.

하지만, 만약 **조회하고자 하는 데이터가 인덱스에 다 포함되어 있다면 본 데이터 영역을 조회할 필요가 없다.**  
이를 **Covering Index** 또는 **Index Only Read**라고 한다.

예를 들어, 상품 가격이 10,000원 이하인 상품 개수를 세고 싶을 때,

 만약 `price`에 대한 인덱스가 있다면, **데이터 테이블을 읽지 않고 인덱스만으로 처리**할 수 있다.

---

#### 4) 인덱스 병합 (Index Merge)

일반적으로 **OR 조건**이 포함된 검색은 단일 인덱스로 최적화하기 어렵다.

예컨대 "부서 코드가 100번 또는 입사 연도가 2010년인 직원을 찾고 싶다"라는 경우를 생각해볼 수 있다

 **인덱스 병합 기능**을 이용하면 **두 개의 인덱스를 각각 검색한 후 결과를 합치는 방식**으로 최적화할 수 있다.

 **동작 방식**

1. 부서 인덱스에서 100번 부서인 직원들의 행 번호를 가져옴.
2. 입사년도 인덱스에서 2010년에 입사한 직원들의 행 번호를 가져옴.
3. **두 개의 결과를 OR 조건으로 합쳐서 최종 행 번호를 선택**.
4. 남은 행 번호를 기반으로 실제 데이터를 조회.

 이를 통해 OR 조건에서도 **인덱스를 활용한 최적화가 가능**하다.

### 멀티칼럼 인덱스 vs 인덱스 병합 차이점

멀티칼럼 인덱스 : 하나의 인덱스에 여러개의 컬럼이 들어가있는것이고  -> AND  조건 검색에 최적화
인덱스 병합 차이점 : 개별적인 인덱스들의 각각 사용후 집합연산을 수행. -> OR 조건 검색에 최적화


RDBMS에서 인덱스는 검색 성능을 높이는 반면, **업데이트 성능이 떨어지는 문제**가 있다. 이를 해결하기 위해 여러 가지 최적화 기법이 사용된다.

### **1) 디스크에 모아서 기록하기 (Batch Writing)**

- **문제점:**
    
    - 인덱스 업데이트는 **랜덤 액세스(Random Access)** 
    --> (데이터가 **디스크나 메모리의 임의의 위치에서 비순차적으로 읽히거나 쓰이는 것**을 의미.) 
    - 가 많아 디스크 I/O 비용이 증가함.
    - 특히 B+Tree 인덱스는 리프 노드가 무작위로 업데이트되므로 **랜덤 라이트(Random Write)** 발생. -> 데이터가 **디스크나 메모리의 여러 위치에 분산되어 기록되는 것**을 의미.
- **해결 방법:**
	    - Batch Update (일괄 업데이트): 여러 개의 변경 사항(INSERT, UPDATE, DELETE)을 **메모리나 전용 파일에 임시 저장 후, 일정 시간이 지난 뒤 한꺼번에 반영**하는 기법.
	    -- **랜덤 액세스를 줄이고 순차적 처리를 가능하게 함** → 디스크 I/O 성능 최적화.
	- **다수의 변경 작업을 하나의 트랜잭션으로 묶어 처리 가능** → 성능 향상 및 무결성 유지.
    - **MySQL InnoDB** 등이 이러한 방식을 사용.

---

### **2) 병렬 갱신 성능 높이기 (Parallel Update Optimization)**

- **문제점:**
    
    - B+Tree에서 값 추가/갱신/삭제 시 **리프 분할(Leaf Split)** 이 발생하며, 데이터 정합성을 유지하기 위해 **락(Lock)이 걸림**.
    - 많은 클라이언트가 동시에 갱신을 시도하면 **동시성(Concurrency) 문제** 발생.
- **해결 방법:**
    
    - **Lock-Free 알고리즘** 적용 → 인덱스 조작 시 락을 최소화하여 동시성 향상.
    - **Lock-Free 알고리즘 : 락을 사용하지 않거나 최소화**하여, 여러 스레드가 **동시에 데이터에 접근**하고 수정할 수 있도록 합니다.
    
    - **파티션 테이블(Partitioned Table) 사용** →
	- **파티션 테이블**은 하나의 **큰 테이블을 여러 개의 작은 테이블로 분할**하여 **효율적으로 관리**하는 기법입니다. 하지만 사용자에게는 **하나의 테이블처럼 보이게** 제공됩니다.  
		이 기법은 특히 **대용량 데이터베이스**에서 성능을 최적화하는 데 유용합니다. 파티션을 나누는 기준은 여러 가지가 있을 수 있으며, 데이터의 종류나 조회 성향에 따라 유연하게 적용할 수 있습니다.

	## **파티션 테이블의 특징:**

1. **사용자에게는 단일 테이블처럼 보임**:
	-  데이터를 물리적으로 분할하지만, 사용자나 개발자는 이를 하나의 테이블로 인식하고 작업을 할 수 있습니다.
	- SQL 쿼리를 작성할 때는 분할된 테이블에 대해 **별도의 처리가 필요 없으며**, 사용자에게는 하나의 **전체 테이블처럼** 보여집니다.
- 
2.  **효율적인 데이터 관리**:
    
    - 데이터가 **파티션으로 나누어져** 저장되므로 특정 범위의 데이터를 더 효율적으로 검색할 수 있습니다. 예를 들어, **날짜별로 데이터를 나누어 저장**하면 **특정 기간에 대한 조회 성능이 향상**됩니다.

3. 병렬 갱신 가능
	- 각 파티션은 **독립적인 테이블처럼** 관리되기 때문에, 하나의 파티션에 대한 갱신 작업이 다른 파티션에 영향을 미치지 않습니다.


---
#### 1. **인덱스란?**

- 데이터 검색 속도를 빠르게 하기 위한 구조
- **CRUD** 중에서 **R(Read, 조회) 성능을 향상**
- 하지만 **C(Create, Insert), U(Update), D(Delete) 연산에는 오버헤드 발생**

---

#### 2. **인덱스의 단점**

- **조회할 데이터 양이 적으면 유리** (빠르게 인덱스를 타고 접근)
- **반대로, 조회할 데이터 양이 많으면 비효율적** (전체 데이터를 읽는 것이 더 빠를 수도 있음 → Full Table Scan 사용)

---

#### 3. **B-Tree 인덱스 (Balanced Tree)**

- **리프 노드(Leaf Node)의 레벨이 유지되도록 설계**
- 삽입/삭제 시 **재정렬이 필요하여 속도가 느려질 수 있음**

---

#### 4. **클러스터형 인덱스 (Clustered Index)**

- **한 개의 테이블당 하나만 생성 가능**
- 데이터가 **물리적으로 정렬된 상태로 저장됨** → **지역성(Locality) 고려**
- **일반적으로 기본 키(PK)에서 사용**
- 단점: **삽입/삭제 시 데이터 재정렬이 필요하므로 속도가 느림**

---

#### 5. **비클러스터형 인덱스 (Non-Clustered Index)**

- **한 테이블에 여러 개 생성 가능**
- 데이터는 정렬되지 않고, 인덱스만 별도로 존재
- **클러스터형 인덱스와 함께 사용하여 보안성 향상 가능**

---

#### 6. **MySQL의 인덱스 관리**

- MySQL은 자동으로 **인덱스를 생성하고 관리**
- 하지만 **상황에 따라 적절한 인덱스 전략을 수동으로 설계해야 성능을 최적화할 수 있음**

