	

### 크래쉬

- 서버가 갑자기 다운되거나 
- 예상치 못한 장애가 일어날때를 크래쉬라고 함.
- ex) OS 비정상 종료 -> 블루 스크린

### 크래쉬가 일어나면 문제점 

- 작업하던게 날라갈 수 있음.
- 파일이 손상될수도 있음. 등등 


### 어떨때 일어나는가?

- 소프트웨어 장애
	- 데드락
	- 메모리 누수
	- 소프트웨어 문제
- OS장애
	- 블루스크린
	- 작년에 window 심각한 문제가 터진적 있다 한번 봐두자
	- OS 안에 있는 펌웨어, 드라이버들의 충돌
	- OS가 터지게되면 OS 가문제여서 터진건지, 소프트웨어가 문제여서 터진건지 로그 추적이 어렵다.
- 하드웨어 장애
	- 물리적으로 교환해야하므로 재부팅하는거에 비해 좀 오래걸림

- 조작 실수 
	- 쿼리를 잘못 작성해서 데이터를 다 날린다 이런거.
	- 가장 빈번하게 일어나게 됨.

이러한 문제들이 생겼을때 해결하기위해 백업( 데이터 이중화 ) 가 중요한것이다. 


### RAID

RAID 0 (스트라이핑) : 여러개를 두고 성능 높임 그러나 하나 망가지면 다 망가짐

RAID 1 (미러링) : 한마디로 그냥 복사를 하는것. 하나에 문제가 생길 시 다른걸로 대체

2,3,4 는 다 없어짐. 

RAID 5 : 만약 5개가 있다면 4개는 합쳐서 성능 높혀서 사용 나머지 하나는 패리티 데이터를 저장해서 되돌릴 수 있다고 함. 

-> 성능과 안정성을 둘다 잡도록 하이브리드 느낌
-> 보통 이 방식을 많이 사용한다고 함.

RAID 6 : 5에서 패리티 데이터를 저장하는걸 하나 더 두는것.

RAID 10 : 미러링을 하고 스트라이핑을 하는 것. 

-> 완전 중요하고 없어지거나 문제생기면 안되는것들은 미러링이 포함되어있는 RAID 10, RAID 1 을 사용


#### **1) 단방향 복제** master -> slave

**비동기**

- 

**동기** 

- 동기 복제는 슬레이브에서도 업데이트 결과가 반영되어 있으므로 즉시 슬레이브에서 서비스를 재개할 수 있다
- 마스터의 서버 상태가 느려짐 지연될 수 있음.


**준동기화**


#### **2) 양방향 복제** master <-> master

- 구현만 되면 아주 좋음. 그러나 구현이 어렵다고 함. 


### 트랜잭션 

ACID  : 트랜잭션의 속성이다. DB의 속성이 아니다

A : 원자성 : 될꺼면 전부되고 안될꺼면 다 안됨. 

C : 일관성 : 제약조건을 만족하는 트랜잭션 이후에도 만족해야한다. 

I : 고립성 (격리성) : 트랜잭션끼리는 서로 독립적이여야한다. 

D : 지속성 : 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야한다. 


무정지성 : 

클러스터링 


복구하기위해 REDO 로그를 사용

장애가 터져서 복구하기 위해서 REDO 로그를 사용

UNDO 로그

### 트랜잭션을 다루는 방법

0 : read unCommited -> 
1 : read Commited -> 어떠한 트랜잭션에서 commit 된 데이터를 읽는다. 
2 : 
3 : 순서대로 그냥 처리하겠다. -> 성능이 최악 병렬을 안하니까 but 안정성 최고

격리수준을 어떻게 관리를 하는가, 락에 대한 내용

MySQL  2번의 격리수준을 사용 
MVCC , 락을 두어서 MYSQL 은 처리를 했다. 

