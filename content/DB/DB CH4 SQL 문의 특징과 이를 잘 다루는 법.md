
## 1. SQL 문의 실행 효율 의식하기

SELECT문, UPDATE문, DELETE문은 많은 레코드 중에서 조건에 맞는 것을 찾아오는 처리이므로
검색 처리를 고속으로 끝내는 것이 매우 중요

### 적절한 인덱스가 사용되고 있는지 확인

검색을 빠르게 처리하는 SQL문을 작성하는 데 있어서 가장 중요한 것은
**적절한 인덱스를 사용하는 것**

인덱스를 전혀 사용할 수 없는 경우는 테이블 전체의 레코드를 검색해야 함
- 테이블이 거대한 경우 -> 작업 매우 무거워짐, 다른 작업에도 영향 끼쳐서 서비스 다운 초래할 수 있음
인덱스가 적절히 사용되는지에 대한 여부는 SQL문 자체 외에도 테이블 정의에 따라 달라짐
- 테이블 인덱스가 전혀 없으면 전체 테이블 검색이 됨
- 따라서 DML 사용 시 SQL문 뿐만 아니라 데이블 정의도 함께 보아야 함

여기서 잠깐
> [! test]
> **DDL** : Data Definition Language 데이터 정의 언어
> `CREATE` `ALTER` `DROP` `TRUNCATE`
> **DML** : Data Manipulation Language 데이터 조작 언어
> `SELECT` `INSERT` `UPDATE` `DELETE`
> **DCL** : Data Control Language 데이터 제어 언어 (사용자 권한 관리)
> `GRANT` `REVOKE`

#### EXPLAIN

EXPLAIN : 데이터베이스 제품에서 SQL문의 실행 방식이 적절한지 여부를 실제로 실행하지 않고 판정만 해주는 기능

![](https://i.imgur.com/9RLJW01.png)

MySQL에서 EXPLAIN을 사용한 예시

특히 중요한 것은 **rows**
여기서 rows는 MySQL 옵티마이저가 쿼리를 처리하기 위해 검사해야 할 것으로 '예상하는' 레코드 수를 의미

rows 값이 1이라는 것은:
- 해당 쿼리에서 MySQL이 단 한 개의 레코드만 검색하면 된다고 예상한다는 뜻
- 예를 들어, PRIMARY KEY나 UNIQUE INDEX를 사용한 정확한 일치 조건(WHERE id = 5)과 같은 경우 rows=1이 나올 수 있음
- 테이블에 실제로 수천, 수만 개의 레코드가 있더라도, 인덱스를 효율적으로 사용하면 단 하나의 레코드만 액세스하면 된다는 의미

일반적으로 rows 값이 낮을수록 쿼리가 효율적이라고 볼 수 있음
why?
- 검사해야 할 레코드 수가 적을수록 쿼리 실행 속도가 빨라짐
- rows=1은 옵티마이저가 단 하나의 레코드만 검사하면 된다고 판단했기 때문에 일반적으로 매우 효율적인 쿼리라고 볼 수 있음
그러나 이 값은 항상 정확한 것은 아니며, MySQL의 예측값이라는 점을 기억

쿼리를 실행하기 전에 EXPLAIN을 처리해 봄으로써 나쁜 쿼리를 사전에 찾아낼 수 있음
- 인덱스 제대로 사용하지 않아서 전체 테이블 검색을 할 수밖에 없는 row 사전 차단 가능

#### 쿼리 분석도구
- 다양한 쿼리를 실행하는 애플리케이션을 운용해 나가다 보면 도대체 어느 쿼리가 느린지 파악하기 어렵게 되므로 EXPLAIN을 실행하기 전에 먼저 어떤 쿼리가 수상한지 찾을 필요가 있음

- 이러한 분석 지원계의 기능도 데이터베이스 제품에 포함되어 있으며, 널리 보급된 제품이라면 직접적인 커맨드 없이도 오픈 소스 지원 도구 등을 사용하여 쿼리를 분석할 수 있음
    - 최근엔 많은 모니터링 툴에서 쿼리 속도를 분석해주고 있음
	예시로는 뭐가 있을까? 찾아보기


## 2. SQL 장점과 단점

프로그래밍 언어에서 데이터 구조를 조작하는 경우에 비해 SQL문을 사용하여 데이터베이스를 액세스하는 작성법은 다양한 장점과 단점 존재

조작성과 기능면의 측면에서 설명

### SQL은 기술 습득이 용이하다

프로그래밍 언어를 사용하여 db를 조작하는 것은 상당히 어려움
	프로그래밍 언어에 대한 이해 + db 조작을 위한 라이브러리에 대한 이해도 필요

-> SQL문은 그에 비해 사용법이 간단하고 학습이 쉬움
	터미널에 접속하면 이후에는 SELECT문으로 실행
	SELECT문, FROM절, WHERE절 등 SQL문을 이루는 구성요소들은 영문 그대로 의미가 통하므로 알기 쉬움

#### 하지만 SQL도 심오하다

솔직히 SQL?? 어렵다
습득 용이한건 진짜 사용해 보는 수준에 도달하는 데까지의 이야기

대량의 데이터를 취급하는 db에서는 쿼리 성능에 관한 문제가 발생함
이러한 문제 해결 위해서 db 아키텍처와 인덱스 구조, 디스크와 메모리의 속도 차이 등 다양한 관점에서의 이해가 필요

### 기능면에서의 SQL

SQL문은 편리한 언어이지만 비즈니스 로직을 SQL문으로 기술하는 것은 어려움
-> 데이터베이스가 제공하는 **저장 프로시저** 이용하면 다소 복잡한 로직 구현 가능

저장 프로시저는 데이터베이스 서버에서 동작하므로 수십번 실행해야 하는 SQL문 대신
SQL문 모아둔 저장 프로시저 한 번만 호출하는 사용법 사용하면 네트워크 엑세스 빈도를 크게 줄일 수 있음
-> 네트워크 속도 느린 과거에는 애용되었음

But 최근에는 저장 프로시저 사용 X
비즈니스 로직은 애플리케이션 계층에서 처리함
db는 데이터의 출입만을 취급하는 분담 체제가 주류임

로직은 프로그래밍 언어, 데이터 조작은 SQL에 분담시키는 큰 이유는 
프로그래밍 언어 쪽이 SQL 및 저장 프로시저보다 **개발환경이 압도적으로 풍부하여 생산성 측면에서 강점** 있음


### 쿼리 최적화 (by.한얼)
당연히 알아야하는거고 
SQL -> **쿼리 최적화 부분**을 알아야함

쿼리 최적화를 위해서 
mysql 측면에서 **explain** -> 
- index로 접근하는지 full table scan으로 가져가는가? 
- join도 hash join merge join 등등 판단 잘 해야함
- 얼마나 처리비용이 되고 얼마나 row가 count가 되느냐
이런 식으로 쿼리 최적화를 위해서 사용

**index** 활용
어떻게 활용해야하는가? -> 월요일에 얘기했음

**WHERE절** 최적화
index를 지정한다고 끝 X 
	where로 index를 뽑아올 때 연봉이 아니라 월급으로 계산했다 생각해보자
	월급 -> 연봉으로 계산해야할 때 월급 x 12 하면 Index 안 타므로 사용하면 안 됨
	연봉 / 12 -> 이런식으로 해야 index를 탐

**LIKE** 
문자열% 이렇게 %가 뒤에 나오면 index를 탐
%가 앞에 붙어있으면 index 타지 않음
이런 식으로 쿼리를 최적화

**서브쿼리**
기본적으로 join을 쓰던가 서브쿼리를 쓰던가 해서 *일대일 치환* 가능
대부분의 경우에서는 서브쿼리가 더 느리다
*왜?*
기본적으로 join은 dbms가 알아서 처리를 좀 빠르게 해줌

dbms 옵티마이저는 서브쿼리에 대해서도 실행 계획을 세우긴 한다만, 외부 쿼리의 각 행마다 서브쿼리가 실행되어야 하는 경우 서브쿼리가 외부 쿼리의 행 수만큼 반복 실행되므로 성능이 저하될 수 있음 (좀 느리다)

서브쿼리가 독립적으로 실행될 때는 옵티마이저가 전체 쿼리에 대한 최적의 접근 방법을 찾기 어려울 수 있음
따라서 join에 비해 옵티마이저가 최적화할 수 있는 옵션이 제한적일 수 있음!!

**페이지네이션 구현**
페이지를 구현하는 이유 : 다 들고와서 보여줄 수 없음!!
- 다 들고온 것을 바탕으로 db 전체를 다 조회하기엔 너무 느리니까 **범위를 기록해두고** 그 다음부터 다시 찾는 방식으로 쿼리 최적화

**CTA**
뷰 (테이블을 가상의 테이블로 만듦)
임시적인 테이블을 만들어놓고 갖다가 쓰는 방식 
복잡한 쿼리를 cta를 사용하면 복잡한 쿼리 최적화

**파티셔닝**
파티셔닝을 이상하게 들고가면 성능 떨어지겟지만 적절하게 잘 처리하게되면
그거에 대해서 쿼리 최적화를 잘 가져갈 수 있다더라...


### SQL 자체의 안티패턴들

이렇게 쓰면 SQL 손해보는 패턴들
대표적인 것
- ORM 사용 시 **N+1 문제**
	- ORM 사용 시, 연관 데이터를 함께 조회해야할 때 Lazy Loading 전략이 적용되어 있으면, 영속성 컨텍스트에 캐싱된 데이터가 없는 경우 추가적인 쿼리 발생
	- 이로 인해 Join을 한 번 사용하여 모든 데이터를 가져올 수 있는 상황에서도 메인 엔티티를 조회하는 쿼리 1번과 각 엔티티의 연관 데이터를 조회하는 N번의 추가 쿼리가 실행되어 총 N+1번의 쿼리가 발생
	- FETCH JOIN으로 해결
	- Entity Graph 사용
- Join 조건 제대로 X from으로 테이블 두개
	- 카티시안 곱 문제가 있음
	- 조인 조건을 잘 체크해서 가져와야됨
	
- 조인이 엄청나게 많아지는 경우에 조인 자체에서 오는 여러가지 문제 있음 
	- 비정규화 하거나 그걸 위한 다른 뷰를 만들어놔서 그걸로 처리 아니면 cta 활용
- 대용량 데이터 bulk 처리 어떻게 하는가?
- 데이터 batch로 해서 어떻게 가져와야하는가?
	- jpa는 기본적으로 해주기는 함 + spring batch 어떻게 써야하는가? 왜 써야하는가? (정리하기)

### 트랜잭션 격리수준 

트랜잭션 격리 수준에 대해서 알 필요가 있음
	0~3 level
	어떤 격리? 
	높은 레벨 -> 동시성, 성능적으로 떨어질 수 있음
	낮은 레벨 -> 동시성 올라갈 수 있음
	read/write 어디에 중점을 두냐에 따라 트랜잭션 수준도 잘 판단해야됨

mysql Innodb -> 트랜잭션 격리 수준은 level2

나머지 db들은 기본적으로 트랜잭션 격리 수준 level1 -> migration 할 때 격리수준 잘 생각해봐야됨


**트랜잭션 격리 수준**
- SERIALIZABLE
- REPEATABLE READ
- READ COMMITTED
- READ UNCOMMITED

