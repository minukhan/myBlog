## 문제 상황

- **증상**: 특정 API (`GET /api/v1/organizations/{id}/members`) 응답 시간이 대규모 고객 데이터에서 수 초 이상 지연, 때로는 타임아웃 발생.
- **특징**: 스테이징 환경에서는 정상(200ms), 프로덕션 대규모 데이터 환경에서만 심각.
- **미션**: 단순 버그 해결이 아니라 **확장성 보장**과 **근본 원인 분석**.

---

## 2. 1차 분석: APM으로 병목 구간 식별

- **APM 도입**: 코드 수정 없이 트랜잭션 추적, DB 호출, 지연 구간 시각화.
- **분석 결과**:
    - 비즈니스 로직은 빠름.
    - **DB 호출이 응답 시간의 97% 차지.**
- **문제 패턴**: 복잡한 단일 쿼리가 아니라, 작은 쿼리 수백 개 반복 실행.
    - `members` → `roles` → `user_profiles` 순차 호출 = **N+1 쿼리 문제**.

---

## 3. 원인 심화: ORM과 DB 이슈

- **ORM 문제**:
    - JPA 기본 Fetch 전략(EAGER/LAZY)으로 인해 `member.getRole()` 호출 시 마다 쿼리 발생.
    - N+1 Select 문제 발생.
- **DB 문제**:
    - `EXPLAIN` 결과 `role_id` 조회 시 **풀 테이블 스캔(ALL)** 발생.
    - **외래 키 컬럼 인덱스 부재** 확인.
- **결론**: N+1 쿼리 패턴과 인덱스 부재가 결합 → 성능 폭발적 저하.

---

## 4. 해결책: 애플리케이션 + DB 양방향 최적화

1. **애플리케이션 계층**:
    - Spring Data JPA 단순 `findAllByOrganizationId()` → QueryDSL `fetchJoin()`으로 리팩토링.
    - N+1 쿼리를 **단일 JOIN 쿼리**로 통합.
2. **데이터베이스 계층**:
    - 외래 키 컬럼에 인덱스 추가:
        
        ```sql
        CREATE INDEX idx_member_role_id ON members (role_id);
        CREATE INDEX idx_member_user_profile_id ON members (user_profile_id);
        
        ```
        
    - 풀 테이블 스캔 제거 → 인덱스 탐색(Seek) 가능.
        

---

## 5. 결과와 검증

- **DB 수준**: `EXPLAIN`에서 `ALL` → `ref`, rows 수 50,000 → 1.
- **애플리케이션 수준**: APM에서 API 응답 시간 5,000ms → 50ms 미만으로 개선.
- **비즈니스 효과**: 사용자 경험 개선 + 확장성 보장.

---

## 6. 교훈

- **ORM의 새는 추상화**: ORM은 편리하지만 SQL 실행을 항상 의식해야 함.
- **체계적 진단 프로세스**:
    - APM → 애플리케이션 로그 → DB EXPLAIN → 원인 규명.
- **설계의 중요성**:
    - ERD는 무결성뿐 아니라 **접근 패턴과 인덱스 설계**까지 고려해야 함.
- **개발자의 성장**: 단순 기능 개발자가 아닌, **엔드투엔드 성능을 책임지는 엔지니어**로 성장.