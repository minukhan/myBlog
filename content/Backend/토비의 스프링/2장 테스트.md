### 들어가기 전에
- 스프링의 핵심인 IoC와 DI는 오브젝트의 설계와 생성 관계, 사용에 관한 기술
- 스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술
- 이렇게 복잡한 애플리케이션을 개발하는데 필요한 도구들
	1. 객체지향 기술
	2. 테스트(스프링이 강조하고 가치를 두고 있음)
- 테스트는 작성한 코드에 대해 확신을 갖게 해준다.
- 2장에서는 테스트란 무엇이며, 그 가치와 정점, 활용 전략, 스프링과의 관계를 살펴볼 예정
### UserDaoTest 다시 보기
- 테스트란?
	: 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업
	-> 정상적으로 동작하는지 눈으로 확인해서 어떤 기능을 수행한다는 것을 보장해줄 수 있는 방법은 테세트 밖에 없다.
##### UserDaoTest의 특징
![](https://i.imgur.com/ewKi0HK.png)
-> 테스트할 대상인 UserDao를 직접 호출해서 사용한다는 점이 눈에 띈다.
###### 웹을 통한 DAO 테스트 방법의 문제점
- 보통 웹 프로그램에서 DAO를 테스트하는 방법
	-> 다들 경험해본 적이 있을 수 있는데, DAO를 만든 뒤 바로 테스트하는 것이 아니라 이 DAO를 위한 가장 기본적인 기능을 하는 서비스 계층, MVC 프레젠테이션 계층까지 만들어서 테스트를 한다.
	-> 이렇게 만들어진 테스트용 웹 애플리케이션을 서버에 배치한 뒤, 웹 화면을 띄워 폼을 열고, 값을 입력한 뒤 버튼을 눌러 등록해본다.
	(한용5 수업에서 간단한 화면 만들고 동작하는지 확인해보고 이런 과정이랑 비슷하다고 생각하면 됩니다.)
- 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰는 방법이지만, DAO에 대한 테스트로는 단점이 많다.
	1. DAO 뿐만이 아니라 다른 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다.(오버헤드가 큼, 배보다 배꼽이 커지는 현상)
	2. 테스트 도중 에러가 발생하거나 테스트가 실패한다면 문제가 발생한 곳을 찾는데 어려움이 있다.
	3. 테스트하고 싶은 코드가 아닌 다른 코드가 영향을 줄 수 있다.
	-> 이 방식은 매우 번거롭고, 오류가 발생할 경우 빠르게 대응하기가 어렵다
##### 작은 단위의 테스트
- 위에서 언급한 문제를 해결하기 위해 테스트는 가능하면 작은 단위로 쪼개서 하는 것이 좋다.
- 관심사의 분리 원리가 여기에도 적용됨
	: 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
- 이번 단계에서 만드는 UserDaoTest는 한 가지 관심에 대해 집중할 수 있게 작은 단위로  만들어진 테스트로 다른 추가적인 것이 필요하지 않다.(간단히 IDE나 도스창에서 테스트 가능)
	-> 이때 에러가 발생하거나 원하는 결과와 다른 결과가 나온다면 그것은 UserDao 코드나 DB 연결 방법 정도에서 문제가 있는 것이므로 빠른 원인 파악 가능
- 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(Unit Test) 라고 한다.
	-> 여기서 말하는 단위는 명확히 정해진 것은 없지만 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 생각하면 된다.(일반적으로 단위는 작을수록 좋음)
- 하지만 이런 단위 테스트 말고 아까와 같이 전체적으로 연동되는 테스트도 언젠가는 필요하다
  (단위 테스트만으로 실제 상황에서 기능이 정상적으로 동작하는지 알 수 없기 때문 -> 다양한 요소 고려)
##### 단위 테스트와 DB 사용에 관한 논쟁

###### DB를 사용하면 단위 테스트가 아니라는 관점

1. 단위 테스트의 정의적 측면
    - 단위 테스트는 코드의 가장 작은 '단위'(일반적으로 메서드나 함수)를 독립적으로 테스트하는 것
    - 외부 의존성(DB, 외부 API 등)이 포함되면 더 이상 '단위'가 아닌 통합 테스트로 간주됨
2. 속도와 효율성
    - DB 연결은 테스트 실행 시간을 크게 늘림
    - CI/CD 파이프라인에서 수천 개의 테스트를 빠르게 실행해야 하는 환경에서는 중요한 문제
3. 격리(Isolation) 원칙
    - 단위 테스트는 서로 완전히 독립적이어야 함
    - DB 상태는 테스트 간에 공유될 수 있어 테스트 순서에 의존성이 생길 위험
4. 테스트 용이성
    - 외부 의존성이 없으면 테스트 설정이 간단하고 빠름
    - 모의 객체(Mock)를 사용하면 특정 시나리오를 쉽게 시뮬레이션할 수 있음

###### DB를 사용해도 단위 테스트가 될 수 있다는 관점
- 이 책에서는 UserDaoTest를 수행할 때 매번 USER 테이블의 내용을 비우고 테스트를 진행했는데, 이렇게 사용할 DB의 상태를 테스트가 관장하고 있다면 이는 단위 테스트라고 할 수 있다고 합니다.
- 하지만 DB 상태가 매번 달라지고, 테스트를 위한 DB를 특정 상태로 만들어줄 수 없다면 단위 테스트라고 보기 힘듦

1. 실제 환경에 가까운 테스트
    - 모의 객체는 실제 DB와 다르게 동작할 수 있어 현실적인 테스트가 어려움
    - 실제 DB를 사용하면 프로덕션 환경과 유사한 조건에서 테스트 가능
2. 단위의 정의 확장
    - '단위'는 반드시 단일 메서드만을 의미하지 않음
    - 특정 기능 단위나 DB 액세스 계층 전체를 하나의 단위로 볼 수 있음
3. 인메모리 DB 활용
    - H2, SQLite 등의 인메모리 DB를 사용하면 속도와 격리 문제 해결 가능
    - 실제 DB와 유사하면서도 테스트에 최적화된 환경 제공
4. 테스트 데이터 관리
    - 각 테스트 전후로 데이터를 초기화하면 격리 문제 해결 가능
    - 트랜잭션 롤백을 활용하여 테스트 간 간섭 방지

###### 실용적인 접근법

1. 계층별 테스트 전략
    - 비즈니스 로직 → 순수한 단위 테스트 (모의 객체 사용)
    - 데이터 액세스 계층 → DB 통합 테스트
    - 전체 시스템 → 종단 간(E2E) 테스트
2. 테스트 피라미드 적용
    - 단위 테스트(모의 객체 사용) 다수
    - 통합 테스트(실제 DB 사용) 중간
    - E2E 테스트 소수
3. 상황에 맞는 선택
    - 프로젝트 규모, 팀 규모, 코드 성격에 따라 적절한 전략 선택
    - 모든 상황에 맞는 하나의 정답은 없음
###### 자동수행 테스트 코드
- 테스트는 사람의 수작업을 거치는 방법보다는 코드로 만들어져서 자동으로 수행될 수 있어야 한다.
	-> 시간적 측면, 번거로운 작업 X
- 자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다.
- 번거로운 작업이 없고 빠르게 테스트를 실행할 수 있기 때문에 언제든 코드를 수정하고 테스트가 가능하다.
##### UserDaoTest의 문제점
- 확인 작업이 수동으로 이루어짐
- 실행 작업이 번거로움
##### UserDaoTest 개선
###### 테스트 검증의 자동화
- 모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있다.
- 테스트 주에 에러가 발생하는 것은 자동으로 발생하는 것이므로 쉽게 확인이 가능하지만 원하는 결과와 다른 결과가 나오는 등 실패하는 경우는 별도로 확인이 필요 -> "테스트 실패" 메세지를 출력하도록 수정
	-> 성공 시에는 "테스트 성공"
- 만들어진 코드의 기능을 모두 점검할 수 있는 포괄적인 테스트를 만들게 되면, 수정 이후에 테스트를 모두 돌려봄으로써 코드에 대한 신뢰성을 어느 정도 보장할 수 있게 된다.
##### 테스트를 위한 도구의 필요성
- main() 메소드로 테스트를 수행하고 편리하게 결과를 관리하는데는 한계가 있음
	: 일정한 패턴을 가진 테스트를 만들 수 있고, 많은 테스트를 간단히 실행시킬 수 있으며, 테스트 결과를 종합해서 볼 수 있고, 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘 테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요
	-> 애플리케이션 규모가 커지고 테스트 개수가 많아지면 부담이 커질 것
##### JUnit 테스트로 전환
###### JUnit 개요
- JUnit은 Java 언어를 위한 단위 테스트 프레임워크입니다.
- 프레임워크이므로 제어의 역전이 적용되어 있고 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다.
###### 주요 특징
- 어노테이션 기반 테스트 작성 (@Test, @Before, @After 등)
- 단언문(assertions)을 통한 결과 검증
- 테스트 실행 및 결과 보고
- 테스트 스위트 지원
###### 활용
- TDD(테스트 주도 개발) 구현에 적합
- 대부분의 Java IDE와 통합
- 현재 JUnit 5가 최신 버전
- 오픈 소스 프로젝트
###### 장점
- 코드 품질 향상
- 버그 조기 발견
- 리팩토링 안전성 확보
- 개발 생산성 증가

-> 기존에 만들었던 main() 메서드 테스트는 제어권을 직접 갖기 때문에 프레임워크에 적용하기엔 적합하지 않고 따라서 main() 메서드에 있던 테스트 코드를 일반 메서드로 옮겨야 한다.
###### JUnit 프레임워크가 테스트 메서드에 요구하는 조건
1. 메서드가 public으로 선언되어야 함
2. 메서드에 @Test라는 어노테이션을 붙여줘야 함
###### 검증 코드 전환
- 기존에 if/else로 테스트의 결과를 검증하는 방식으로 구현되어 있었는데, 이 부분을 JUnit이 제공하는 assertThat이라는 스태틱 메서드를 사용하는 방식으로 변경한다.
- assertThat 메서드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어줌
	-> 이때 검증 결과가 기대한 결과가 아니면 AssertionError를 던진다.(테스트 수행 중에 예외가 발생하는 경우 테스트 수행은 중단되고 테스트는 실패한다.)
### 테스팅 프레임워크 JUnit
- 스프링 프레임워크도 JUnit 프레임워크를 이용해 테스트를 만들어가며 개발됨
- JUnitCore를 이용해 테스트를 실행하는 방법이 가장 간단하지만 테스트의 수가 많아지면 관리하기 힘들어진다는 단점이 있음.
	-> 가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것
- 실행과 관련된 부분은 간단히 읽어보면 좋을 듯
- JUnit은 하나의 클래스 안에 여러 개의 테스트 메서드가 들어가는 것을 허용
	-> @Test가 붙어 있고 public 접근자가 있으며 리턴 값이 void 형이고 파라미터가 없다는 조건을 지키기만 하면 된다.
- JUnit은 특정한 테스트 메서드의 실행 순서를 보장해주지 않는다.
	-> 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것
	ex) addAndGet() 테스트 메서드에서 사용한 사용자 정보를 count() 테스트 메서드에서 활용하는 식으로 테스트를 만들며 ㄴ안된다.
##### 테스트 결과의 일관성
- 위에서 보았던 테스트는 매번 DB 정보를 삭제 후 테스트를 동작시키는 방식이었는데 이 경우 이런 과정을 거치지 않는다면 테스트 실행 중 에러가 발생하는 경우가 발생 가능
	-> 외부 상태에 따라 테스트의 성공 여부가 바뀜
	-> 이는 좋은 테스트가 아님
- 책에서는 테스트 실행 전에 getCount()를 통해 데이터 개수를 가져오고 데이터가 남아있다면 새로 만든 deleteAll() 메서드를 통해 데이터를 삭제해 동일한 상태를 유지하는 방식을 사용
- 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다.
	1. DB의 데이터와 같은 외부 환경에 영향을 받지 않아야 함
	2. 테스트 실행 순서를 바꿔도 동일한 결과가 보장되도록 해야 함
##### JUnit의 예외 테스트 기능
- 예외 발생 여부는 메서드를 실행해서 리턴 값을 비교하는 방법으로 확인할 수 없다
	-> 즉, assertThat() 메서드로는 검증이 불가능하다.
- @Test에 expected 속성을 추가해놓으면 보통의 테스트와는 다르게 정상적으로 메서드를 마치면 테스트가 실패하고, expected에서 지정한 예외가 던져지면 테스트가 성공한다.
- 테스트를 작성할 때는 부정적인 케이스를 먼저 만드는 습관을 들이는 것이 좋다
	-> 예외 상황을 빠뜨리지 않을 가능성이 높아짐
### 테스트 주도 개발(Test Driven Development)
##### 테스트 주도 개발이란?
- 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법
- 테스트를 코드보다 먼저 작성한다고 해서 테스트 우선 개발이라고도 한다.
###### TDD 프로세스
- Red: 실패하는 테스트 작성
- Green: 테스트를 통과하는 최소한의 코드 작성
- Refactor: 코드 개선 및 중복 제거
###### 핵심 원칙
- 테스트 먼저, 코드는 나중에
- 작은 단위로 점진적 개발
- 지속적인 테스트와 리팩토링
- YAGNI(You Aren't Gonna Need It) 원칙 준수
###### 장점
- 코드 품질 향상
- 명확한 요구사항 이해
- 설계 개선 및 유지보수 용이
- 회귀 오류 방지
- 개발자 자신감 증가
- 테스트를 실행하는 사이의 간격이 매우 짧다(오류를 빨리 발견하고 대응 가능)
##### JUnit 테스트 수행 과정
1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메서드를 모두 찾는다.
2. 테스트 클래스의 오브제트를 하나 만든다. (테스트 클래스의 오브젝트는 하나의 테스트 메서드를 사용하고 나면 버려진다.)
3. @Before가 붙은 메소드가 있으면 실행한다. (보통 공통적인 준비 작업)
4. @Test가 붙은 메서드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메서드가 있으면 실행한다. (보통 공통적인 정리 작업)
6. 나머지 테스트 메서드에 대해 2~5번 과정을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.
-> @Before와 @After에서 공통적인 준비/정리 작업이 수행되도록 한다면 테스트 메서드 별로 따로 메서드를 호출해야 할 필요성이 없어지고 코드의 중복을 피할 수 있음
> [!note] 테스트 메서드를 실행할 때마다 새로운 오브젝트를 만드는 이유
> 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들도록 했다. 보통 @Before에서 변수를 초기화하는 경우가 많은데 이때 인스턴스 변수를 부담 없이 사용할 수 있는 이유가 이것이다.

- 만약 테스트 메서드의 일부에서만 공통적으로 사용되는 코드가 있다면 @Before를 사용하기보다는, 일반적인 메서드 추출 방법을 써서 메서드를 분리하고 이를 호출해서 사용하도록 만드는 것이 낫다.
###### 픽스처
- 테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처라고 한다.
- 일반적으로 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메서드를 이용해 생성해두면 편리하다.
### 테스트를 위한 애플리케이션 컨텍스트 관리
- 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공
- 테스트 컨텍스트의 지원을 받으면 간단한 어노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어 모든 테스트가 공유하게 할 수 있다.
- @RunWith는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 어노테이션
	-> 여기서는 SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정했고, 이게 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.
- @ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정 파일 위치를 지정한 것
- 예시로 콘솔에 출력해서 보는게 있는데 여기서 출력된 context와 this의 오브젝트 값을 보면, context는 세 번 모두 동일하고 UserDaoTest의 오브젝트 주소는 매번 주소 값이 다름 것을 확인할 수 있다.
	-> 하나의 애플리케이션 컨텍스트가 만들어져 모든 테스트 메서드에서 사용되고 있으며, 앞에서 설명한 것처럼 JUnit은 테스트 메소드를 실행할 때마다 새로운 테스트 오브젝트를 만들기 때문
- 스프링이 애플리케이션 컨텍스트 테스트 개수에 상관없이 한 번만 만들어서 공유가 가능하도록 해줬기 때문에 테스트 수행 속도가 매우 빨라진다.
	-> 첫 번째 테스트에서는 최초로 애플리케이션 컨텍스트가 만들어지므로 가장 오랜 시간이 소모된다.
- 스프링은 하나의 테스트 클래스 안에서만 애플리케이션 컨텍스트를 공유해주는 것이 아니라, 여러 개의 테스트 클래스가 있고 모두 같은 설정 파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.(하나만 만들어서 공유)
	-> 이를 통해 테스트 성능 대폭 향상
##### Autowired
- @Autowired는 스프링의 D에 사용되는 특별한 어노테이션(Vol.2에서 자세히 설명)
- 동작
	1. @Autowired가 붙은 인스턴스 변수가 있다면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾음
	2. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입
- 일반적으로 주입을 위해서는 생성자나 수정자 메서드 같은 메서드가 필요하지만, 이 경우에는 메서드가 없어도 주입이 가능하다.
- 별도의 DI 설정 없이 필드의 타입 정보를 이용해 빈을 자동으로 가져올 수 있는데, 이런 방법을 타입에 의한 자동 와이어링이라고 함
- 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록
- @Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다.
	- 단, @Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.
- 예시
```
// 설정 클래스
@Configuration
public class DataSourceConfig {
	@Bean
	public DataSource simpleDriverDataSource() {
		// 생략
	}

	@Bean
	public DataSource hikariDataSource() {
		// 생략
	}
}

// 사용 예시 1: 구체적인 타입 주입
@Service
public class DatabaseService1 {
	@Autowired
	private SimpleDriverDataSource dataSource; // 구체적인 타입으로 주입

	public void printDataSourceInfo() {
		// 생략
	}
}

// 사용 예시 2: 인터페이스 타입 주입 (빈이 두 개 이상일 때 문제 발생)
@Service
public class DatabaseService2 {
	@Autowired
	private DataSource dataSource; // 인터페이스로 주입, 어떤 구현체가 주입될지 모호함

	public void printDataSourceInfo() {
		// 생략
	}
}

// 사용 예시 3: @Qualifier 어노테이션으로 명시적 지정
@Service
public class DatabaseService3 {
	@Autowired @Qualifier("simpleDriverDataSource") // 명시적으로 어떤 빈을 주입할지 지정 private DataSource dataSource;

	public void printDataSourceInfo() {
		// 생략
	}
}
```
- `DatabaseService1`은 `SimpleDriverDataSource` 타입으로 명확하게 주입받습니다.
- `DatabaseService2`는 `DataSource` 인터페이스 타입으로 주입받는데, 이 경우 두 개 이상의 `DataSource` 구현체(`simpleDriverDataSource`와 `hikariDataSource`)가 있어 스프링이 어떤 빈을 주입해야 할지 모호해집니다. 이 경우 다음과 같은 에러가 발생할 수 있습니다:
    
    `No qualifying bean of type 'javax.sql.DataSource' available: expected single matching bean but found 2`
    
- `DatabaseService3`은 `@Qualifier` 어노테이션을 사용하여 명시적으로 `simpleDriverDataSource` 빈을 주입받도록 지정합니다.


-> SimpleDriverDataSource 타입의 변수로 선언하는 방법과 DataSource 타입으로 선언하는 방법 중 어떤 것이 나을까?
	: 용도에 따라 다름. 하지만 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다.
##### 인터페이스를 두고 DI를 적용해야 하는 이유
1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
	-> 클래스 대신 인터페이스를 사용하고,  new를 이용해 생성하는 대신 DI를 통해 주입받게 하는 건 매우 단순하고 쉬운 작업인데 이런 단순한 작업으로 혹시라도 수정이 필요한 상황에서 시간과 비용의 부담을 줄일 수 있음
2. 클래스의 구현 방식은 바뀌지 않더라도 인터페이스를 두고 DI를 적용하면 다른 차원의 서비스 기능을 도입할 수 있다.
	-> 1장에서 만들었던 DB 커넥션의 개수를 카운팅하는 부가기능이 그 예시이다. 이 과정에서 새로운 기능을 넣기 위해 기존 코드를 수정할 필요가 없었다.
3. 효율적인 테스트를 쉽게 만들기 위해서
	-> DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 함

### DI를 테스트에 이용하는 방법
##### 수동 DI
- 테스트용 DB에 연결해주는 DataSource를 테스트 내에서 직접 만들고 이를 setter를 통해 수동 주입(DI)
	-> 애플리케이션 컨텍스트에서 가져온 UserDao 빈의 의존관계를 강제로 변경(바람직하지 않음)
- @DirtiesContext 어노테이션 추가
	-> 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려줌
	=> 테스트 컨텍스트는 이 어노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않음(매 메서드마다 새로운 애플리케이션 컨텍스트를 생성해서 다음 테스트가 사용하게 함)
- 이렇게 매번 만드는 건 좋지 않다.
- @DirtiesContext는 클래스에만 적용할 수 있는 것은 아니고, 하나의 메서드에서만 컨텍스트 상태를 변경한다면 메서드 레벨에 붙여주는 편이 좋다.
##### 테스트 전용 설정 파일 생성
- 두 가지 종류의 설정파일을 만들어서 하나는 서버에서 운영용으로 사용할 DataSource를 빈으로 등록해두고, 다른 하나에는 테스트에 적합하게 준비된 DB를 사용하는 가벼운 DataSource가 빈으로 등록되게 만드는 것 
	-> 테스트에서는 항상 테스트 전용 설정파일만 사용하게 함
##### 컨테이너 없는 DI 테스트 
- 스프링 컨테이너를 아예 사용하지 않고 테스트를 만드는 것
- DI는 객체지향 프로그래밍 스타일로 DI를 위해 컨테이너가 반드시 필요한 것은 아니다.
	-> DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다.
##### 학습 테스트 
- 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 하는데 이를 학습 테스트라고 한다.
- 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것
###### 학습 테스트의 장점
1. 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
2. 학습 테스트 코드를 개발 중에 참고할 수 있다.
3. 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
	-> 요즘처럼 업데이트가 매우 빠른 환경에서 작은 업데이트에 미묘한 오류가 발생할 수 있는데 학습 테스트를 통해 기존에 사용하던 API가 기능에 문제가 없다는 사실을 미리 확인해볼 수 있다.
4. 테스트 작성에 대한 좋은 훈련이 된다. 
##### 버그 테스트
- 코드에 오류가 있을 때 그 오류를 가장잘 드러내줄 수 있는 테스트
- 버그가 원인이 되어 테스트가 실패하논 코드를 만드는 것 
	-> 그 이후에 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다.
###### 버스테스트의 필요성 및 장점
1. 테스트의 완성도를 높여준다.
	-> 미처 검증하지 못했던 부분이 있는 경우에 오류가 발생
2. 버그의 내용을 명확하게 분석하게 해준다.
3. 기술적인 문제를 해결하는 데 도움이 된다. 