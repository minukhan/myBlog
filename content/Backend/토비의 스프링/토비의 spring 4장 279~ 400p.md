
# 4장 - 예외

- 개발자가 신경쓰기 귀찮은 영역 - 예외처리
- 이번 장에서는...
    - 스프링의 데이터 엑세스 기능의 예외처리
  
>[!note] 참고
>
>예외가 관련된 코드는 자주 엉망이 되거나 무성의하게 만들어지기 쉽다. 
>때론 잘못된 예외처리 코드 때문에 찾기 힘든 버그를 낳을 수도 있고, 생각지 않았던 예외상황이 발생했을 떄 상상 이상으로 난처해질 수도 있다.
## 4.1. 사라진 SQLException

279p

```java
    public void deleteAll() throws SQLException {
        this.jdbcContext.executeSql("delete from users");
    }
```

```java
    public void deleteAll() {
        this.jdbcTemplate.update("delete from users");
    }
```

JdbcTemplate 적용 이전에는 있었던 throws SQLException 선언이 적용 후에는 사라졌음을 알 수 있다.

SQLException 의 행방은 어디로? 

### 4.1.1. 초난감 예외처리 (이렇게 하면 안된다라는 예시들들)


- 대표적인 초난감 예외처리 대표주자들!
    - 예외 블랙홀
        
        ```java
            try {
        
            } catch(SQLException e){
            }
        ```
        
        - 예외를 받고 아무것도 하지 않음
        - 발생한 예외를 무시해버리는 상황 발생
        - 이런 코드를 작성하게되면 문제는 -> 나중에 오류가 있어 예외발생시 어디에서 문제가 생기는지 전혀 알수 없게 되버린다는 점이다.
        
        ```java
        } catch(SQLException e){
            System.out.println(e);
        }
        ```
        
        ```java
        } catch(SQLException e){
            e.printStackTrace();
        }
        ```
        
        - 위의 둘도 문제가 많음
        - 콘솔 로그에만 찍히게 되는데, 누가 직접 콘솔을 계속 보고 있지 않는 한 이 메시지를 볼수 없다.
        - 예외는 처리돼야 하는데 리스트 4-2와 리스트 4-3에서 catch 블록을 이용해 화면에 메시지를 출력한 것은 예외를 처리한 게 아니다.


- SQLException의 발생 이유
	- SQL문법에러
	- DB에서 처리할수 없을 정도의 데이터 액세스 로직에 심각한 버그
	- 서버가 죽음 혹은 네트워크가 끊김

  ```java
        } catch(SQLException e){
            e.printStackTrace();
            System.exit(1);
        }
        ```

- 최소한 이렇게라도 해야 함
- 이 코드는 **예외가 발생하면, 에러 메시지를 출력한 후 프로그램을 강제 종료**하는 코드

    - 무의미하고 무책임한 throws
        - 메소드 선언에 throws Exception을 기계적으로 붙임
        ```java
            public void method1() throws Exception {
                method2();
            }
            public void method2() throws Exception {
                method3();
            }
            public void method3() throws Exception {
                ...
            }
        ```
        
        - 남용하면 throw 선언이 의미없어져 버림.
        - 실행 중 정말 예외 상황이 발생할 수 밖에 없는 메소드인지 부르는(사용하는) 쪽에선 알수 없게 되어버림

>[!important] 예외를 처리하는 핵심원칙
>모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.

### 4.1.2. 예외의 종류와 특징

- 어떻게 처리해야 하는가? 오랫동안 논쟁이 되온 부분
    
- 특히 체크 예외(cheched exception)의 명시적으로 처리가 필요한 예외를 다루는 방법이 큰 이슈였음
    
- 예외는 크게 3가지 종류 Error, 체크예외, 언체크예외 
    
    - Error
        
        - java.lang.Error 클래스와 그 서브 클래스
        - VM에서 비정상적인 상황 발생할 경우
        - 애플리케이션에서 해결할 수 없는 상황인 경우(OutOfMemoryError ThreadDeath 등)
        - 개발자가 신경쓰지 않아도 됨
        
        284p
        [![Exception의 2가지 종류](https://github.com/PilhwanKim/toby_spring_practice/raw/master/chapter04/images/4-1.PNG)](https://github.com/PilhwanKim/toby_spring_practice/blob/master/chapter04/images/4-1.PNG)
		    
        - java.lang.Exception 클래스와 그 서브 클래스
        - 애플리케이션 코드 작업중에 예외상황이 발생할 경우에 사용

        - 다시 체크예외와 언체크 예외로 나뉨

	- ### **체크 예외(Checked Exception)란?**

		- **컴파일러가 예외 처리를 강제하는 예외**
		- 예상할 수 있는 예외 , 미리 대비할 수 있는 예외
		- 예외가 발생할 가능성이 있는 메서드는 반드시 `try-catch`로 잡거나 `throws`로 던져야 함
		- 주로 **파일 I/O, 네트워크, DB 관련 예외** 등이 포함됨

	- ### **런타임 예외(Runtime Exception), 언체크 예외 란?**

		- **컴파일러가 예외 처리를 강제하지 않는 예외**
		- 개발자가 부주의하면 발생할 수 있는 예외 → 미리 조건을 체크하면 피할 수 있음
		- 주로 **NullPointerException, IndexOutOfBoundsException, ArithmeticException** 등이 있음

	- ### **체크 예외가 논란이 되는 이유**

		자바 초창기에는 **예상 가능한 예외 상황을 체크 예외로 강제**했다고함.  
		즉, **"예외 처리를 강제하면 버그를 줄일 수 있을 거야!"** 라는 생각.
		
		하지만 현실에서는 오히려 **개발자들이 불필요한 코드(예외 블랙홀, throws 남발)를 작성하게 만들었음**.
		
	### **최근 트렌드: 체크 예외 줄이기**
	
	 **새로운 자바 표준 API들은 체크 예외를 잘 사용하지 않음**  
	 예상 가능한 예외라도 **체크 예외가 아닌 런타임 예외로 처리하는 경향**이 있음  
	 예를 들어, **자바의 스트림 API**는 예외를 체크 예외로 강제하지 않음

>[!note] 결론
>**체크 예외는 개발자가 실수를 줄이게 하려는 의도로 도입됨**  
 -> **하지만 현실에서는 오히려 개발자들이 불필요한 코드(throws 남발, 예외 블랙홀)를 작성하는 부작용이 발생**  
 그래서 **최근에는 체크 예외를 줄이고, 런타임 예외를 활용하는 방향으로 가고 있음**  
 하지만 **DB, 네트워크, 파일 I/O 같은 중요한 예외는 여전히 체크 예외로 남아 있음**

즉, **체크 예외는 신중하게 사용해야 하고, 무조건 남발하는 건 피해야 함!**

### 4.1.3. 예외처리 방법 크게 3가지방법이 있다고 한다. 

###### 첫 번째 예외처리 방법은 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다.

- 예외 복구
    - 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
    - 예1) 사용자가 요청한 파일을 읽으려고 시도했는데 해당 파일이 없다거나 다른 문제가 있어 IOException이 발생
        - 사용자에게 다른 파일을 이용하도록 안내함
    - 예2) 네트워크가 불안해서 가끔 접속이 안되는 시스템. 원격DB 서버 접속 실패해서 SQLException이 발생한 경우
        - 일정 시간 대기후 접속 재시도. 이것을 정해진 횟수만큼 시도. 실패했다면 복구 포기

```java
    int maxretry = MAX_RETRY;
    while(maxretry -- >0) {
        try {
            ...     // 예외가 발생할 가능성이 있는 시도
            return; // 작업 성공
        catch(SomeException e) {
            // 로그 출력. 정해진 시간만큼 대기
        finally {
            // 리소스 반납. 정리 작업
        }
        throw new RetryFailedException(); // 최대 재시도 횟수를 넘기면 직접 예외 발생.
```

###### 두 번째 방법은 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것 이다.

- 예외 처리 회피
    - 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
    - throws문으로 선언해서 예외가 발생하면 알아서 던저지게 하거나 catch문으로 일단 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는 것(rethrow)
    - 자신이 사용하는 쪽에서 예외를 다루는게 최선의 방법일 때 사용

    - 예) JdbcTemplate에서 사용하는 콜백 오브젝트는 ResultSet이나 PrepareStatement 등을 이용해서 작업하다 발생하는 SQLException을 자신이 처리하지 않고 템플릿으로 던져버림
        
        - SQLException 처리는 콜백오브젝트의 역할이 아니라 템플릿의 역할이라고 생각하기 때문
    - 이와같이 명확히 예외를 다루는 것이 자신이 사용하는 쪽에서 해야한다고 판단될때 써야한다.
        
###### 마지막으로 예외를 처리하는 방법은 예외 전환exception translation을 하는 것이다.

예외 회피 와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖 으로 던지는 것이다. 하지만 예외 회피와 달리, 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 특징이 있다.

- 예외 전환(exeception translation)
    - 발생한 예외를 그대로 넘기지 않고 적절한 예외로 전환해 던짐
        
    - 보통 2가지 목적으로 사용
        
        - 내부에 발생한 예외를 좀더 적절하고 분명한 의미를 가진 예외로 바꿔서 던지기 위해
            - 예) 새로운 사용자를 등록하려고 시도했을 때 아이디가 같은 사용자가 있어 DB에서 JDBC API의 SQLException 발생시킴. DAO에서는 이 정보를 좀더 의미있게 해석해서 SQLException에러를 잡아서 DuplicationUserIdException 같은 예외를 정의해서 던짐.
        - 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 것
            - 예외처리를 강제하는 체크예외를 언체크 예외(런타임 예외)로 바꾸는 경우
            - 대부분 서버환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰수 있는 기능을 제공함
            - 어차피 복구못할 예외라면 애플리케이션 코드에서는 런타임 예외로 포장해서 던지고 예외처리 서비스 등을 이용해 로그를 남기고, 관리자에게 메일로 통보, 사용자에게 안내 메시지를 보여주는 것이 바람직

    - 체크 예외를 언체크 예외로 포장해서 던짐(SQLException -> EJBException)
        

```java
    try {
        OrderHome orderHome = EJBHomeFactorY.getlnstance().getOrderHome();
        Order order = orderHome.findByPrimaryKey(Integer id);
    } catch (NamingException ne) (
        throw new EJBException(ne);
    } catch (SQLException se) (
        throw new EJBException(se);
    } catch (RemoteException re ) (
        throw new EJBException(re)
    }
```


### 4.1.4. 예외처리 전략

- 런타임 예외의 보편화
    
    - 일반적으로
        - 체크 예외 - 일반적 예외
        - 언체크 예외 - 시스템 장애나 프로그램상의 오류에 사용
        - 문제는 체크 예외는 복구할 가능성이 조금이라도 있 는, 말 그대로 예외적인 상황이기 때문에 자바는 이를 처리하는 catch 블록이나 throws 선언을 강제하고 있다는 점
    - 예외처리 강제
        - API 사용하는 개발자의 실수 방지를 위한 배려일수도 있지만
        - 예외를 다루고 싶지 않은 귀차니즘의 원인 일수도
    - 애플릿, AWT, 스윙 - 독립형 어플리케이션 에서는
        - 통제 불가능한 시스템 예외라도 애플리케이션의 작업이 중단되지 않게 해주고 상황을 최대한 복구해야한다.
        - GUI 애플리케이션(예: 데스크톱 프로그램, 그래픽 인터페이스 기반 소프트웨어)은 **사용자가 직접 조작하는 프로그램**이기 때문에

    - 자바 엔터프라이즈 서버 환경
        - 수많은 사용자 동시 요청을 처리해야 함
        - 각 요청은 독립적 작업
        - 하나의 요청 처리중 예외 발생시 해당 작업만 중단하면 됨
        - 예외 발생시 사용자와 커뮤니케이션 하면서 복구할 수 있는 수단이 없음
        - 예외 상황을 미리 파악하고, 예외가 발생치 않도록 차단하는 게 좋음
        - 빨리 요청의 작업 취소 후, 서버 관리자나 개발자에게 통보해야 함
        - 즉 체크예외는 점점 사용도가 떨어지고 있음
        - 대부분 런타임 예외로 처리하는 경향
        - 언체크라도 언제든지 예외를 catch로 잡을수도 있음. 즉 선택적이라 더더욱 런타임 에러로 처리



|              | 애플릿(Applet)           | AWT                   | 스윙(Swing)                |
| ------------ | --------------------- | --------------------- | ------------------------ |
| **역할**       | 웹 브라우저에서 실행되는 자바 프로그램 | OS의 네이티브 UI를 사용하는 GUI | 가벼운 GUI 프레임워크            |
| **패키지**      | `java.applet`         | `java.awt`            | `javax.swing`            |
| **특징**       | **보안 문제로 폐기됨**        | **운영체제에 따라 UI가 다름**   | **OS 독립적인 UI 제공**        |
| **현대 사용 여부** | 사용 안 함                | 거의 안 씀                | 사용 가능 (하지만 JavaFX가 대체 중) |
|              |                       |                       |                          |
- add() 메소드의 예외 처리 - 292 페이지

리스트 4-9에 나온 add() 메소드는 DuplicatedUserIdException과 SQLException, 두가 지의 체크 예외를 던지게 되어 있다.
```java
    public void add(User user) throws DuplicateUserIdException, SQLException {
        try {
            // JDBC를 이용해 user 정보를 DB에 추가하는 코드 또는
            // 그런 기능을 가진 다른 SQLException을 던지는 메소드를 호출하는 코드
        } catch(SQLException e) {
            // ErrorCode가 MySQL의 "Duplicate Entry(1062)"이면 예외 전환
            if (e.QetErrorCode() == MysQIErrorNumbers.ER_DUP_ENTRY)
                throw new DuplicateUserIdException();
        } else
            throw e; // 그 외의 경우는 SQLException 그대로
```

- SQLException 은 대부분 복구 불가능한 예외이므로 throws 를 계속 이어가게 해는 것 보다 런타임 예외로 포장해 주는 것이 좋다.
    
- DuplicateUserIdException 도 굳이 체크 예외로 둘 필요가 없음. 어디에서는 잡아 처리할 수 있기 때문.
    
- 다만 명시적으로 throws는 선언하는게 좋음. 그래야 add() 메소드를 사용하는 개발자에게 의미 있는 정보가 전달됨
    
- 둘다 언체크 에외로 변환시키면 다음과 같이 코드를 바꿔야 함
    
- DuplicateUserldException 을 런타임 예외로 구현
    
리스트 4-13
```java
  public class DuplicateUserldException extends RuntimeException {
      public DuplicateUserldException(Throwable cause) {
          super (cause);
      }
  }
```

이렇게 되면 둘다 언체크 예외로 변환시킨것이고 

메소드 선언의 throws에 포함 시킬 필요가 없다. 반면에 역시 언체크 예외로 만들어지긴 했지만 add() 메소드를 사용하는 쪽에서 아이디 중복 예외를 처리하고 싶은 경우 활용할 수 있음을 알려주도록 DuplicatedUserIdException을 메소드의 throws 선언에 포함시킨다.

```java
  public void add(User user) throws DuplicateUserIdException {
      try {
          // JDBC를 이용해 user 정보를 DB에 추가하는 코드 또는
          // 그런 기능을 가진 다른 SQLException을 던지는 메소드를 호출하는 코드
      } catch(SQLException e) {
          if (e.QetErrorCode() == MysQIErrorNumbers.ER_DUP_ENTRY)
              throw new DuplicateUserIdException(e); // 예외 전환
      } else
          throw new RuntimeException(e); // 예외 포장
```

** 기존 방식 (SQLException 직접 던짐) → 모든 SQL 오류가 SQLException으로 던져짐**  
** 개선 방식 (DuplicateUserIdException 사용) → "아이디 중복"이라는 의미를 명확히 전달**  
** 예외 처리를 강제하지 않으면서도, 필요할 때만 잡아서 처리할 수 있도록 함**

---
######  런타임 예외 중심의 전략은 굳이 이름을 붙이자면 낙관적인 예외처리 기법이라고 할 수 있다.

- 낙관적인 예외처리 기법
    
    - 복구할 수 있는 예외는 없다는 가정
    - 어짜피 시스템 레벨에서 알아서 처리
    - 꼭 필요한 경우는 런타임 예외라도 잡아서 복구함

- 비관적인 예외처리 기법
    - 일단 잡고 보도록 강제하는 체크 예외
	- **"혹시 놓치는 예외가 있을 수도 있으니, 컴파일러가 강제하도록 한다"**  
	- **"반드시 catch해서 대처하도록 만들어야 한다"**

- 애플리케이션 예외
    
    - 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고 반드시 catch해서 조치를 취하도록 요구하는 예외
    - 예제) 사용자가 요청한 금액을 은행계좌에서 출금하는 기능을 가진 메소드
        - 대략적인 로직
		- 현재 잔고 확인
		- 허용하는 범위를 넘어선 출금 요청시 출금작업 중단
		- 경고를 사용자에게 보냄


#### 애플리케이션 예외 vs 체크예외
	
애플리케이션 예외와 체크 예외는 개념적으로 비슷하지만, 정확히 일치 X!  
 **체크 예외(Checked Exception)**는 예외 처리 방식을 강제하는 "기술적인 개념"  
 **애플리케이션 예외**는 **비즈니스 로직상 반드시 처리해야 하는 예외**라는 "설계 개념"
	즉, **애플리케이션 예외는 보통 체크 예외로 구현되지만, 항상 그런 것은 아니다.**
	
- 메소드를 설계하는 2가지 방법
            
## **"메소드에서 예외 상황을 처리하는 두 가지 방법"**

### **1. 리턴 값을 이용하는 방법**

- 출금 메소드에서 정상적으로 출금되면 요청 금액을 그대로 반환하고,  
    잔액이 부족하면 `0`, `-1`, `-999` 같은 특별한 값을 반환하는 방식이야.
    
- 이 방식의 문제점:
    - **결과 값이 개발자마다 다를 수 있음** → 예외 상황의 리턴 값을 명확하게 정하지 않으면 혼란이 생길 수 있음.
    - **조건문 남발** → 호출하는 코드에서 `if` 문으로 결과를 체크해야 해서 코드가 지저분해질 가능성이 높음.

### **2. 예외(Exception)를 이용하는 방법**

- 출금 메소드는 정상적인 경우 그냥 진행하고,  
    잔고가 부족하면 `InsufficientBalanceException` 같은 예외를 던짐.
    
- 이 방식의 장점:
    - `try-catch` 블록을 사용해서 **예외 처리 코드를 별도로 분리**할 수 있음 → 코드가 깔끔해짐.
    - **체크 예외(Checked Exception)** 를 사용하면, 개발자가 예외 처리를 강제적으로 해야 해서 실수를 줄일 수 있음.

### **결론**

- 첫 번째 방법(리턴 값 사용)은 **유연하지만 코드가 복잡해질 위험**이 있고,
- 두 번째 방법(예외 사용)은 **코드를 더 깔끔하고 직관적으로 만들 수 있음.**
- 그래서 잔고 부족 같은 비즈니스 로직에서는 **예외를 사용하는 게 더 좋다**는 이야기임임.
            

### 4.1.5. SQLException은 어떻게 되었나?

- SQLException은 복구 가능한 예외인가?
    - 99%의 경우 코드 레벨에서 복구할 방법이 없음
    - 대부분의 발생이유
        - 프로그램의 오류 또는 개발자의 부주의
            - SQL 문법이 틀림
            - 제약조건 위반
        - 통제할 수 없는 외부상황
            - DB 서버 다운
            - 네트워크 불안정
            - DB 커넥션 풀이 꽉 참
    - 결국 관리자나 개발자에게 예외 발생을 알리는 방법 밖에 없음
    - SQLException을 잡아서 무언가 처리할 것이 거의 없음
    - 가능한한 의미있는 언체크/런타임 예외로 전환해서 던지는 것이 나음
    - 스프링은 JdbcTemplate에서 이와같은 예외처리 전략을 따름
        - **(중요!)SQLException을 런타임 예외 DataAccessException으로 포장해 던짐**
        - 스프링을 사용하는 측은 꼭 필요한 경우에만 catch 해서 처리하면 됨

`JdbcTemplate`은 자동으로 `SQLException`을 `DataAccessException`으로 변환한다

- **체크 예외인 `SQLException`을 강제로 처리할 필요가 없도록 스프링이 `DataAccessException`으로 변환해 준다.**
- 그래서 **DAO 메소드에서 `SQLException`이 사라진 것처럼 보이는 것**이고,  
    **개발자는 `try-catch` 남발 없이 더 깔끔하게 코드 작성 가능**.
- 스프링의 주요 API 예외는 대부분 런타임 예외로 설계되어 있어서  
    개발자가 **필요할 때만 예외를 잡아서 처리**하면 됨.

297p
## 4.2. 예외 전환

- 예외 전환의 목적은 2가지
    - 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를 줄여주는 것
    - 로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바뀌서 던져주는 것
- 스프링 JdbcTemplate이 던지는 DataAccessException의 목적
    - SQLException을 런타임 예외로 포장해서 대부분 복구 불가능한 예외를 catch 하는 것을 없애줌
    - SQLException에서 다루기 힘든 상세한 예외정보를 의미있고 일관성 있는 예외로 전환해서 추상화해줌
 
### 4.2.1. JDBC의 한계

- JDBC를 만든 취지
    - DB별로 같은 표준 API 인터페이스를 만들어서 서로 호환되게 함. 즉 DB만 바꿔도 동작되게
    - 개발자가 단 하나의 표준 API를 익힐수 있도록 도움

- 그러나.. 현실적인 한계가 몇가지 있다
    - 비표준 SQL
        
- ### **비표준 SQL 문제**

- **SQL 문법과 기능이 DBMS마다 다름.**
- ex) MySQL과 Oracle의 **페이지네이션(페이징 처리) SQL 문법이 다름.**

- ### **SQLException 의 호환성 문제**

- DB에서 오류가 발생하면 **DBMS마다 오류 코드가 다름.**
- 하지만 JDBC는 모든 DB 오류를 **SQLException하나로 처리**함.
- 따라서 오류의 원인을 확인하려면 **SQLException내부의 오류 코드와 상태 코드(SQL State)를 직접 확인해야 함.**

- JDBC는 DBMS 간 **호환성을 높이려는 목표**로 만들어졌지만,  
**비표준 SQL 문제**와 **`SQLException`의 호환성 문제** 때문에 한계가 있음.
    
- 이를 해결하기 위해 **Spring의 `JdbcTemplate`** 이나 **ORM(JPA, Hibernate)** 같은 기술을 활용하는 게 더 나은 방법!

## 스프링이 SQLException을 DataAccessException으로 변환하는 방법과 DB 에러 코드 매핑 전략

## **DataAccessException이란?**

- **스프링이 `SQLException`을 대체할 런타임 예외**.
    
- `SQLException`을 그대로 사용하면 **DB별로 에러 코드가 달라서** 예외 처리가 어렵기 때문에,  
    스프링은 **`DataAccessException`을 상속받은 여러 개의 서브클래스를 정의해서 사용**함.


### **2. DataAccessException의 서브클래스 (스프링이 예외를 세분화)**

|예외 클래스|설명|
|---|---|
|`BadSqlGrammarException`|SQL 문법 오류|
|`DataAccessResourceFailureException`|DB 커넥션을 가져올 수 없음|
|`DataIntegrityViolationException`|데이터 무결성(제약 조건) 위반|
|`DuplicateKeyException`|중복 키 예외|


--- 
## **DB별로 에러 코드가 다르다는 문제**

 **문제점**

- 예를 들어, MySQL과 Oracle에서 **중복 키 오류**가 발생하면 오류 코드가 다름.
- DB가 달라지면 예외를 처리하는 코드도 변경해야 함 → **DB 독립성이 사라짐**.

**해결책 (스프링의 에러 코드 매핑)**

- 스프링은 **DB별 에러 코드와 `DataAccessException` 서브클래스를 매핑한 테이블**을 내부적으로 가지고 있음.
- **즉, DB가 달라져도 같은 원인의 에러는 같은 예외(`DuplicateKeyException`)로 변환**됨.
- 개발자는 **DBMS에 상관없이 동일한 예외 처리를 할 수 있음**.

--- 
## **JdbcTemplate을 사용하면 예외 포장 코드가 필요 없다**

- `JdbcTemplate`을 사용하면 **체크 예외인 `SQLException`을 자동으로 런타임 예외(`DataAccessException`)로 변환**함.
    
- 따라서 **별도로 예외 포장 코드를 작성할 필요 없음**.

---
## **체크 예외로 변환하는 방법 (직접 예외를 정의)**

- 만약 **중복 키 예외를 체크 예외(Checked Exception)로 강제하고 싶다면**,  
    `DuplicateUserIdException` 같은 예외 클래스를 직접 만들고 다시 포장하면 됨.


---
## 결론!

**스프링은 DB별 에러 코드를 자동으로 매핑해 DataAccessException의 서브클래스로 변환한다.**  

 **덕분에 DB가 바뀌어도 같은 종류의 에러는 같은 예외로 변환되므로, DB에 독립적인 예외 처리가 가능해진다.**  
 **필요하면 직접 예외를 정의해서 체크 예외로 만들 수도 있다.**

---
### 4.2.3. DAO 인터페이스와 DataAccessException 계층구조

## **DataAccessException은 JDBC 전용이 아니다!**

- DataAccessException은 **JDBC뿐만 아니라 JPA, Hibernate, MyBatis 등 모든 데이터 액세스 기술에서 발생하는 예외를 처리하기 위해 설계됨**.
    
- 즉, **데이터 액세스 기술과 상관없이 일관된 예외를 받을 수 있도록 함**.
    
- ## **DAO를 인터페이스로 분리하는 이유**

DAO(Data Access Object)는 **데이터베이스와의 직접적인 통신을 담당하는 객체**야.  
DAO를 인터페이스로 분리하는 이유는 다음과 같아:

1. **데이터 액세스 코드와 비즈니스 로직을 분리하기 위해**  
    → DAO의 구현 방식이 바뀌어도 비즈니스 로직에는 영향이 없도록.
    
2. **전략 패턴(Strategy Pattern) 적용 가능**  
    → JDBC, JPA, Hibernate 등 다양한 데이터 액세스 기술로 교체 가능.
    
3. **DAO를 사용하는 클라이언트(UserService 같은 서비스 계층)가 내부 구현을 몰라도 되도록**  
    → DAO의 내부 구현이 어떤 데이터베이스 기술을 사용하는지 몰라도 호출할 수 있어야 함.
    

```java
    public interface UserDao {
        public void add(User user); //이렇게 선언하는 것이 가능한가?
    }
```

- 문제는 예외가 기술 독립적으로 인터페이스 선언 하지 못하도록 되어있다.

```java
    public void add(User user) throws PersistentException // JPA
    public void add(User user) throws PersistentException // Hibernate
    public void add(User user) throws PersistentException // JDO
    ...
```

- 해결책이 있을까?
    
    - throw Exception으로 다 바꾼다?
        - 무책임한 선언이다.

**해결책: 예외를 런타임 예외로 변환**

1. **JPA, Hibernate, JDO는 이미 런타임 예외 사용**  
    → `throws` 선언이 필요 없음.
    
2. **JDBC의 `SQLException`은 체크 예외이므로 `DataAccessException`으로 변환**  
    → `JdbcTemplate`을 사용하면 자동으로 변환됨.
    
3. **DAO 인터페이스에서 예외를 선언할 필요가 없어짐!**
    - 그러나, 모든 예외를 다 무시해야 하는 것은 아님. 애플리케이션에서는 사용하지 않더라도 시스템 레벨에서 데이터 엑세스 예외를 의미 있게 분류할 필요 있음


- ## **스프링의 DataAccessException 계층구조**

스프링은 **각 기술(JDBC, Hibernate, JPA 등)에서 발생하는 예외를 `DataAccessException` 계층 구조로 통합**해 줘.

|예외 클래스|설명|
|---|---|
|`DataAccessException`|최상위 예외 (모든 데이터 액세스 관련 예외의 부모)|
|`InvalidDataAccessResourceUsageException`|데이터 액세스 기술을 잘못 사용|
|`BadSqlGrammarException`|SQL 문법 오류 (JDBC)|
|`HibernateQueryException`|Hibernate 쿼리 오류|
|`TypeMismatchDataAccessException`|타입 불일치 예외|

→ **즉, DB 액세스 기술이 달라져도 같은 종류의 에러는 같은 예외로 변환되므로, DAO를 교체해도 클라이언트 코드에 영향을 주지 않음.**

#### 결론적으로

**DAO를 인터페이스로 만들면 데이터 액세스 기술(JDBC, JPA 등)이 바뀌어도 코드가 유지될 수 있다.**  
**JDBC처럼 체크 예외를 던지는 기술은 `DataAccessException`으로 변환하면 인터페이스에서 예외를 선언할 필요가 없다.**  
**스프링은 다양한 데이터 액세스 기술의 예외를 `DataAccessException` 계층으로 통합하여 일관된 방식으로 예외를 처리할 수 있도록 해준다.**

### 4.2.4. 기술에 독립적인 UesrDao 만들기

## **1. 인터페이스 적용**

**왜 DAO를 인터페이스로 분리해야 할까?**  
→ DAO의 **구현 기술을 바꿔도 서비스 계층 코드(UserService 등)에 영향을 주지 않도록 하기 위해서**!

### **인터페이스 명명법**

DAO 인터페이스를 만들 때 두 가지 방법이 있어:

1. **"I" 접두어를 붙이는 방법**
    - 예) `IUserDao`, `IOrderDao`
        
2. **인터페이스는 단순한 이름을 쓰고, 구현체에 기술적인 특징을 붙이는 방법**
    - 예) `UserDao` (인터페이스), `UserDaoJdbc` (JDBC 구현체), `UserDaoHibernate` (Hibernate 구현체)

테스트 보완, `DataAccessException`을 활용한 예외 테스트 등이 나오고 한번 읽어보고

    
## **DataAccessException 활용 시 주의할 점**

스프링이 `SQLException`을 `DataAccessException` 계층으로 변환해주지만, **완벽하게 기술 독립적인 건 아님!**

그 이유는 ->  DB 종류나 데이터 액세스 기술(JDBC, Hibernate 등)에 따라 **예외가 다르게 변환될 수 때문**
그래서 기술별 예외 매핑을 미리 확인하는 학습 테스트를 만들어야 함.

## **학습 테스트 코드**

 **"학습 테스트란?"**  
새로운 기술을 사용할 때, **어떤 동작을 하는지 미리 확인하는 테스트 코드**를 작성하는 것.

**이렇게 학습 테스트를 하면?**

- **각 기술이 어떤 예외를 던지는지 미리 파악 가능**
    
- **DAO를 교체할 때 예외가 달라질 가능성이 있는지 확인 가능**

## 4.3. 정리
  

- 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험하다.
- 예외는 복구하거나, 예외처리 오브젝트로 의도적으로 전달하거나, 적절한 예외로 전환해야 한다.
- 좀 더 의미 있는 예외로 변경하거나, 불필요한 catch/throws를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다.
- 복구할 수 없는 예외는 가능한 빨리 런타임 예외로 전환하는 것이 바람직하다.
- 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다.
- JDBC의 SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.
- SQLExcetion의 에러 코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있다.
- 스프링은 DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다.
- DAO를 데이터 엑세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요하다.