```table-of-contents
```
## 들어가기 전에
- 스프링을 이용해 애플리케이션 프로젝트를 처음 구성할 때 알아야 할 기본적인 내용을 다룰 것
## 9.1 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션
- 자바 엔터프라이즈 애플리케이션은 서버에서 동작하며 클라이언트를 상대로 서비스를 제공하도록 되어 있음
	-> 클라이언트의 요청을 받아서 그에 대한 작업을 수행하고 그 결과를 돌려주는 것이 기본적인 동작 방식
- 클라이언트의 요청 없이도 정해진 시간이나 특정 이벤트 발생에 따라 독자적으로 작업을 수행하기도 함
### 9.1.1 클라이언트와 백엔드 시스템
- 엔터프라이즈 애플리케이션은 자신이 클라이언트가 돼서 또 다른 엔터프라이즈 시스템에 서비스를 요청할 수도 있고 데이터베이스나 레거시 시스템 같은 엔터프라이즈 정보 시스템이라고 불리는 백엔드 시스템의 기능을 이용해 동작하기도 함
- 가장 많이 사용하는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성
- 나머지는 읽어보면 좋을 듯
### 9.1.2 애플리케이션 서버
- 스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버가 필요
- 크게 두 가지로 구분 -> WAS || 경량급 WAS 또는 서블릿/JSP 컨테이너
##### 경량급 WAS/ 서블릿 컨테이너
- 스프링은 기본적으로 톰캣이나 제티 같은 가벼운 서블릿 컨테이너만 있어도 충분
- EJB나 리소스 커넥터, WAS가 제공하는 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심 기능을 모두 이용 가능
##### WAS
- 미션 크리티컬한 시스템에서 요구하는 고도의 안정성이나 고성능 시스템에서 필수적인 안정적인 리소스 관리, 레거시 시스템의 연동이나 기존 EJB로 개발된 모듈을 함께 사용하는 등의 필요가 있을 때는 상용 또는 오픈소스 WAS를 이용할 수 있음
- WAS는 상대적으로 관리 기능이나 모니터링 기능이 뛰어나서 여러 대의 서버를 동시에 운영할 때 강점이 있음
- JavaEE 표준을 최대한 활용할 수 있음
-> 스프링 개발팀은 필요할 경우 비용을 들이더라도 적합한 조건을 가진 WAS를 사용할 것을 권장함. 물론 WAS를 사용할 때는 분명한 이유와 근거가 있는지 충분히 검토해야 하며 훨씬 가볍고 빠르며 저렴한 비용으로 사용할 수 있는 서블릿 컨테이너로도 대개는 충분한데 타당한 이유없이 WAS를 사용할 필요는 없다.
##### 스프링소스 tcServer
- 실제로 개발 환경과 운영 환경에서 가장 많이 사용되는 자바 서버는 웹 모듈만 지원하는 서블릿 컨테이너인 아파치 톰캣
- 톰캣 전문가들이 톰캣을 기반으로 엔터프라이즈 스프링 애플리케이션에 최적화된 경량급 애플리케이션 서버인 tcServer를 개발
- tcServer를 이용하면 기존 톰캣에서 아쉬웠던 고급 서버 관리 기능, 배포 기능과 진단 기능을 포함해서 톰캣 전문가에게 받는 기술 지원도 함께 받을 수 있음
- 가장 큰 장점은 스프링 개발 회사가 개발하는 것인 만큼 애플리케이션 개발과 운영에 꼭 필요한 중요한 기능이 많이 제공됨
### 9.1.3 스프링 애플리케이션의 배포 단위
- 스프링으로 만든 애플리케이션은 다음의 세 가지 단위로 배포 가능
1. 독립 웹 모듈
	- 스프링은 보통 war로 패키징된 독립 웹 모듈로 배포됨 -> 요즘은 jar 많이 쓰지 않나?
2. JAR(Java Archive)
	- 자바 애플리케이션에서 가장 기본적이고 널리 사용되는 패키징 포캣
	- Java 클래스 파일과 관련 메타데이터, 리소스(이미지, 속성 파일 등)를 하나의 파일로 패키징한 압축 파일 형식
3. 엔터프라이즈 애플리케이션
	- 경우에 따라 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해서 배포할 수도 있음
4. 백그라운드 서비스 모듈
	- rar 패키징 방법도 있음
## 9.2 개발도구와 환경
- 읽어보면 될 듯
## 9.3 애플리케이션 아키텍처
### 9.3.1 계층형 아키텍처
##### 아키텍처와 SoC
- 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 **계층형 아키텍처(Layered Architecture)** 라고 부름
	-> 멀티 티어 아키텍처라고도 함
- 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3계층 애플리케이션이라고도 하지만 꼭 3계층으로 해야하는 건 아님
##### 3계층 아키텍처와 수직 계층
![](https://i.imgur.com/llJ5Tm5.png)
1. 데이터 액세스 계층
	- DAO 계층이라고도 불림
	- 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임
2. 서비스 계층
	- 비즈니스 로직의 핵심을 담고 있는 부분
	- POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 테스트가 쉬워지고 확장에도 유연해짐
3. 프레젠테이션 계층
	- 가장 복잡한 계층
	- 매우 다양한 기술과 프레임워크의 조합을 가질 수 있음
	- 다른 계층과 달리 클라이언트까지 그 범위가 확장될 수도 있음
	- 클라이언트는 단순히 서버 프레젠테이션 계층의 기능에 대한 사용자 인터페이스에 불과했지만 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있음
##### 계층형 아키텍처 설계의 원칙
- 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지해야 함
	-> 각 계층은 자신의 계층의 책임에만 충실해야 함
### 9.3.2 애플리케이션 정보 아키텍처
- 엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템
- 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지하고 애플리케이션의 주요 상태 정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다.
- 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 것은 아키텍처를 결정할 때 매우 중요한 기준이 됨
	-> 데이터로 다루는 경우와 오브젝트로 다루는 경우 두 가지 기준으로 구분 가능
##### DB/SQL 중심의 로직 구현 방식
- 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있음
	-> 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경됨
- 종속적일 뿐 아니라 배타적이어서 다른 단위 업무에 재사용되기 힘듦
- 대용량 데이터를 다루면서 빠른 처리가 필요한 경우에는 일부 로직을 DB 내에 존재하는 PL/SQL과 같은 저장 프로시저 형태로 만들기도 함
- 대부분의 코드는 대응되는 작업 단위에 1:1로 매핑됨
	-> 여러 작업에서 반복되는 기능이 있다면 그에 대한 코드는 중복되기 쉬움
	![](https://i.imgur.com/Sa4oACQ.png)
- 개발하기 쉽다는 장점
- 각 업무의 핵심을 담은 SQL을 중심으로 DAO부터 사용자가 보는 화면까지 한 벌씩 만들면 되기 때문에 툴이나 코드 생성기를 이용해서 자동화하는 데도 유리
- 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시킴
	-> 자바의 오브젝트는 단지  HTTP 서비스 채널을 만들어주고 JDBC를 이용해 DB 기능을 사용하게 하는 스크립트 정도로 역할이 축소됨
- 이런 개발 방식은 변화에 매우 취약함
	-> 객체지향의 장점이 별로 활용되지 않고 각 계층의 코드가 긴밀하게 연결되어 있기 때문
- 상대적으로 애플리케이션 서버와 그 안에 담긴 오브젝트는 비용이적게 들고 서버를 쉽게 확장 가능
	-> 로직을 DB보다는 애플리케이션으로 가져오는 편이 유리한 점이 많음(비용이 저렴해지고 안정성이 높아지며 코드를 검증하기 편해짐)
##### 거대한 서비스 계층 방식
- 서비스 계층 코드의 책임이 커짐 -> 비즈니스 로직이 복잡해지면 서비스 계층의 코드가 매우 복잡해짐
### 9.3.3 오브젝트 중심 아키텍처
- 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것
- 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용
	-> 대게 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성 높음
##### 데이터와 오브젝트(p.798)
- 데이터 중심의 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존함
- 도메인 분석을 통해 작성된 모델 정보는 DB에 대한 SQL을 작성할 때 외에는 코드에 반영되는 일이 없음
- 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담김
- 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 가짐
	-> 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채로 사용 가능
- SQL이나 웹 페이지의 출력 포맷, 입력 폼 등에 종속되지 않는 일관된 형식의 애플리케이션의 정보를 다룰 수 있게 됨 
- DB에서 SQL 결과로 가져온 값을 그대로 사용하는 경우와는 다르게, 도메인 모델을 반영하는 오브젝트를 사용하면 자바 언어의 특성을 최대한 활용할 수 있도록 정보를 가공 가능
	-> 대표적으로 오브젝트 사이의 관계를 자바에서는 레퍼런스 변수를 이용해서 다른 오브젝트를 참조하는 방식으로 직접 연결이 가능(RDB에서는 키의 조합을 통해 그때그때 테이블을 조인해서 의미 있는 관계를 만들어야 함)
##### 도메인 오브젝트를 사용하는 코드(p.802)
- 재사용 가능한 메서드
	-> 데이터 중심 방식에서는 이런 식의 재사용 가능한 메서드를 만들어 사용하기 쉽지 않음(코드 중복 발생)
##### 도메인 오브젝트 사용의 문제점
- 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 손해 감수해야 함
	-> DAO는 비즈니스 로직의 사용 방식을 알지 못하므로, 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분(낭비 발생)
- 오브젝트 관계 문제
	-> Product 정보만 필요한 상황이지만 관계를 가지고 있는 Category 오브젝트도 함께 담겨서 온다.(낭비, N+1 문제 같은 것)
- 단순한게 필요하지 않은 경우에는 null 값이 들어가게 하면 되지만 예상치 못한 NullPointerExcetpion 발생 가능성
##### 해결 방법
1. 지연된 로딩 기법
	: 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 동적으로 DB에서 읽어옴
2. 필드가 너무 많은 테이블이 있다면 그중에서 자주 사용되는 것을 골라내서 별도의 오브젝트로 정의해두고 필요에 따라 구분해서 사용
	-> 약하긴  하지만 계층 사이의 결합이 발생
3. 가장 이상적인 방법은 JPA나 하이버네이트 같은 ORM 기술을 사용하는 것
	-> 이런 데이터 액세스 기술은 기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 번거로운 코드를 만들지 않고도 도메인 오브젝트의 생성을 최적화할 수 있음
##### 빈약한 도메인 오브젝트 방식
- 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트라고 보기 힘듦 
	-> 이를 빈약한 오브젝트라고 부름
	-> 흔히 사용되는 방식
- **객체지향 프로그래밍의 본질 위배**:
    - 객체는 데이터와 행위(메서드)가 함께 캡슐화되어야 하는데, 빈약한 도메인 모델은 객체가 단순히 데이터 컨테이너(DTO)로만 사용됩니다.
    - 비즈니스 로직이 도메인 객체가 아닌 서비스 계층에 위치하게 됩니다.
- **비즈니스 로직의 분산**:
    - 관련된 비즈니스 로직이 여러 서비스 클래스에 흩어져 있어 코드 이해와 유지보수가 어려워집니다.
    - 동일한 도메인 개념에 대한 로직이 여러 곳에 중복될 위험이 높아집니다.
- **캡슐화 부족**:
    - 내부 상태를 보호하는 적절한 캡슐화가 이루어지지 않아 객체 상태가 쉽게 손상될 수 있습니다.
    - Getter/Setter 메서드를 통해 객체 내부 상태가 외부에 그대로 노출됩니다.
- **도메인 지식의 불명확한 표현**:
    - 도메인의 규칙과 제약조건이 객체 자체가 아닌 외부 코드에 표현되어 도메인 모델의 표현력이 떨어집니다.
    - 비즈니스 규칙과 로직이 코드 전반에 숨겨져 있어 도메인의 의도를 파악하기 어렵습니다.
- **테스트 어려움**:
    - 비즈니스 로직이 여러 서비스에 분산되어 있어 단위 테스트가 복잡해집니다.
    - 도메인 객체 자체를 테스트하기보다 서비스 계층을 테스트해야 합니다.
- **변경에 취약**:
    - 도메인 규칙이 변경될 때 여러 서비스 클래스를 수정해야 할 가능성이 높아집니다.
    - 응집도가 낮아져 한 곳의 변경이 여러 곳에 영향을 미칩니다.
- **확장성 제한**:
    - 새로운 기능이나 비즈니스 규칙을 추가할 때 기존 코드의 수정이 광범위하게 필요합니다.
- **객체 간 협력 모델의 부재**:
    - 풍부한 도메인 모델에서는 객체들이 서로 메시지를 주고받으며 협력하지만, 빈약한 도메인 모델에서는 이러한 객체 간 협력이 부족합니다.
##### 풍성한 도메인 오브젝트 방식
- 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것  
	-> 비즈니스 로직을 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것
- 도메인 오브젝트를 사용한다는 면에서 빈약한 도메인 오브젝트 방식과 비슷하지만, 실제 작성된 코드를 살펴보면 훨씬 간결하고 객체지향적
- 도메인 오브젝트에 비즈니스 로직을 넣더라도 비즈니스 로직을 담고 있던 서비스 계층은 여전히 필요하며 중요한 역할을 함
	-> 도메인 오브젝트 안에 메서드로 들어가는 로직들은 대부분 해당 오브젝트나, 긴밀한 연간관계를 맺고 있는 관련 오브젝트의 정보와 기능만을 활용
	-> 여러 종류의 도메인 오브젝트 기능을 조합해서 복잡한 비즈니스 로직을 만들었다면 이는 특정한 도메인 오브젝트에 넣기 힘들기 때문에 서비스 계층에 두는 것이 적당
	-> 도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 께층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요(빈이 아니기 때문에 DI를 받을 수 없음)  
- 충실한 도메인 모델링과 도메인 오브젝트 개발이 선행되고 그 내용이 개발자에게 사전에 충분히 공유되지 않았다면 차라리 데이터 구조만 오브젝트 방식으로 정의해놓은 빈약한 도메인 오브젝트 방식이 혼란을 피할수 있고 쉽게 접근할 수 있는 대안이 될 수 있음
	-> 처음은 쉬워도 시간이 지나고 시스템이 복잡해지면 빈약한 오브젝트 방식의 단점이 드러날것 
##### 도메인 계층 방식
- 도메인 계층의 역할과 비중을 극대화하기 위해 도메인 오브젝트를 기존 3계층과 같은 레벨로 격상시켜 하나의 계층을 이루게 하는 것
- 도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과 다른 두 가지 특징을 가짐
	1. 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행됨
	2. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있음
		-> 스프링이 관리하지 않는 오브젝트에도 DI를 적용하기 위해 추가적인 설정 필요(AOP 필요) 
- 도메인 오브젝트가 도메인 계층을 벗어나도 사용되게 할지 결정해야 함
	1. 여전히 모든 계층에서 도메인 오브젝트를 사용
		-> 가장 손쉽고 편한 방법으로 오브젝트 중심 아키텍처의 장점을 그대로 누릴 수 있음
		-> 비즈니스 로직을 담고 있는 메서드를 모든 곳에서 사용하게 하면 이를 함부로 사용하는 위험이 뒤따름 
	2. 도메인 오브젝튼은 도메인 계층을 벗어나지 못하게 함
		-> 도메인 게층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줌(DTO)
		-> DTO는 기능을 갖지 않으므로 사용하기 안전(도메인 오브젝트를 외부 계층의 코드로부터 보호해줌)
		-> 반면, 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를 따로 만들어야 하고 이를 매번 변환해줘야 하는 번거로움이 있음(AOP 같은 방법을 통해 자동으로 해주도록 만들어줘야 함)
![](https://i.imgur.com/Q10Le3n.png)
- 서비스를 제공하는 싱글톤으로 계속 존재하는 다른 계층의 오브젝트와 달리, 도메인 계층의 오브젝트는 독립적으로 도메인 계층을 이루는 오브젝트들이 생성됐다가 해당 요청을 처리하고 나면 버려짐
	-> 도메인 오브젝트는 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문
	-> DAO나 컨트롤러, 또는 스프링 외의 라이브러리를 통해 오브젝트가 만들어지는 경우가 많기 때문에 빈으로 등록조차 불가능
- 여러 가지 제약과 불편을 감수하면서라도 이 방식을 택해야 하는 경우는 매우 복잡하고 변경이 잦은 도메인을 가졌을 경우(그렇지 않다면 오버헤드) 
##### DTO와 리포트 쿼리
- 오브젝트 중심 아키텍처는 애플리케이션 내의 모든 정보를 항상 도메인 오브젝트에 담고 있지 않음
- 도메인 계층 방식의 경우 도메인 계층을 벗어난 정보를 DTO라 불리는 특정 계층에 종속되지 않는 정보 전달의 목적을 가진 단순 오브젝트에 담아 사용하기도 함
- 대표적으로 리포트 쿼리라 불리는 DB 쿼리의 실행 결과를 담는 경우가 있음  
### 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계
##### 계층형 아키텍처
- 3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조
- 스프링의 주요 모듈과 기술을 살펴보면 3계층 구조에 적합하도록 설계되어 있다고 함
- 약간의 변동이 있을 수 있음(계층 통합, 세분화 등) 
- 프레젠테이션 계층은 보통 MVC 패턴을 주로 사용
##### 정보 전송 아키텍처
- 스프링 기본 기술에 가장 맞고 쉽게 적용해볼 수 있음
- 도메인 오브젝트를 계층 간의 정보 전송을 위해 사용하고, 이를 각 계층의 코드에서 활용
- 도메인 오브젝트를 사용해 애플리케이션의 정보를 일관된 형태로 유지하는게 스프링에 가장 맞는 방식
##### 상태 관리와 빈 스코프
- 엔터프라이즈 애플리케이션은특정 사용자가 독점해서 배타적으로 사용되지 않음
	-> 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하게 하기 위해 매번 간단한 요청을 받아서 그 겨로가를 돌려주는 방식으로 동작
	-> 서버의 자원이 특정 사용자에게 일정하게 할당되지 않음
	-> 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않음
- 클라이언트로부터의 요청을 처리하는 매우 짧은 시간 동안만 도메인 오브젝트와 같은 정보 저장소에 현재 상태 정보가 보관되지만, 이는 요청 결과를 클라이언트에 돌려주고 나면 바로 폐기됨
	-> 이를 통해 수많은 동시 사용자의 요청을 제한된 서버 리소스를 가지고 처리 가능
- 하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업 정보는 유지돼야 하는데 이를 위해서 웹 클라이언트에 URL, 파라미터, 폼 히든 필드, 쿠키 등을 이용해 상태 정보 또는 서버에 저장된 상태 정보에 키 값 등을 전달해야 함
	-> 클라이언트와 서버 사이에서 많은 양의 정보를 계속해서 주고 받을 수는 없으므로 중요한 상태 정보는 파일시스템, 데이터그리드, DB 등에 저장되기도 함
- 스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장
- 상태는 클라이언트, 백엔드에 저장해두거나 서블릿의 HTTP  세션 정도에 일시적으로 저장해두는 것이 대부분이지만 경우에 따라서는 장시간 유지되며 중첩될 수 있는 상태를 다루는 고급 상태 관리 기법을 이용할 수 있음
- 스프링에서는 싱글톤 외에도 다른 스코프를 갖는 빈을 간단히 만들 수 있음
##### 서드파티 프레임워크, 라이브러리 적용
- 읽어보자