> [!important] 스프링의 3대 핵심 기술
> 1. IoC/DI
> 2. 서비스 추상화
> 3. AOP

- 스프링의 모든 기술은 결국 **객체지향 언어의 장점을 적극적으로 활용**해서 코드를 작성하도록 도와주는 것

> [!cite] 7장에서는..
> 스프링의 개발철학, 추구하는 가치, 스프링 사용자에게 요구되는 것이 무엇인지 살펴본다.
## 1. SQL과 DAO의 분리
UserDao를 많이 개선해왔지만, 한 가지를 더 개선해보려고 한다.
- [>] **SQL을 DAO에서 분리**하기
	- SQL의 변경 작업이 빈번히 일어나는데, 그 때마다 DAO 코드 수정 후 다시 컴파일하는 건 *번거로울 뿐만 아니라 위험하다.*
### 1.1. XML 설정을 이용한 분리
- 가장 손쉽게 생각해볼 수 있는 SQL 분리 방법
#### 개별 SQL 프로퍼티 방식
- SQL은 문자열로 되어있으니 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입해줄 수 있다.
- [!] 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고 DI를 위한 변수, Setter도 만들어줘야 한다.
#### SQL 맵 프로퍼티 방식
- SQL을 하나의 컬렉션(Map)으로 담아두는 방식
- 새로운 SQL이 필요할 때 설정에 \<entry>만 추가해주면 된다.
	- [p] 작업량도 적고, 코드도 간단하다.
	- [c] 오타와 같은 실수가 있다면 해당 메소드가 실행되기 전에는 오류를 확인하기 힘들다.
### 1.2 SQL 제공 서비스
- SQL과 DI 설정정보가 섞여있으면 보기에도 지저분하고 **관리하기도 어렵다.**
- SQL을 꼭 스프링의 빈 설정 방법을 사용해 **XML에 담아둘 이유도 없다.**
- 스프링의 생성파일로부터 생성된 오브젝트와 정보는 애플리케이션을 **다시 시작하기 전에는 변경이 매우 어렵다.**

> [!todo] 이런 문제점을 해결하려면?
> DAO가 사용할 **SQL을 제공해주는 기능을 독립**시키면 된다.
> SQL 제공 기능을 본격적으로 분리해서 다양한 SQL 정보 소스를 사용할 수 있고, 운영 중에 동적으로 갱신도 가능한 **유연하고 확장성이 뛰어난 SQL 서비스**를 만들어보자.
#### SQL 서비스 인터페이스
- 가장 먼저 할 일은 SQL 서비스의 인터페이스를 설계하는 것이다.
- 인터페이스의 이름은 `SqlService`
#### 스프링 설정을 사용하는 단순 SQL 서비스
- 일단 가장 간단한 방법으로 `SqlService`를 구현한다.
	- Map 타입 프로퍼티를 추가하고,
	- Map에서 SQL을 읽어서 돌려주도록 `getSql()`을 구현한다.
- 코드나 설정만 놓고 보자면 앞에서 사용했던 [[#SQL 맵 프로퍼티 방식]]과 별로 다를 게 없어 보인다.
	- 사실 큰 차이가 존재하는데, **모든 DAO는 이제 SQL을 어디에 저장해두고 가져오는 지**에 대해 **전혀 신경 쓰지 않아도 된다**는 차이가 있다.
	- 구체적인 구현 방법과 기술에 상관없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다.

---
## 2. 인터페이스 분리와 자기참조 빈
이제 `SqlService` 인터페이스의 구현 방법을 발전시켜 보고자 한다.
### 2.1. XML 파일 매핑
- 스프링의 XML 설정파일에서 \<bean> 태그 안에 SQL 정보를 넣어놓고 활용하는 건 좋은 방법이 아니다.
- [f] **SQL을 저장해두는 전용 포맷을 가진 독립적인 파일을 이용**하는 것이 바람직하다.
#### JAXB
> [!tldr] JAXB(Java Architecture for XML Binding)란?
> 개발자가 XML 처리 세부 사항을 알지 않고도 XML 데이터에 접근하고 처리할 수 있도록 하여 XML 작업을 단순화하는 자바 기술
- XML에 담긴 정보를 파일에서 읽어오는 방법은 다양한데, 여기서는 JAXB를 이용했다.
###### 언마샬링(unmarshalling)
- XML 문서 -> 자바 오브젝트로 변환
###### 마샬링(marshalling)
- 바인딩 오브젝트 -> XML 문서로 변환
### 2.2. XML 파일을 이용하는 SQL 서비스
- [[#JAXB]]를 이용해서 SQL 문장을 스프링의 빈 설정에서 완벽하게 분리했다.
- 독자적인 스키마를 갖는 깔끔한 XML 문서이므로
	1. 작성하고 검증하기에도 편리하고
	2. 필요하다면 다른 툴에서도 불러서 사용할 수 있다.
### 2.3. 빈의 초기화 작업
- 생성자에서 예외가 발생할 수도 있는 복잡한 초기화 작업을 다루는 것은 좋지 않으므로 개선이 필요하다.
	- [>] 초기 상태를 가진 오브젝트를 만들어놓고 별도의 초기화 메소드를 사용하는 방법이 바람직하다.
	- `@PostConstruct` 어노테이션을 단 메소드를 사용해 이 부분을 해결했다.

> [!important] @PostConstruct란?
> 빈 오브젝트의 초기화 메소드를 지정하는 데 사용하는 어노테이션.
> `@PostConstruct`를 초기화 작업을 수행할 메소드에 부여해주면 스프링은 빈의 오브젝트를 생성하고 DI 작업을 마친 뒤에 `@PostConstruct`가 붙은 메소드를 자동으로 실행해준다.
### 2.4. 변화를 위한 준비 : 인터페이스 분리
- 이제 스프링의 유연한 확장 구조를 위해 더욱 개선해본다.
- XML 대신 **다른 포맷의 파일에서 SQL을 읽어오게 하려면 어떻게 해야 하는가?**
#### 책임에 따른 인터페이스 정의
- 가장 먼저 할 일은 분리 가능한 관심사를 구분하는 것
	1. SQL 정보를 **외부의 리소스로부터 읽어오는** 책임
	2. 읽어온 SQL을 **보관해두고 있다가 필요할 때 제공**해주는 책임
	3. (부가적으로..) 한 번 가져온 SQL을 필요에 따라 수정할 수 있게 하는 책임

![](https://i.imgur.com/GtFxsi9.png)
- `SqlService`의 구현 클래스가 변경 가능한 책임을 가진 `SqlReader`와 `SqlRegistry` 두 가지 타입의 오브젝트를 사용하도록 변경
- 당연히 인터페이스를 이용하게 하고, DI를 통해 의존 오브젝트를 제공받게 해야 함
- [?] 그런데.. `SqlReader`가 읽어오는 SQL 정보는 다시 `SqlRegistry`에 전달해서 등록되어야 하는데, 어떻게 해야 하는가?

![](https://i.imgur.com/XNynXEJ.png)
- `SqlReader`에게 `SqlRegistry` 전략을 제공해주면서 이를 이용해 SQL 정보를 `SqlRegistry`에 저장하라고 요청하면 된다.
	- 일종의 **콜백 오브젝트처럼 사용된다고 생각**해도 된다.
### 2.5. 자기참조 빈으로 시작하기
#### 다중 인터페이스 구현과 간접 참조
- 인터페이스는 **한 클래스에서 하나 이상을 구현**할 수 있다.
- 하나의 클래스가 여러 개의 인터페이스를 상속해서 여러 종류의 타입으로서 존재할 수 있는 것이다.
![](https://i.imgur.com/MH4NH1i.png)
- 기존 `XmlSqlService`는 3가지 책임을 모두 갖고 있는 클래스였다. 따라서 이 3개의 인터페이스를 구현하도록 만드는 건 어렵지 않다.
#### 인터페이스를 이용한 분리
- 이제 ==그림 7-6==을 실제로 구현해보자.
- 여기서 주의해야 할 점은..
	1. `sqlMap`은 `SqlRegistry` 구현의 일부가 됐으므로 `SqlRegistry` 구현 메소드가 아닌 메소드에서는 직접 사용해서는 안된다.
	2. `SqlReader`를 구현한 코드에서 `XmlSqlService` 내의 다른 변수와 메소드를 직접 참조하거나 사용하면 안된다.
	3. `SqlReader` 구현 코드에서 `SqlService` 구현 코드로 내부 정보에 접근하거나 하면 안된다.
- 같은 클래스 안에 구현된 내용이긴 하지만 `SqlService`의 메소드에서 SQL을 읽을 때는 `SqlReader`를, SQL을 찾을 때는 `SqlRegistry` 인터페이스를 통해 간접적으로 접근하게 만들었다.
#### 자기참조 빈 설정
- 빈 설정을 통해 실제 DI가 일어나도록 해야 한다.
- 클래스는 하나뿐이고 빈도 하나만 등록할 것이지만, **마치 3개의 빈이 등록된 것처럼** `SqlService` 빈이 `SqlRegistry`와 `SqlReader`를 주입받도록 해야한다.
```xml
<bean id="sqlService" class="springbook.user.sqlservice.XmlSqlService">
	<property name="sqlReader" ref="sqlService" />
	<property name="sqlRegistry" ref="sqlService" />
	<property name="sqlmapFile" ref="sqlService" />
</bean>
```
- 프로퍼티는 자기 자신을 참조(ref)할 수 있다.
- 이를 통해, `sqlService`를 구현한 메소드와 초기화 메소드는 **외부에서 DI된 오브젝트라고 생각하고 결국 자신의 메소드에 접근**한다.
	- ["] 인터페이스 + DI를 이용하면 이런 특별한 구조까지도 유연하게 구성 가능하다.
- 자기 자신을 참조하는 빈은 사실 흔히 쓰이지는 않는다.
	- 책임이 다르다면 클래스를 구분하고 각기 다른 오브젝트로 만들어지는 것이 자연스럽다.
	- 다만 책임과 관심사가 복잡하게 얽혀있어서 **확장이 힘들고 변경에 취약한 구조의 클래스를 유연하게 만들고자 할 때** 처음 시도해볼 수 있는 방법이다.
### 2.6. 디폴트 의존관계
- 확장 가능한 인터페이스를 **완전히 분리해두고 DI로 조합해서 사용**하게 만드는 단계
- 디폴트 의존 오브젝트와 값을 이용해,
	1. 설정을 간단하게 해주고
	2. 미리 준비된 기능을 손쉽게 사용할 수 있으면서도
	3. 필요한 부분은 언제든지 확장 가능한 구조를 갖는 빈을 만들 수 있다.

> 한번 읽어보기

---
## 3. 서비스 추상화 적용
`JaxbXmlSqlReader`는 좀 더 개선하고 발전시킬 부분이 있다.
1. 자바에는 [[#JAXB]] 외에도 다양한 XML과 자바 오브젝트를 매핑하는 기술이 있다.
	- [ ] 필요에 따라 다른 기술로 손쉽게 바꿔서 사용할 수 있게 해야 한다.
2. XML 파일을 좀 더 다양한 소스에서 가져올 수 있게 만든다.
	- [l] 현재는 UserDao 클래스와 같은 클래스패스 안에서만 XML을 읽어올 수 있다.
	- [>] 이것을 임의 클래스패스나 파일 시스템 상의 절대 위치, 또는 HTTP 프로토콜을 통해 원격으로 가져오도록 확장할 수는 없는가?
### 3.1. OXM 서비스 추상화
[[#JAXB]] 외에도 실전에서 자주 사용되는 XML과 자바 오브젝트 매핑 기술이 있다.
1. **Castor XML** : 설정파일이 필요없는 인트로스펙션 모드를 지원하기도 하는 매우 간결하고 가벼운 바인딩 프레임워크
2. **JiBX** : 뛰어난 퍼포먼스를 자랑하는 XML 바인딩 기술
3. **XmlBeans** : 아파치 XML 프로젝트의 하나로, XML의 정보셋을 효과적으로 제공
4. **Xstream** : 관례를 이용해서 설정이 없는 바인딩을 지원하는 XML 바인딩 기술의 일종
> [!check] 이렇게 XML과 자바 오브젝트를 매핑해서 상호 변환해주는 기술을 OXM(Object-XML Mapping)이라고 한다.
#### OXM 서비스 인터페이스
- 스프링이 제공하는 OXM 추상화 서비스 인터페이스에는 [[#마샬링(marshalling)|Marshaller]]와 [[#언마샬링(unmarshalling)|Unmarshaller]]가 있다.
	- `SqlReader`는 이 중에서 **Unmarshaller를 이용**하면 된다.
### 3.2. OXM 서비스 추상화 적용
- SQL을 읽는 방법을 OXM으로 제한해서 사용성을 극대화하는 것이 목적
#### 멤버 클래스를 참조하는 통합 클래스
- `OxmSqlService`는 `SqlReader` 타입의 의존 오브젝트를 사용하되 이를 스태틱 멤버 클래스로 내장하고 자신만이 사용할 수 있도록 만든다.
	- 의존 오브젝트를 자신만이 사용하도록 독점하는 구조
	- 유연성은 조금 손해를 보더라도 내부적으로 낮은 결합도를 유지한 채로 응집도가 높은 구현을 만들 때 유용하게 쓸 수 있는 방법
![](https://i.imgur.com/3QwKZ8B.png)

```java
public class OxmSqlService implements SqlService {
	private final OxmSqlReader oxmSqlReader = new OxmSqlReader();
	private class OxmSqlReader implements SqlReader {
		...
	}
}
```
- `OxmSqlService`와 `OxmSqlReader`는 강하게 결합돼서 **하나의 빈으로 등록되고 한 번에 설정**할 수 있다.
- 또한 `OxmSqlReader`는 private 멤버 클래스이므로 외부에서 접근하거나 사용할 수 없다.
- [>] **OXM을 이용하는 서비스 구조로 최적화하기 위함**
	- 가능한 한 분리하고 유연하게 확장할 수 있게 만드는 것은 중요하다.
	- 하지만 자꾸 늘어나는 빈의 개수와 반복되는 DI구조가 불편하게 느껴질 수 있고,
	- DAO를 개발하는 개발자 입장에서 `SqlService`를 사용하기 위해 많은 빈을 등록하는게 부담이 될 수 있다.
- `BaseSqlService`를 확장해서 디폴트 설정을 두는 방법도 존재한다 하지만..
	- [[#2.6. 디폴트 의존관계|디폴트 의존 오브젝트]]를 만드는 방식의 한계는, 디폴트로 내부에서 만드는 오브젝트의 프로퍼티를 외부에서 지정해주기가 힘들다는 점이다.

![](https://i.imgur.com/JMlnga8.png)
- 하나의 빈 설정으로 2개의 오브젝트를 설정하는 구조
- `OxmSqlReader`는 외부에 노출되지 않으므로, 자신이 DI를 통해 제공받아야 하는 프로퍼티가 있다면 이를 `OxmSqlService`의 공개된 프로퍼티를 통해 **간접적으로 DI** 받아야 한다.
#### 위임을 사용한 BaseSqlService의 재사용
- `loadSql()`, `getSql()`과 같은 핵심 메소드 구현 코드가 `OxmlSqlService`와 `BaseSqlService`가 서로 겹친다.
- 위임 구조를 이용해 코드의 중복을 제거해보자.
![](https://i.imgur.com/zi8gDKF.png)
1. `loadSql()`과 `getSql()` 구현 로직은 `BaseSqlService`에만 둔다.
2. `OxmSqlService`는 일종의 설정과 기본 구성을 변경해주기 위한 어댑터 같은 개념으로 `BaseSqlService` 앞에 두는 설계가 가능하다.
### 3.3. 리소스 추상화
> [!error] `OxmSqlReader`나 `XmlSqlReader`에는 공통적인 문제점이 존재
> SQL 매핑 정보가 담긴 XML 파일 이름을 프로퍼티로 외부에서 지정할 수는 있지만, **UserDao 클래스와 같은 클래스패스에 존재하는 파일로 제한**된다.
- [?] 클래스패스 루트에 있는 XML을 읽으려면 어떻게 해야하는가?
- [?] 서버나 개발 시스템의 특정 폴더에 있는 파일을 읽으려면?
- [?] 더 나아가서 서블릿 컨텍스트의 상대적인 폴더나 http, ftp 프로토콜로 접근할 수 있는 웹 상의 리소스 파일을 가져오려면?
- 안타깝게도 **자바에는** 이렇게 다양한 위치에 존재하는 리소스에 대해 **단일화된 접근 인터페이스를 제공해주는 클래스가 없다.**
#### 리소스
- **스프링은** 자바에 존재하는 일관성 없는 **리소스 접근 API를 추상화해서 `Resource`라는 추상화 인터페이스를 정의**해두었다.
```java
package org.springframework.core.io;

public interface Resource extends InputStreamSource {
	// 리소스의 존재, 읽기 가능한지 여부 등을 알 수 있다.
	// 현재 리소스에 대한 입력 스트림이 열려있는지 확인 가능하다.
	boolean exists();
	boolean isReadable();
	boolean isOpen();

	// JDK의 URL, URI, File 형태로 전환 가능한 리소스에 사용된다.
	URL getURL() throws IOException;
	URI getURI() throws IOException;
	File getFile() throws IOException;

	Resource createRelative(String relativePath) throws IOException;

	// 리소스에 대한 이름과 부가적인 정보를 제공한다.
	long lastModified() throws IOException;
	String getFilename();
	String getDescription();
}

public interface InputStreamSource {
	// 모든 리소스는 InputStream 형태로 가져올 수 있다.
	InputStream getInputStream() throws IOException;
}
```
- 다른 서비스 추상화의 오브젝트와 달리, **Resource는** 스프링에서 빈이 아니라 **값으로 취급**된다.
- 그래서 추상화 적용 방법이 문제다. `Resource`는 빈으로 등록하지 않으므로 기껏 외부에서 지정한다고 해봐야 `<property>`의 `value`에 넣는 방법 밖에 없다.
	- 하지만 `value`에는 단순한 문자열밖에 들어가지 않는다.

URL + URN = URI 
#### 리소스 로더
- 그래서 스프링에는 URL 클래스와 유사하게 접두어를 이용해 `Resource` 오브젝트를 선언하는 방법이 있다.
- 그리고 이렇게 정의된 리소스를 실제 `Resource` 타입 오브젝트로 변환해주는 **ResourceLoader를 제공**한다.
- `ResourceLoader`가 인식하는 접두어와 이를 이용해 리소스를 표현한 예는 다음과 같다.

| **접두어**      | **예**                     | **설명**                                                                                                |
| :----------- | :------------------------ | :---------------------------------------------------------------------------------------------------- |
| `file:`      | file:/C:/temp/file.txt    | 파일 시스템의 C:/temp 폴더에 있는 file.txt를 리소스로 만들어준다.                                                          |
| `classpath:` | classpath:file.txt        | 클래스패스의 루트에 존재하는 file.txt 리소스에 접근하게 해준다.                                                               |
| 없음           | WEB-INF/test.dat          | 접두어가 없다면 `ResourceLoader` 구현에 따라 리소스의 위치가 결정된다.<br>`ServletResourceLoader`라면 서블릿 컨텍스트의 루트를 기준으로 해석한다. |
| `http:`      | http://www...com/test.dat | HTTP 프로토콜을 사용해 접근할 수 있는 웹상의 리소스를 지정한다. ftp:/도 사용할 수 있다.                                               |
- `ResourceLoader`의 대표적인 예는 바로 스프링의 **애플리케이션 컨텍스트**다.
- `ApplicationContext`는 `ResourceLoader` 인터페이스를 상속하고 있다.

---
## 4. 인터페이스 상속을 통한 안전한 기능 확장
애플리케이션을 새로 시작하지 않고 특정 SQL의 내용만을 변경하고 싶으면 어떻게 해야하는가?
- SQL 정보의 실시간 변경이라는 기능을 추가하려면 지금까지 만들고 다듬어왔던 `SqlService` 구현 클래스는 물론, 핵심 인터페이스까지 뜯어고쳐야 한다.
- 기존에 설계하고 개발했던 **기능이 발전돼야 할 경우**에 **스프링답게 접근하는 방법**이 무엇인지 살펴본다.
### 4.1. DI와 기능의 확장
#### DI를 의식하는 설계
- 초기부터 `SqlService`의 내부 기능을 적절한 책임과 역할에 따라 분리하고, 인터페이스를 정의해 느슨하게 연결해주고, **DI를 통해 유연하게 의존관계를 지정하도록 설계**해 뒀기 때문에 그 뒤 작업이 매우 쉬워졌다.
- DI에 필요한 유연하고 확장성이 뛰어난 오브젝트 설계를 위해선 많은 고민, 학습, 훈련, 경험이 필요하다.
#### DI와 인터페이스 프로그래밍
- DI를 적용할 때는 가능한 한 인터페이스를 사용하게 해야 한다.
	- 물론 인터페이스를 사용하지 않고도 DI는 가능하다.
- 인터페이스를 사용하는 이유는 다음과 같다.
	1. **다형성을 얻을 수 있다.** 프록시, 데코레이터, 어댑터, 테스트 대역 등의 다양한 목적을 위해 활용될 수 있다.
	2. **ISP**(Interface Segregation Principle)**를 통해** 클라이언트와 의존 오브젝트 사이의 **관계를 명확하게** 해줄 수 있다.
### 4.2. 인터페이스 상속
- ISP가 주는 장점은 **모든 클라이언트가 자신의 관심에 따른 접근 방식을 불필요한 간섭 없이 유지**할 수 있다는 점이다.
	- 기존 클라이언트는 자신이 사용하던 인터페이스를 통해 동일한 방식으로 접근할 수만 있다면 **오브젝트의 변경에 영향 받지 않는다.**

- ["] 클라이언트가 **정말 필요한 기능을 가진 인터페이스를 통해 오브젝트에 접근하도록 만들었는가**하는 점이 중요하다.

- 잘 적용된 DI는 결국 잘 설계된 오브젝트 의존관계에 달려있다.
- 인터페이스를 적절하게 분리하고 확장하는 방법을 통해,
	1. 오브젝트 사이의 의존관계를 명확하게 해주고, 
	2. 기존 의존관계에 영향을 주지 않으면서
	3. 유연한 확장성을 얻는 방법이 무엇인지 항상 고민해야 한다.

---
## 5. DI를 이용해 다양한 구현 방법 적용하기
### 5.1. ConcurrentHashMap을 이용한 수정 가능 SQL 레지스트리
- `HashMap`으로는 멀티스레드 환경에서 동시에 수정을 시도하거나, 수정과 동시에 요청하는 경우 예상치 못한 결과가 발생할 수 있다.
- 멀티스레드 환경에서 안전하게 `HashMap`을 조작하려면 `Collections.synchronizedMap()` 등을 이용해 외부에서 동기화 해주어야 한다.
	- [c] 하지만 이렇게 `HashMap`에 대한 전 작업을 동기화하면 `SqlService`처럼 DAO의 요청이 많은 고성능 서비스에서는 성능에 문제가 생긴다.

> [!important] ConcurrentHashMap의 사용
 따라서 동기화된 해시 데이터 조작에 최적화되도록 만들어진 ConcurrentHashMap을 사용하는 방법이 일반적으로 권장된다.
- ConcurrentHashMap은 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고, 조회는 아예 락을 사용하지 않는다.
- 어느 정도 안전하면서 성능이 보장되는 동기화된 HashMap으로 이용하기에 적당하다.
### 5.2. 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기
- 이번엔 `ConcurrentHashMap` 대신 내장형 DB(Embedded DB)를 이용해 SQL을 저장하고 수정하도록 만들고자 한다.
- [c] `ConcurrentHashMap`이 멀티스레드 환경에서 최소한의 동시성을 보장해주고 성능도 그리 나쁜 편은 아니지만, **저장되는 데이터의 양이 많아지고 잦은 조회와 변경이 일어난다면 한계점이 생긴다.**

> [!important] 내장형 DB의 사용
> 애플리케이션에 내장돼서 **애플리케이션과 함께 시작되고 종료되는 DB**를 말한다. 데이터는 **메모리에 저장**되기 때문에 IO로 인해 발생하는 부하가 적어서 성능도 뛰어나다.
> 동시에 매우 효과적이고 **안정적인 방법으로 등록, 수정, 검색이 가능**하다.
- 데이터를 내장형 DB의 테이블에 분산해서 넣은 후, SQL문을 이용해 검색하고 조작하면 훨씬 코드도 깔끔하고 활용하기도 편리하다.
#### 스프링의 내장형 DB 지원 기능
- 자바에서 많이 사용되는 내장형 DB는 Derby, HSQL, H2를 꼽을 수 있다.
- 모두 JDBC 드라이버를 제공하고 표준 DB와 호환되는 기능을 제공하기 때문에 JDBC 프로그래밍 모델을 그대로 따라서 사용할 수 있다.
	- [c] JDBC 방식의 접근이라고 해서 기존의 Datasource와 DAO를 사용하는 모델을 그대로 사용하는건 좋은 방법이 아니다.
- **스프링은** 내장형 DB를 손쉽게 이용할 수 있도록 **내장형 DB 지원 기능을 제공**한다.
	- 내장형 DB를 초기화하는 작업을 지원하는 편리한 내장형 DB 빌더를 제공한다.
		- 내장형 DB를 사용할 때 필요한 URL과 드라이버 등을 초기화해주는 기능이 있다.
		- 데이터 초기화를 위해 테이블 등을 생성하거나 초기 데이터를 삽입하는 SQL을 실행해주기도 한다.
	- 모든 준비가 끝나면 내장형 DB에 대한 DataSouce 오브젝트를 돌려준다. 이를 통해 일반적인 DB처럼 사용할 수 있도록 한다.
	- 내장형 DB는 애플리케이션 안에서 직접 DB 종료를 요청할 수도 있어야한다.
		- 스프링은 Datasource 인터페이스를 상속해서 `shutdown()`이라는 내장형 DB용 메소드를 추가한 `EmbeddedDatabase` 인터페이스를 제공한다.
		  *-> 인터페이스 상속을 통한 확장 방법의 좋은 예*
### 5.3. 트랜잭션 적용
- 여러 개의 SQL을 변경하는 작업을 진행하는 중에 존재하지 않는 키가 발견되면, 예외가 발생하도록 되어있으니 작업이 중단된다.
	- 문제는 `updateSql()` 메소드는 단순히 SimpleJdbcTemplate을 사용해 SQL을 실행하고 있으므로 트랜잭션이 적용되어있지 않다는 점이다.
	- 따라서 여러 개의 SQL을 수정하다가 중간에 예외가 발생하면, **이미 수정한 SQL은 DB에 그대로 반영되고 예외가 발생한 SQL부터 그 이후는 적용되지 않은 채로 작업을 마치게 된다.**
- 조금 번거로운 설정이 뒤따름에서 컬렉션(HashMap) 기반이 아닌, 내장형 DB를 도입한 이유는 바로 이런 트랜잭션과 같은 안전한 수정 작업 때문이다.
	- 스프링에서 트랜잭션을 적용할 때 트랜잭션 경계가 DAO 밖에 있고, 범위가 넓은 경우라면 AOP를 이용하는 것이 편리하다.
	- 하지만 **SQL 레지스트리라는 제한된 오브젝트 내에서** 서비스에 특화된 간단한 트랜잭션이 필요한 경우라면 AOP와 같이 거창한 방법보다, **간단히 트랜잭션 추상화 API를 직접 사용**하는게 편리하다.

---
## 6. 스프링 3.1의 DI
스프링은 1.0부터 3.1까지 거의 완벽에 가까울 만큼 구 버전 호환성을 유지하고 있다.
- 그 덕분에 구 버전 스프링을 이용해 개발했던 코드와 설정파일을 스프링 3.1에서도 수정 없이 그대로 사용할 수 있다.
- 많은 변화 속에서 스프링이 꾸준히 호환성을 지키고 안정된 기술을 유지해올 수 있었던 것은 스프링이 지지하고 지원하는 **객체지향적인 코드의 장점인 유연성과 확장성을 스프링 스스로가 충실하게 지켜왔기 때문**이다.

> [!check] 스프링의 호환성
> 현재 최신 스프링 버전은 **6.2.x**로, **객체지향적인 코드의 장점인 유연성과 확장성**을 지키는 철학은 최신 스프링에서도 여전히 유효하나, Jakarta EE 전환과 같은 구조적 변화가 있었기 때문에 여러 코드와 설정파일을 그대로 사용하기는 어렵다.
### 6.1. 자바 언어의 변화와 스프링
###### 어노테이션의 메타정보 활용
- [p] 어노테이션은 애플리케이션 핵심 로직을 담은 자바 코드와 이를 지원하는 IoC 방식의 프레임워크, 그리고 프레임워크가 참조하는 메타정보라는 세 가지로 구성하는 방식에 잘 어울린다.
- [c] XML은 어느 환경에서나 손쉽게 편집이 가능하고, 내용을 변경하더라도 다시 빌드를 거칠 필요가 없다. 반면 어노테이션은 자바 코드에 존재하므로 변경할 때마다 매번 클래스를 새로 컴파일해줘야 한다.
###### 정책과 관례를 이용한 프로그래밍
- [p] 어노테이션과 같은 프로그래밍 방식은 명시적으로 동작 내용을 기술하는 대신 코드 없이도 미리 약속한 규칙 또는 관례를 따라서 프로그램이 동작하도록 만드는 프로그래밍 스타일을 적극적으로 포용하게 만들어왔다.
- [c] 반면 프로그래밍 언어나 API 사용법 외에 미리 정의된 많은 규칙과 관례를 기억해야하고, 메타정보를 보고 프로그램이 어떻게 동작할지 이해해야 하는 부담을 주기도 한다.
### 6.2. 빈 스캐닝과 자동와이어링
#### @Autowired를 이용한 자동와이어링
- 지금까지 사용했던 `@Autowired`는 스프링 테스트 클래스나 DI 설정용 `@Configuration` 클래스에서 스프링 컨테이너가 생성한 빈을 클래스의 멤버 필드로 주입받기 위해 사용했다.
- 빈의 프로퍼티에 다른 빈을 넣어서 런타임 관계를 맺어주려면 `<bean>`의 `<property>`를 사용해 빈을 정의하거나 자바 코드로 직접 Setter 메소드를 호출해줘야 했다.
- 빈으로 사용되는 `UserServiceImpl`이나 `UserDaoJdbc` 같은 클래스에서`Autowired`를 사용해서 명시적인 프로퍼티 설정 없이 다른 빈 오브젝트를 주입되게 할 수는 없을까?
	- 물론 가능하다. `@Autowired`는 **자동와이어링 기법을 이용해서 조건에 맞는 빈을 찾아 자동으로 Setter 메소드 또는 필드에 넣어준다.**
#### @Component를 이용한 자동 빈 등록
- `@Component`는 클래스에 부여되며, `@Component`가 붙은 클래스는 빈 스캐너를 통해 자동으로 빈으로 등록된다.
	- 정확히는 `@Component` 또는 `@Component`를 메타 어노테이션으로 갖고 있는 어노테이션이 붙은 클래스가 자동 빈 등록 대상이 된다.
	- [?] `@Controller`, `@Service`, `@Repository` 등을 의미한다.
```java
@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) 
@Documented 
@Component // @Component를 메타 어노테이션으로 포함 
public @interface Service { 
	String value() default "";
}
```
- 예를 들어 @Service를 보면 요렇게 생겼다.
- 직접 정의하는 것 역시 가능하다. 아래 예시는 SNS 서비스에 접속하는 기능을 제공하는 빈을 AOP 포인트 컷으로 지정할 수 있도록 구분해주는 어노테이션이다.
```java
@Component
public @interface SnsConnector {
	...
}
```
### 6.3. 컨텍스트 분리와 @Import
이번에 할 작업은 성격이 다른 DI 정보를 분리하는 것이다.
#### 테스트용 컨텍스트 분리
- `userDao`와 `userService` 빈은 애플리케이션 운영과 테스트에 모두 필요하다. 또한 DB 연결과 트랜잭션 관리, SQL 서비스도 항상 필요하다.
- 반면 `testUserService` 빈은 테스트에서만 사용된다. `mailSender` 빈은 좀 애매하지만 일단 테스트용이라고 하자.
	- 그렇다면 이 2개의 빈 설정은 테스트를 작성하거나 수정할 때만 영향을 받고 변경되므로 다른 애플리케이션 빈의 DI 정보에서 분리하는 것이 좋다.
	- 테스트용 빈 정보를 분리해낼 클래스를 새로 만들고 , `@Configuration`을 붙여 만들면 된다.
```java
@Configuration
public class AppContext {
    // 공통 빈 설정
}

@Configuration
public class TestAppContext {
    // 테스트 전용 빈 설정
}
```

- 운영 시스템에서 애플리케이션이 동작할 때는 AppContext만 참조하고, 테스트 코드에서는 두 설정을 모두 사용하도록 지정한다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes={TestAppContext.class, AppContext.class})
public class UserDaoTest {
	...
}
```
#### @Import
- SQL 서비스는 그 자체로 독립적인 모듈처럼 취급하는 게 낫다.
	- SQL 서비스는 다른 애플리케이션에서도 사용될 수 있고, 다른 빈과 달리 독립적으로 개발되거나 변경될 가능성이 높기 때문이다.
- 따라서 SQL 서비스와 관련된 빈들을 분리하고자 한다.
```java
@Configuration
public class SqlServiceContext {
    ...
}

@Configuration
@Import(SqlServiceContext.class)
public class AppContext {
	...
}
```
- `@Import`는 다른 설정 클래스를 가져와서 함께 사용할 수 있게 해주는 어노테이션이다.
- 이렇게 설정을 분리함으로써
	1. 관심사 분리로 코드 관리가 용이해지고
	2. 모듈별 독립적인 개발과 테스트가 가능해지며
	3. 필요한 환경에 따라 설정 조합이 가능해진다. (운영/테스트)
	4. 마지막으로 재사용성도 향상된다.

> [!important] 스프링 부트의 자동 설정(Auto Configuration)
> 컨텍스트 분리와 @Import 개념을 더욱 발전시킨 형태. 설정이 자동으로 적용되므로, 개발자는 **application.properties(application.yml)을 통해 자동 설정된 빈의 속성을 쉽게 변경**할 수 있다.

### 6.4. 프로파일
- 테스트 환경과 운영 환경에서 각기 다른 빈 정의가 필요한 경우가 종종 있다.
- 이 문제를 해결하려면 운영환경에서는 반드시 필요하지만 테스트 실행 중에는 배제되어야 하는 빈 설정을 별도의 설정 클래스를 만들어 따로 관리할 필요가 있다.
#### @Profile과 @ActiveProfiles
- 스프링 3.1에서는 간단히 설정정보를 구성할 수 있는 방법을 제공한다.
	- 실행환경에 따라 빈 구성이 달라지는 내용을 프로파일로 정의해서 만들어두고, 실행 시점에 어떤 프로파일의 빈 설정을 사용할지 지정하는 것이다.
```java
@Configuration
@Profile("test")
public class TestAppContext {
	...
}
```

1. 테스트에서 활성화 시 다음과 같이 `@ActiveProfiles`를 이용하면 된다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=AppContext.class)
@ActiveProfiles("test")  // 테스트에서 사용할 프로파일 지정
public class UserServiceTest {
    ...
}
```

2. 애플리케이션 실행 시에는
	- JVM 시스템 프로퍼티(`-Dspring.profiles.active=production`)
	- 환경 변수 등으로 활성화 할 수 있다.

> [!important] 스프링 부트의 프로파일
> `application-{profile}.properties` 또는 `application-{profile}.yml` 파일을 통해 프로파일별 설정 값을 쉽게 관리할 수 있다.
### 6.5. 프로퍼티 소스
- 프로파일을 이용해 테스트 환경과 운영 환경에서 각각 다른 빈 설정이 적용되게 만들었다.
	- [!] 하지만 아직 AppContext에는 테스트 환경에 종속되는 정보가 남아있다. 
	  **바로 `dataSource`의 DB 연결 정보다.**
#### @PropertySource
- 프로퍼티에 들어갈 DB 연결정보는 텍스트로 된 이름과 값의 쌍으로 구성되면 된다.
- 복잡한 XML을 정의해서 사용할 것 없이 간단히 자바의 프로퍼티 파일 포맷을 이용하면 충분하다.
```yml
db.driverClass=com.mysql.jdbc.Driver
db.url=jdbc:mysql://localhost/springbook
db.username=spring
db.password=book
```
- AppContext의 `dataSource()`가 이 파일의 내용을 가져와 DB 연결정보 프로퍼티에 넣어주도록 만들려면, @PropertySource 어노테이션을 이용할 수 있다.
```java
@Configuration
@PropertySource("/database.properties")
public class AppContext {
	...
}
```
#### 프로퍼티 값 가져오기
프로퍼티 값을 가져오는 방법은 2가지가 있다.
1. Environment 객체 사용하기
```java
@Autowired
private Environment env;

@Bean
public DataSource dataSource() {
    SimpleDriverDataSource ds = new SimpleDriverDataSource();
    
    try {
        ds.setDriverClass((Class<? extends Driver>)
            Class.forName(env.getProperty("db.driverClass")));
    } catch (ClassNotFoundException e) {
        throw new RuntimeException(e);
    }
    ds.setUrl(env.getProperty("db.url"));
    ds.setUsername(env.getProperty("db.username"));
    ds.setPassword(env.getProperty("db.password"));
    
    return ds;
}
```

 2. PropertySourcesPlaceholderConfigurer 사용하기
```java
// 이 방식을 사용하려면 PropertySourcesPlaceholderConfigurer 빈이 필요하다.
@Bean
public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
    return new PropertySourcesPlaceholderConfigurer();
}
```

```java
// 이후 @Value 어노테이션과 함께 플레이스홀더를 사용할 수 있다.
@Value("${db.driverClass}")
private String driverClass;

@Value("${db.url}")
private String url;

@Value("${db.username}")
private String username;

@Value("${db.password}")
private String password;

@Bean
public DataSource dataSource() {
    SimpleDriverDataSource ds = new SimpleDriverDataSource();
    try {
        ds.setDriverClass((Class<? extends Driver>) Class.forName(driverClass));
    } catch (ClassNotFoundException e) {
        throw new RuntimeException(e);
    }
    ds.setUrl(url);
    ds.setUsername(username);
    ds.setPassword(password);
    return ds;
}
```
### 6.6. 빈 설정 재사용과 @Enable*
- 스프링 3.1에서는 **모듈화된 빈 설정을 쉽게 가져다 쓸 수 있는** @Enable* 시리즈 어노테이션을 도입했다.
- 특정 기능을 손쉽게 활성화할 수 있게 해준다.
#### @Enable* 어노테이션의 개념
- **목적**: 특정 기능 모듈의 설정을 쉽게 임포트하고 활성화
- **구성**: 내부적으로 @Import를 사용하여 필요한 설정 클래스들을 가져옴
- **사용자 편의성**: 복잡한 설정을 단일 어노테이션으로 간소화
#### 주요 @Enable* 어노테이션 예시
1. **@EnableTransactionManagement**: 트랜잭션 관리 기능 활성화
```java
@Configuration
@EnableTransactionManagement
public class AppContext {
    ...
}
```
2. **@EnableWebMvc**: 스프링 MVC 기능 활성화
3. **@EnableAspectJAutoProxy**: AspectJ 기반 AOP 기능 활성화
4. **@EnableScheduling**: 스케줄링 기능 활성화
5. **@EnableCaching**: 캐싱 기능 활성화

> [!important] 스프링 부트의 자동 설정(Auto Configuration) 2
> 스프링 부트는 `@Enable*` 어노테이션과 같은 설정을 대부분 application.properties(application.yml) 파일로 대체할 수 있으며, `spring-boot-starter` 의존성 추가만으로도 필요한 기능이 자동 활성화된다. 필요한 경우에만 명시적으로 `@Enable*` 어노테이션을 사용하여 추가 설정을 할 수 있다.