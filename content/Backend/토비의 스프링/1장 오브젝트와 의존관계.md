## 0. 들어가기 전에..

- 많은 부분이 UML 다이어그램으로 설명되어있음
- **실선 화살표 - 연관(Association)**
    - 클래스 간의 연결을 나타냄
    - 보통 "has-a" 관계 (한 클래스가 다른 클래스를 알고 있음)

- **실선 삼각형 화살표 - 상속/일반화(Generalization)**
    - 클래스 간의 "is-a" 관계
    - 자식 클래스가 부모 클래스를 향하도록 표시

- **점선 화살표 - 의존성(Dependency)**
    - 한 클래스가 다른 클래스를 일시적으로 사용하는 관계
    - 메서드 매개변수, 지역 변수, 정적 메서드 호출 등
    - "uses-a" 관계라고 볼 수 있음
    - 화살표가 의존하는 클래스를 향함

- **점선 삼각형 화살표 - 실현(Realization)**
    - 인터페이스와 구현 클래스 간의 관계
    - 구현 클래스가 인터페이스를 실현(구현)함
    - 화살표가 인터페이스를 향함

## 1. 초난감 DAO
- 스프링은 자바를 기반으로 한 기술
    - **객체지향 프로그래밍이 제공하는 폭 넓은 혜택을 누릴 수 있도록 기본으로 돌아가자**는 것이 스프링의 핵심 철학
- 따라서, 스프링이 가장 관심을 많이 두는 대상은 **오브젝트**이다.
- 스프링을 공부한다는 건 객체지향 설계의 원칙에 대한 문제와 의문의 해답을 찾아나가는 과정
    - 스프링은 기계적인 답변이나 성급한 결론을 주지 않는다.
    - 최종 결론은 스프링을 이용해 개발자 스스로가 만들어내는 것

> [!note] 중요 
> 스프링은 단지 그 과정 속에서 이런 고민을 제대로 하고 있는지 끊임없이 확인해주고, 좋은 결론을 내릴 수 있도록 객체지향 기술과 자바 개발의 선구자들이 먼저 고민하고 제안한 방법에 대한 힌트를 제공해 줄 뿐이다.
## 2. DAO의 분리
- 개발자가 객체를 설계할 때 가장 염두해 둬야 할 사항은 **미래의 변화를 어떻게 대비할 것인가**이다.
    - 분리와 확장을 고려한 설계가 필요하다.
- **관심사의 분리(Separation of Concerns)**
    - 관심이 같은 것끼리는 하나의 객체 안으로, 관심이 다른 것은 가능한 한 따로 떨어져서 영향을 주지 않도록 분리해야 한다.
### 상속을 통한 확장
#### 템플릿 메소드 패턴
- 스프링에서 애용되는 디자인 패턴
- 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
    - 변하지 않는 기능은 슈퍼클래스에,
    - 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.
#### 팩토리 메소드 패턴
- 템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴
- 객체 생성 로직을 서브클래스로 위임하는 방식

> [!important] 주의 
> 정적 팩토리 메소드에서의 **팩토리 메소드**와는 다르다!
> 
> 1. **팩토리 메소드 패턴**에서의 팩토리 메소드 
>    -> 객체 생성 로직을 서브클래스에 위임하는 인스턴스(non-static) 메소드
> 2. **정적 팩토리 메소드**에서의 팩토리 메소드 
>    -> 생성자 대신 사용되는, 클래스의 인스턴스를 반환하는 정적(static) 메소드
## 3. DAO의 확장
- **상속**이라는 방법으로 관심사의 분리를 하는 경우, **여러 부분이 불편**하다
    1. 결합도가 강해지고(부모 클래스 변경 시 자식 클래스에 영향 끼침),
    2. 유연성이 약해진다(상속은 컴파일 타임에 결정됨, 런타임에 동작 변경 어려움)
    3. 상속 계층 역시 복잡해질 수 있고, ( 가독성이 떨어진다. )
    4. 단위 테스트를 어렵게 만든다.
### 인터페이스 도입
- 클래스를 (상속 없이) 분리하면서, 자유롭게 변경 및 확장이 가능하게 하려면?
- 두 개의 클래스가 서로 긴밀하게 연결되어있지 않도록 중간에 추상적인 느슨한 연결 고리를 만들어 준다. -> **인터페이스**
### OCP(Open-Closed Principle)
- 인터페이스를 이용한 분리에도 불구하고 아직 확장이 자유롭지 못하다면?
- 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
- 이를 위해선 인터페이스에 의존해야지, 구체화된 클래스에 의존해서는 안된다.
- DIP(의존성 역전 원칙)을 지키는 것이기도 함.
### 전략 패턴
- 디자인 패턴의 꽃이라고 불릴만큼 자주 사용되는 패턴
- OCP에도 가장 잘 들어맞는 패턴
- 행동(알고리즘) 집합을 정의하고, 각각을 캡슐화하며, 이들을 상호 교환 가능하게 만드는 디자인 패턴
#### 전략 패턴의 구성요소
- **컨텍스트**: 전략을 사용하는 클라이언트
- **전략 인터페이스**: 모든 전략이 구현해야 하는 공통 인터페이스
- **구체적인 전략**: 실제 알고리즘을 구현한 클래스들
## 4. 제어의 역전(IoC)
- 오브젝트 팩토리
    - 어떤 구현 클래스를 사용할지를 결정하는 기능 역시 책임 분리가 필요하다.
    - 객체의 생성 방법을 결정하고 오브젝트를 돌려주는 역할이 필요 -> **팩토리**
- 제어의 역전
    - 프로그램의 제어 흐름 구조가 뒤바뀌는 것
    - 오브젝트가 자신이 사용할 오브젝트를 스스로 선택(생성)하지 않는다.
    - **모든 제어 권한을 자신이 아닌 다른 대상에게 위임**한다.
## 5. 스프링의 IoC
- 오브젝트 팩토리를 이용한 스프링 IoC
    - **빈(Bean)**: 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
    - **빈 팩토리(Bean Factory)**: 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
    - **애플리케이션 컨텍스트(Application Context)**: 빈 팩토리를 확장하여 만들어짐
### 스프링 설정 애노테이션
- **@Configuration**: 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스를 인식하기 위함
- **@Bean**: 스프링 빈임을 명시

> [!tip] 참고 스프링 빈 설정은 XML이나 자바 코드(@Configuration)로 할 수 있으며, 스프링 부트에서는 컴포넌트 스캔(@Component)이 많이 사용됨
## 6. 싱글톤 레지스트리와 오브젝트 스코프
- 동일성과 동등성
    - 자바에서 두 개의 오브젝트가 같은가를 따지는 두 가지 용어
    - **동일성(`==`)**: 사실은 하나의 오브젝트만 존재하는 것
    - **동등성(`equal()`)**: 내부 상태가 같은 것
### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
- 애플리케이션 컨텍스트는 IoC 컨테이너이며, 동시에 싱글톤을 저장하고 관리하는 **싱글톤 레지스트리**이기도 하다.
- 별다른 설정이 없으면 스프링은 기본적으로 빈을 **싱글톤으로 관리**한다
#### 싱글톤 패턴의 한계
- private 생성자를 갖고 있으므로 상속이 불가능하다.
- 테스트하기가 어렵다(Mock 오브젝트 등으로 대체가 어렵다).
- 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
- 전역 상태를 만들 수 있으므로 바람직하지 못하다.
	- 아무 객체나 자유롭게 접근/수정/공유 하는 것은 권장되지 않는다.
#### 싱글톤 레지스트리
- 싱글톤 패턴과 달리 스프링은 싱글톤 레지스트리를 통해 싱글톤을 관리한다.
    - 일반 클래스를 싱글톤으로 활용 가능(public 생성자 역시 가질 수 있음)
    - 테스트하기 쉬움
    - 객체지향적 설계 가능
### 빈 스코프
- **싱글톤 스코프**: 기본 스코프, 애플리케이션 컨텍스트 시작/종료까지 하나의 빈 인스턴스만 생성
- **프로토타입 스코프**: 빈을 요청할 때마다 새로운 인스턴스 생성
- **요청(request) 스코프**: 웹 요청마다 독립적인 빈 인스턴스 생성
- **세션(session) 스코프**: 웹 세션마다 독립적인 빈 인스턴스 생성
## 7. 의존관계 주입(DI)
- 스프링이 제공하는 IoC 방식의 핵심을 짚어 주는 의존 관계 주입(Dependency Injection)이라는, 좀 더 의도가 명확히 드러나는 이름을 사용하기 시작
    - IoC 컨테이너 대신 **DI 컨테이너**라고 더 많이 불리우고 있음
- 의존관계
    - A가 B를 사용하는(의존하는) 관계
    - 변화에 취약한 결합도가 높은 관계가 될 수 있음
- 의존관계 주입
    - 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴
    - 상위 타입(인터페이스)에 의존함으로써 느슨한 결합도를 유지
### DI의 세 가지 조건
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다
    - 인터페이스에만 의존하고 있어야 함
2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3자에 의해 결정되어야 한다
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로써 만들어진다
### DI의 유형
- **생성자 주입**: 생성자를 통해 의존성 주입 (`@Autowired` 생성자)
    - 현대 스프링에서 가장 권장되는 방식
    - 필수 의존성을 명확히 하고, final 필드로 불변성 보장
    - 스프링 4.3(스프링 부트 1.4.x ~)부터는 단일 생성자의 경우 `@Autowired` 생략 가능
- **수정자 주입**: setter 메서드를 통해 의존성 주입 (`@Autowired` setter)
    - 현재는 선택적 의존성에만 권장
- **필드 주입**: 필드에 직접 의존성 주입 (`@Autowired` 필드)
    - 코드는 간결하나 테스트하기 어려워 권장되지 않음

> [!tip] 참고 
> 의존관계 주입 방식은 스프링 버전과 개발 트렌드에 따라 변화해왔다. 
> 토비의 스프링 초판(2008년경)에서는 수정자 주입이 많이 사용되었으나, 현대 스프링에서는 불변성과 안정성 측면에서 생성자 주입이 권장된다고 한다.
## 8. XML을 이용한 설정
- XML 설정 파일을 통해 빈 등록 및 의존관계 설정 가능
- 자바 코드와 함께 혼용 가능
### XML 설정의 장점
- 재컴파일 없이 빈 구성 변경 가능
- 여러 환경에서 쉽게 재사용 가능
### XML 설정
- `<beans>`를 루트 엘리먼트로 사용한다.
	- 여러 개의 `<bean>`을 정의할 수 있다.
	- `@Configuration`을 `<beans>`, `@Bean`을 `<bean>`에 대응해서 생각하면 이해하기 편하다.
- 하나의 `@Bean` 또는 `<bean>`으로 얻을 수 있는 빈의 DI 정보는 다음 세 가지
	- **빈의 이름** : @Bean의 메소드 이름
	- **빈의 클래스** : 어떤 클래스를 이용해서 만들지 정의
	- **빈의 의존 오브젝트** : 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어 줌
### XML을 이용하는 애플리케이션 컨텍스트
- XML에서 빈의 의존관계 정보를 이용하는 IoC/DI 작업에는 `GenericXmlApplicationContext`를 사용
	- 애플리케이션 컨텍스트가 사용하는 XML 설정파일의 이름은 관례를 따라 `applicationContext.xml`이라고 만든다.

AOC, IoC, DI