
- 자바/Spring에서는 여러 기술들이 비슷한 목적을 가지고 있지만 **API나 방식이 다르다**.
- 이를 **스프링이 어떻게 통일된 추상화로 묶어주는지**를 예제로 설명하려는 의도.
- 그래서 트랜잭션처럼 기술이 다른데 역할은 비슷한 요소들을 **공통 인터페이스로 감싸는 것**을 보여주려함.
- `enum`을 통해 **타입 안정성 확보**
- `User` 클래스와 DB 스키마에 **레벨, 로그인 횟수, 추천 수** 필드 추가
- 테스트도 함께 업데이트해서 **회귀 테스트 보장

**테스트 코드는 단순한 보조 수단이 아니라, 코드 변경 시 발생할 수 있는 오류를 빠르게 감지하는 중요한 도구다.**  

 **SQL 같은 동적인 문자열 기반 코드에서는 오타나 실수를 빠르게 찾아내기 위해 철저한 테스트가 필요하다.**  
 
 **특히 UPDATE 문을 사용할 때 WHERE 절을 빼먹는 실수는 치명적이므로, 이를 감지할 수 있는 테스트를 작성해야 한다.**
 
처음부터 ~ 349까지 정리 

349P
## 트랜잭션 서비스 추상화

**트랜잭션이란 더 이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자성을 의미한다.**

### ### **트랜잭션 경계 설정 요약**

#### **1. DB는 기본적으로 트랜잭션을 지원한다.**

- 단일 SQL 문장은 **DB 자체가 트랜잭션을 보장**하므로, 실행 도중 일부만 적용되는 문제가 발생하지 않는다.
- 예를 들어, `UPDATE`나 `DELETE` 같은 SQL 명령어는 **항상 전체적으로 적용되거나, 실패하면 아무것도 변경되지 않는다.**
    

#### **2. 여러 개의 SQL을 하나의 트랜잭션으로 묶어야 할 경우**

- 하나의 논리적인 작업이 여러 개의 SQL로 이루어질 수 있다.
- 이 경우, **중간에 문제가 발생하면 앞에서 실행된 SQL도 취소(롤백)해야 한다.**
- 반대로, **모든 SQL이 정상적으로 실행되면 최종적으로 확정(커밋)해야 한다.**
    

#### **3. 트랜잭션 롤백(Transaction Rollback)**

- **어떤 SQL이 실패하면 이전에 실행된 모든 SQL 작업을 취소하는 것.**
- 예: A 계좌에서 B 계좌로 돈을 송금하는 과정에서 B 계좌에 입금하기 전에 오류가 발생하면, A 계좌에서 출금된 돈도 원래대로 복구해야 한다.
    

#### **4. 트랜잭션 커밋(Transaction Commit)**

- **모든 SQL 작업이 성공적으로 끝났을 때, 변경사항을 확정하는 것.**
- 예: A 계좌에서 출금 → B 계좌에 입금 → **모든 작업이 문제없이 끝났다면, 변경사항을 DB에 반영.**
    

#### **5. 트랜잭션 경계 설정이 필요한 이유**

- 데이터 정합성을 유지하기 위해
- 부분적으로만 변경되는 문제를 방지하기 위해
- 안정적인 애플리케이션 운영을 위해
    

 **트랜잭션 = "작업을 하나의 단위로 묶어, 모두 성공하면 반영(커밋), 하나라도 실패하면 취소(롤백)"**

### JDBC 트랜잭션의 트랜잭션 경계설정

모든 트랜잭션은 시작하는 지점과 끝나는 지점이 있다. 시작하는 방법은 한 가지이지만 끝나는 방법은 두 가지다. 

- **시작 방법:** `setAutoCommit(false)`
- **종료 방법:**
    - `commit()`: 모든 작업을 확정(반영)
    - `rollback()`: 모든 작업을 취소

Connection : DB와 연결을 담당하는 객체

**JDBC의 트랜잭션은 하나의 Connection을 가져와 사용하다가 닫는 사이에 일어난다. 트랜잭션의 시작과 종료는 Connection 오브젝트를 통해 이루어지기 때문이다.** JDBC의 기본 설정은 DB 작업을 수행한 직후에 자동으로 커밋이 되도록 되어 있다.

- **JDBC에서는 하나의 `Connection`을 사용하는 동안 트랜잭션이 유지됨.**
- 기본적으로 DB 작업을 수행하면 **자동으로 커밋(AutoCommit=true)** 된다.
- 수동으로 트랜잭션을 관리하려면 `setAutoCommit(false)`로 자동 커밋을 해제해야 함.
- Spring을 사용하면 **`@Transactional`을 붙이는 것만으로 트랜잭션을 자동 관리**할 수 있음.

**setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 종료하는 작업을 `트랜잭션의 경계설정(transaction demarcation)`이라고 한다.** 

트랜잭션의 경계는 하나의 Connection이 만들어지고 닫히는 범위 안에 존재한다는 점도 기억하자. 이렇게 하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 `로컬 트랜잭션(local transaction)`이라고도 한다.

#### 비즈니스 로직 내의 트랜잭션 경계설정

- **JDBC에서는 `setAutoCommit(false)`로 트랜잭션을 시작하고, `commit()` 또는 `rollback()`으로 종료**함.
- 하지만 **비즈니스 로직(UserService)과 데이터 엑세스(UserDao)의 역할을 분리**해야 더 유지보수가 쉬움.
- 그래서 **UserService에서 트랜잭션을 제어**하고, **UserDao는 SQL 실행만 담당**하도록 구조를 변경하는 게 좋음.

결국 리스트 5-40과 같이 UserService의 메소드 사이에도 같은 Connection 오브젝트를 사용하도록 파라미터로 전달해줘야만 한다.
### UserService 트랜잭션 경계설정의 문제점

위의 방법을 사용하면 트랜잭션 문제는 해결할 수 있겠지만, 그 대신 여러 가지 새로운 문제가 발생한다.

첫째는 DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 JdbcTemplate을 더 이상 활용할 수 없다는 점이다. Try/catch/finally 블록은 이제 UserService 내에 존재하고, UserService의 코드는 JDBC 작업 코드의 전형적인 문제점을 그대로 가질 수 밖에 없다.

두 번째 문제점은 DAO의 메소드와 비즈니스 로직을 담고 있는 UserService의 메소드에 Connection 파라미터가 추가돼야 한다는 점이다.

세 번째 문제는 Connection 파라미터가 UserDao 인터페이스 메소드에 추가되면 UserDao는 더 이상 데이터 액세스 기술에 독립적일 수가 없다는 점이다.

**Spring이 제공하는 `@Transactional`을 사용하면 트랜잭션의 이런 점들을 자동 관리**

### 트랜잭션 동기화

스프링은 위의 문제를 해결할 수 있는 멋진 방법을 제공해준다.

### Connection 파라미터 제거

Connection 오브젝트를 한번 생성 후 계속 메소드의 파라미터로 전달하다가 DAO를 호출할 때 사용하는 건 피하고 싶다. 이를 위해 스프링이 제안하는 방법은 `트랜잭션 동기화(transaction synchronization)` 방식이다. **트랜잭션 동기화란 UserService에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 DAO의 메소드에서는 저장된 Coonection을 가져다가 사용하게 하는 것이다.**

**트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 날 염려는 없다.**

이렇게 트랜잭션 동기화 기법을 사용하면 파라미터를 통해 일일이 Connection 오브젝트를 전달할 필요가 없어진다. 트래잭션의 경계설정이 필요한 Service에서만 Connection을 다루게 하고, 여기에 생성된 Connection과 트랜잭션을 DAO의 JdbcTemplate이 사용할 수 있도록 별도의 저장소에 동기화하는 방법을 적용하기만 하면 된다. 더 이상 로직을 담은 메소드에 Connection 타입의 파라미터가 전달될 필요도 없고, UserDao의 인터페이스에도 일일이 JDBC 인터페이스인 Connection을 사용한다고 노출할 필요가 없다.

### 트랜잭션 동기화 적용

**이전처럼 트랜잭션을 직접 관리하면**

- **Connection을 직접 가져와야 함.**
- **여러 DAO에서 같은 Connection을 공유하려면 직접 전달해야 함.**
- **트랜잭션 처리가 복잡해지고, 관리가 어려워짐**

이러한 문제점이 있으므로 

### **361p 트랜잭션 동기화 적용 (Spring 지원 기능 활용)**

여기 내용들도 쭉 읽어보면 좋을 것 같다 간단하게 정리하자면 

Spring의 **`TransactionSynchronizationManager`** 와 **`DataSourceUtils.getConnection()`** 을 사용하면

- **Connection을 직접 관리할 필요 없음.**
- **같은 트랜잭션 내에서 자동으로 같은 Connection을 공유함.**

**🔹 동작 방식**

1. `TransactionSynchronizationManager.initSynchronization()` → **트랜잭션 동기화 시작**
2. `DataSourceUtils.getConnection(dataSource)` → **Connection을 생성하면서 동기화 저장소에 저장**
3. JdbcTemplate을 사용하면 → **동기화된 Connection을 자동으로 사용**
4. `TransactionSynchronizationManager.clearSynchronization()` → **트랜잭션 동기화 종료**

트랜잭션 동기화가 되어 있는 채로 JdbcTemplate을 사용하면 JdbcTemplate의 작업에서 동기화시킨 DB 커넥션을 사용하게 된다.

### JdbcTemplate과 트랜잭션 동기화

JdbcTemplate은 영리하게 동작하도록 설계되어 있다. 만약 미리 생성돼서 트랜잭션 동기화 저장소에 등록된 DB 커넥션이나 트랜잭션이 없는 경우에는 JdbcTemplate이 직접 DB 커넥션을 만들고 트랜잭션을 시작해서 JDBC 작업을 진행한다. 반면에 upgradeLevels() 메소드에서처럼 트랜잭션 동기화를 시작해놓았다면 그때부터 실행되는 JdbcTemplate의 메소드에서는 직접 DB 커넥션을 만드는 대신 트랜잭션 동기화 저장소에 들어 있는 DB 커넥션을 가져와서 사용한다. 이를 통해 이미 시작된 트랜잭션에 참여하는 것이다.

- **지금 트랜잭션 안에서 실행 중인가?"** 를 자동으로 파악해서,
- **있으면 그 트랜잭션 안에서 사용 중인 커넥션을 재사용**하고,
- **없으면 새 커넥션을 만들어서 트랜잭션 없이 실행**함.

이 덕분에 우리는 굳이 JdbcTemplate에 “이 커넥션 써~” 하고 넘기지 않아도, 트랜잭션이 자동으로 적용되고, **비즈니스 로직과 DB작업을 분리한 상태로** 깔끔하게 관리할 수 있다

>[!note] 핵심
> JdbcTemplate은 **트랜잭션이 이미 시작되어 있으면 그 트랜잭션에 참여**하고,  
> 그렇지 않으면 **독립적으로 동작한다.**

이게 **스프링이 JDBC를 쓸 때도 깔끔하게 트랜잭션을 처리할 수 있게 해주는 핵심 메커니즘**이다.

### 트랜잭션 서비스 추상화

### 로컬 트랜잭션은 한계가 있다

- 우리가 지금까지 얘기한 **JDBC 트랜잭션**은 하나의 `Connection` 객체를 기반으로 트랜잭션을 시작하고 끝내.
- 그런데 문제는, 이 **Connection은 하나의 DB에만 연결**되어 있다는 것.
- 그래서 **여러 개의 DB에 동시에 접근해서 하나의 트랜잭션으로 묶는 건 불가능**해.

---
#### 기술과 환경에 종속되는 트랜잭션 경계설정 코드

그래서 등장한 게 글로벌 트랜잭션 (= 분산 트랜잭션)

- 여러 개의 리소스(DB, 메시지 큐 등)에 대해 **하나의 트랜잭션처럼 작동하도록 하는 기술**이야.
- 이걸 하려면 각 DB의 `Connection`이 아니라, **중앙에서 트랜잭션을 조정하는 무언가가 필요**해.
- 그게 바로 **트랜잭션 매니저(Transaction Manager)**.
    

---

###  트랜잭션 매니저가 모든 리소스를 관리한다

- 트랜잭션 매니저는 **DB, 메시지 서버 등 리소스 매니저들과 통신**해서,
- " 트랜잭션 시작해!  이런 식으로 명령을 내려.
- 이걸 가능하게 해주는 통신 방식이 **XA 프로토콜**이라는 거고,
- 이런 분산 트랜잭션을 자바에서 구현할 수 있도록 표준 API를 만든 게 **JTA (Java Transaction API)**야.
    

---

###  스프링에서는 이걸 추상화해서 제공해줌

- 스프링은 `DataSourceTransactionManager` 같은 걸로 **JDBC 로컬 트랜잭션**,
- `JtaTransactionManager` 같은 걸로 **글로벌 트랜잭션 (JTA)**을 다룰 수 있게 해줘.
- 즉, 우리는 `PlatformTransactionManager`라는 **공통 인터페이스**만 사용하면 되고,
- 그 뒤에서 어떤 방식(JDBC, JPA, JTA 등)으로 트랜잭션을 관리하든 상관없이 똑같은 코드로 사용할 수 있게 해주는 거야. (이게 바로 **트랜잭션 서비스 추상화**)

--- 
#### 트랜잭션 API의 의존관계 문제와 해결책

UserDao가 DAO 패턴을 사용해 구현 데이터 액세스 기술을 유연하게 바꿔서 사용할 수 있게 했지만 UserService에서 트랜잭션의 경계 설정을 해야 할 필요가 생기면서 다시 특정 데이터 액세스 기술에 종속되는 구조가 되고 말았다.

트랜잭션 경계 설정 코드를 “어떻게 하면 기술에 의존하지 않게 만들 수 있을까?

**추상화 : 란 하위 시스템의 공통점을 뽑아내서 분리시키는 것을 말한다. 그렇게 하면 하위 시스템이 어떤 것인지 알지 못해도, 또는 하위 시스템이 바뀌더라도 일관된 방법으로 접할 수가 있다.**

- 공통의 인터페이스나 추상 클래스를 만들어서, 다양한 트랜잭션 구현을 숨기고
- `UserService`는 그 인터페이스를 통해서만 트랜잭션을 다루도록 하는 거야

### 스프링의 트랜잭션 서비스 추상화

**스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다.**

스프링은 다양한 트랜잭션 기술을 지원하지만, **코드가 특정 기술에 종속되지 않도록** **공통 인터페이스(`PlatformTransactionManager`)를 제공**함.

기존에는 **JDBC, JTA 등 트랜잭션 방식마다 다른 코드**를 써야 했지만,  
이제 `PlatformTransactionManager` 인터페이스만 사용하면 트랜잭션 구현을 **바꿔도 서비스 코드 수정이 필요 없음**!

### **어떤 트랜잭션 기술을 사용할지 UserService가 직접 알 필요가 없다!**

이제 `UserService`가 직접 `Connection`을 만들고 트랜잭션을 관리하는 대신,  
스프링이 알아서 적절한 트랜잭션 매니저를 사용하도록 만들 수 있다.

이렇게 시작된 트랜잭션은 TransactionStatus 타입의 변수에 저장된다. TransactionStatus는 트랜잭션에 대한 조작이 필요할 때 PlatformTransactionManager 메소드의 파라미터로 전달해주면 된다.

트랜잭션이 시작됐으니 이제 JdbcTemplate을 사용하는 DAO를 이용하는 작업을 진행한다. 스프링의 트랜잭션 추상화 기술은 앞에서 적용해봤던 트랜잭션 동기화를 사용한다. PlatformTransactionManager로 시작한 트랜잭션 동기화 저장소에 저장된다. PlatformTransactionManager를 구현한 DataSourceTransactionManager 오브젝트는 JdbcTemplate에서 사용될 수 있는 방식으로 트랜잭션을 관리해준다. 따라서 PlatformTransactionManager를 통해 시작한 트랜잭션은 UserDao의 JdbcTemplate 안에서 사용된다.

### 트랜잭션 기술 설정의 분리

JTATransactionManager는 주요 자바 서버에서 제공하는 JTA 정보를 JNDI를 통해 자동으로 인식하는 기능을 갖고 있다. 따라서 별다른 설정 없이 JTATransactionManager를 사용하기만 해도 서버의 트랜잭션 매니저/서비스와 연동해서 동작한다.

**어떤 트랜잭션 매니저 구현 클래스를 사용할지 UserService 코드가 알고 있는 것은 DI 원칙에 위배된다.** 자신이 사용할 구체적인 클래스를 스스로 결정하고 생성하지 말고 컨테이너를 통해 외부에서 제공받게 하는 스프링 DI의 방식으로 바꾸자.

## **DI와 트랜잭션 추상화를 통해 코드 독립성을 높이자!**

1. **스프링의 트랜잭션 추상화(`PlatformTransactionManager`)를 사용하면 JDBC, JPA, JTA 등과 독립적인 코드 작성 가능**
2. **DI(의존성 주입)를 활용하면 트랜잭션 기술 설정을 분리할 수 있음**
3. **`@Transactional`을 사용하면 트랜잭션 관리가 더 간단해짐**
4. **비즈니스 로직(UserService)과 트랜잭션 관리 코드가 완전히 분리되어 유지보수가 쉬워짐**

### 서비스 추상화와 단일 책임 원칙

### 수직, 수평 계층구조와 의존관계

기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.

애플리케이션 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 하고 있다. DI의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.

### 단일 책임 원칙

**이런 적절한 분리가 가져오는 특징은 객체지향 설계의 원칙 중의 하나인 `단일 책임 원칙(Single Responsibility Principle)`으로 설명할 수 있다. 단일 책임 원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 의미다. 하나의 모듈이 바뀌는 이유는 한 가지여야 한다고 설명할 수도 있다.**

### 단일 책임 원칙의 장점

단일 책임 원칙을 잘 지키고 있다면, 어떤 변경이 필요할 때 수정대상이 명확해진다. 기술이 바뀌면 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 된다. 데이터를 가져오는 테이블의 이름이 바뀌었다면 데이터 액세스 로직을 담고 있는 UserDao를 변경하면 된다. 비즈니스 로직도 마찬가지다.

적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고, 애플리케이션 로직과 기술/환경을 분리하는 등의 작업은 갈수록 복잡해지는 엔터프라이즈 애플리케이션에는 반드시 필요하다. 이를 위한 핵심적인 도구가 바로 스프링이 제공하는 DI다.

이렇게 스프링의 의존관계 주입 기술인 DI는 모든 스프링 기술의 기반이 되는 핵심엔진이자 원리이며, 스프링이 지지하고 지원하는, 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구다. 스프링을 DI 프레임워크라고 부르는 이유는 외부 설정정보를 통한 런타임 오브젝트 DI라는 단순한 기능을 제공하기 때문이 아니다. 오히려 스프링이 DI에 담긴 원칙과 이를 응용하는 프로그래밍 모델을 자바 엔터프라이즈 기술의 많은 문제를 해결하는 데 적극적으로 활용하고 있기 때문이다.

---
## 스프링 애플리케이션에서 “메일 서비스”와 “테스트”를 어떻게 추상화하고, 유연하게 관리할 수 있을지

### 메일 서비스 추상화

### 테스트와 서비스 추상화

**일반적으로 서비스 추상화라고 하면 트랜잭션과 같은 기능은 유사하거나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 추상 인터페이스와 일관성 있는 잡근 방법을 제공해주는 것을 말한다.**

이를 적용하면 어떤 경우에도 UserService와 같은 애플리케이션 계층의 코드는 아래 계층에서는 어떤 일이 일어나는지 상관없이 메일 발송을 요청한다는 기본 기능에 충실하게 작성하면 된다.

서비스 추상화란 이렇게 원활한 테스트만을 위해서도 충분한 가치가 있다. 기술이나 환경이 바뀔 가능성이 있음에도, JavaMail처럼 확장이 불가능하게 설계해놓은 API를 사용해야 하는 경우라면 추상화 계층의 도입을 적극 고려해볼 필요가 있다.

### 테스트 대역의 종류와 특징

## **테스트와 서비스 추상화의 관계**

###  왜 추상화가 테스트에 좋은가?

- 메일 전송이나 DB 작업처럼 외부와 연결되는 기능은 테스트하기 어렵다.
- **추상화된 인터페이스를 사용하면**, 실제 구현 대신 **가짜(Mock, Stub 등)를 넣어 테스트**할 수 있다.

**테스트 환경을 만들어주기 위해, 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있도록 사용하는 이런 오브젝트를 통틀어서 `테스트 대역(test double)`이라고 부른다.**

**대표적인 테스트 대역은 `테스트 스텁(test stub)`이다. 테스트 스텁은 테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것을 말한다.**

## **테스트 대역(Test Double)의 종류**

|구분|설명|예시|
|---|---|---|
|**Test Stub**|테스트 대상이 정상 실행되도록 도와주는 가짜 오브젝트|`DummyMailSender`: 아무 작업도 안 하고 호출만 수락|
|**Mock Object**|테스트 중 일어난 커뮤니케이션(호출 여부, 횟수 등)을 저장했다가 검증|`MockMailSender`: 실제 호출 내용 기록 후 테스트에서 검증|
|Fake|동작은 비슷하지만 간단하게 구현된 오브젝트|In-memory DB 등|
|Dummy|사용되진 않지만 자리를 채우는 용도|null 방지용 객체|

---

##  **Stub vs Mock 차이**

| 구분  | Stub        | Mock                 |
| --- | ----------- | -------------------- |
| 목적  | 실행 가능하게만 해줌 | 실행 + 커뮤니케이션 확인       |
| 리턴  | 미리 정해진 값 리턴 | 테스트 후 어떤 일이 일어났는지 기록 |
| 검증  | 결과값 위주 검증   | **호출 횟수/내용 등**도 검증   |


테스트는 테스트의 대상이 되는 오브젝트에 직접 입력 값을 제공하고, 테스트 오브젝트가 돌려주는 출력 값, 즉 리턴 값을 가지고 결과를 확인한다. 테스트 대상이 받게 될 이볅 값을 제어하면서 그 결과가 어떻게 달라지는지 확인하기도 한다. 문제는 테스트 대상 오브젝트는 테스트로부터만 입력을 받는 것이 아니라는 점이다. 테스트가 수행되는 동안 실행되는 코드는 테스트 대상이 의존하고 있는 다른 의존 오브젝트와도 커뮤니케이션하기도 한다.

|핵심 개념|설명|
|---|---|
|**서비스 추상화**|기술에 종속되지 않도록 인터페이스로 감싸기 (ex. MailSender)|
|**DI 활용**|실제 구현체는 외부에서 주입 (JavaMailSender, Dummy 등)|
|**테스트 대역**|테스트에서 실제 의존 객체 대신 사용하는 가짜 오브젝트|
|**Stub**|실행만 가능하게 함|
|**Mock**|실행 + 호출 내용을 기록해 검증 가능|
|**효과**|테스트 쉽고, 유연하며 변경에 강한 코드 작성 가능|

**때론 테스트 대상 오브젝트가 의존 오브젝트에게 출력한 값에 관심이 있을 겨웅가 있다.** 또는 의존 오브젝트를 얼마나 사용했는가 하는 커뮤니케이션 행위 자체에 관심이 있을 수가 있다. 문제는 이 정보는 테스트에서는 직접 알 수가 없다는 것이다. 이때는 테스트 대상과 의존 오브젝트 사이에 주고받는 정보를 보존해두는 기능을 가진 테스트용 의존 오브젝트인 목 오브젝트를 만들어서 사용해야 한다.
테스트 대상 오브젝트의 메소드 호출이 끝나고 나면 테스트는 목 오브젝트에게 테스트 대상과 목 오브젝트 사이에서 일어났던 일에 대해 확인을 요청해서, 그것을 테스트 검증 자료로 삼을 수 있다.

목 오브젝트를 이용한 테스트라는 게, 작성하기는 간단하면서도 기능은 상당히 막강하다는 사실을 알 수 있을 것이다. 보통의 테스트 방법으로는 검증하기가 매우 까다로운 테스트 대상 오브젝트의 내부에서 일어나는 일이나 다른 오브젝트 사이에서 부고받은 정보까지 검증하는 일이 손쉽기 때문이다.

## 정리

- 비즈니스 로직을 담은 코드는 데이터 엑세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다. 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메소드로 정리돼야 한다.
- 이를 위해서는 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스와 DI를 잘 활용해서 결합도를 낮춰줘야 한다.
- DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요하다.
- 트랜잭션의 시작과 종료를 지정하는 일을 트랜잭션 경계설정이라고 한다. 트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.
- 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO에 전달하는 방법은 매우 비효율적이기 때문에 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리하다.
- 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다. 환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경돼야 한다.
- 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며, DAO가 사용하는 특정 기술에 대해 강한 결합을 만들어낸다.
- 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다.
- 서비스 추상화는 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일괄된 API를 가진 추상화 계층을 도입한다.
- 서비스 추상화는 테스트하기 어려운 JavaMail 같은 기술에도 적용할 수 있다. 테스트를 편리하게 작성하도록 도와주는 것만으로도 서비스 추상화는 가치가 있다.
- 테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이라고 한다.
- 테스트 대역은 테스트 대상 오브젝트가 원활하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공해주기도 한다.
- 테스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을 목 오브젝트라고 한다.

---

자바 EE(Java EE, Java Platform, Enterprise Edition)는 **기업용 애플리케이션 개발을 위한 자바 플랫폼** 현재는 **Jakarta EE**라는 이름으로 바뀌었음.

###  자바 EE란?

**Java EE**는 **웹 애플리케이션, 분산 시스템, 기업용 애플리케이션** 등을 개발할 때 필요한 다양한 API와 런타임 환경을 제공.

즉, **대규모 시스템을 쉽게 만들 수 있도록 도와주는 자바 기반 프레임워크**

---
###  주요 특징

|기능|설명|
|---|---|
|**컴포넌트 기반 개발**|코드 재사용과 유지보수를 쉽게 하기 위해 모듈화된 컴포넌트로 구성|
|**서버 사이드 기술 포함**|웹 서버, 애플리케이션 서버를 활용한 백엔드 개발 가능|
|**표준화**|여러 벤더가 구현한 서버에서도 동일하게 동작 (예: WildFly, GlassFish 등)|
|**대규모 트랜잭션 지원**|기업용 애플리케이션에 필수적인 트랜잭션 관리 기능 포함|
|**보안, 확장성**|인증, 권한 부여, 클러스터링 등 기업 환경에서 필요한 기능들 제공|

---
###  주요 기술 구성 요소

| 기술                                          | 설명                                |
| ------------------------------------------- | --------------------------------- |
| **Servlet**                                 | HTTP 요청/응답을 처리하는 서버 사이드 자바 프로그램   |
| **JSP (JavaServer Pages)**                  | HTML에 자바 코드를 삽입할 수 있는 기술          |
| **EJB (Enterprise JavaBeans)**              | 트랜잭션, 보안, 분산처리 등을 위한 비즈니스 로직 컴포넌트 |
| **JPA (Java Persistence API)**              | 객체와 데이터베이스 간 매핑을 처리하는 ORM 기술      |
| **JAX-RS / JAX-WS**                         | RESTful 또는 SOAP 기반 웹 서비스 개발 API   |
| **CDI (Contexts and Dependency Injection)** | 의존성 주입(DI)을 위한 표준 프레임워크           |

---
###  Java EE vs Spring

| 항목        | Java EE          | Spring             |
| --------- | ---------------- | ------------------ |
| **표준**    | Java 공식 표준       | 비공식 오픈소스           |
| **구현 방식** | 명시적 구성, 어노테이션 기반 | 더 유연한 구성, 많은 기능 제공 |
| **사용성**   | 다소 복잡하고 무거움      | 비교적 가볍고 배우기 쉬움     |
| **선호도**   | 대기업 시스템에서 많이 사용됨 | 스타트업 및 현대적 웹에서 인기  |

---
###  현재는 Jakarta EE로 진화

Oracle이 Java EE를 Eclipse 재단에 넘기면서 이름이 **Jakarta EE**로 바뀌었어요. 기술 내용은 비슷하지만, **기술 이름, 패키지 경로 등이 조금씩 변경**되고 있습니다.