> [!note] 템플릿이란?
> 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법
> 
### 예외처리 기능을 갖춘 DAO
- DB 커넥션이라는 제하적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 예외처리 원칙을 반드시 지켜야한다.
	-> 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 함(정상적인 JDBC 코드의 흐름 -> 이렇게 안하면시스템에 심각한 문제 발생 가능성 있음 )
  - JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 try/catch/finally 구문 사용을 권장
	  - try : 예외가 발생할 수 있는 코드를 감싸는 부분
	  - catch :  예외가 발생했을 때 처리할 동작
	  - finally : try 블록을 수행한 후에 예외가 발생하든 정상적으로 처리되든 상관없이 반드시 실행되는 코드를 넣을 때 사용
- 어느 시점에 예외가 발생했는지에 따라 close()를 사용할 수 있는 변수가 달라질 수 있기 때문에 finally에서는 반드시 해당 변수가  null이 아닌지를 먼저 확인한후에 close() 메서드를 호출해야 함
	-> 이 close()도 SQLException이 발생할 수 있는 메서드이기 때문에 try/catch문으로 처리해줘야 함(물론, close()가 실패했을 때 특별히 해줄 수 있는 조치가 없기 때문에 catch 블록은 비어 있음) 
##### 여기서의 문제점
- try/catch/finally 블록이 이중으로 나오고 모든 메서드마다 반복됨 
- 실수해서 c.close()와 같은 구문을 하나 빼먹으면 당장은 문제가 없는 것처럼 보이지만 언젠가 DB 풀이 정해놓은 최대 DB 커넥션 개수를 넘어설 것이고, 이렇게 되면 서버에 리소스가 꽉 찼다는 에러가 발생하면서 서비스가 중단되는 상황이 발생할 수 있다.
- 처음에는 잘 작성했더라도 추후에 수정하는 과정에서 문제가 발생할 수 있는 언제 터질지 모르는 폭탄 같은 코드가 된다.
##### 해결 방법 - 템플릿 메서드 패턴의 적용(행위 패턴)
- 템플릿 메서드 패턴 : 상속을 통해 기능을 확장해서 사용
	-> 변하지 않는 부분을 슈퍼클래스에 두고 변하는 부분을 추상 메서드로 정의해둬서 서브클래스에서 오버라이드해서 새롭게 정의해 사용하도록 하는 것   
- 템플릿 메서드 패턴은 제한이 많음
	1. DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 함
	2. 확장구조가 이미 클래스를 설계하는 시점에서 고정됨(유연성이 떨어짐)
### 전략 패턴의 적용
- 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴
	-> 개방 폐쇄 원칙을 잘 지키는 구조이면서도 템플릿 메서드 패턴보다 유연하고 확장성도 뛰어남  
- OCP 관점에서 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식 
- 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서(폐쇄) 전략을 바꿔 쓸 수 있다(개방)는 것
	-> 컨텍스트 안에서 이미 구체적인 전략 클래스를 사용하도록 고정되어 있다면 잘못된 것 
##### 클래스 파일이 많아지는 문제의 해결 방안
###### 로컬 클래스
- 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의하는 것
	-> 이 안에서만 사용되는 것들
- 내부 클래스는 자신이 정의된 메서드의 로컬 변수에 직접 접근이 가능하다는 장점이 있음   
- 내부 클래스에서 외부 변수를 사용할 때는 반드시 final로 선언해줘야 함
##### 익명 내부 클래스
- 이름을 갖지 않는 클래스
- 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용해서 **new 인터페이스 이름() { 클래스 본문 }** 과 같은 형태로 만들어 사용한다.
- 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용    
> [!note] 스프링의 빈 설정은 클래스 레벨이 아니라 런타임 시에 만들어지는 오브젝트 레벨의 의존관게에 따라 정의된다.   
##### 예시에서 인터페이스를 사용하지 않고 DI를 적용하는 것이 문제가 되지는 않는가
- 의존관계 주입이라는 개념을 충실히 따르자면, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않게 하고, 런타임 시에 의존할 오브젝트와의 관계를 동적으로 주입해주는 것이 맞다.
	-> 인터페이스를사용하지 않았다면 엄밀히 말해서 온전한 DI라고 볼 수 없지만 스프링의 DI는 넓게보자면 객체의 생성과 관계 설정에 대한 제어 권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC 개념을 포괄(이런 의미에서는 JdbcContext를 스프링을 이용해 UserDao 객체에서 사용하게 주입한 것은 DI의 기본을 따르고 있다고 볼 수 있다.)
- 인터페이스가 없다는 건 매우 긴밀한 관계를 가지고 강하게 결합되어 있다는 의미
######  JdbcContext를 UserDao와 DI 구조로 만들어야 하는 이유
1. JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문
2. JdbcContext가 DI를 통해다른 빈에 의존하고 있기 때문
	-> JdbcContext는 dataSource 속성을 통해 DataSource 오브젝트를 주입받음(DI를 위해서는 주입 되는 오브젝트와 주입 받는 오브젝트 양쪽 모두 스프링 빈으로 등록돼야 함)
##### 코드를 이용하는 수동 DI
- UserDao 내부에서 직접 DI를 적용하는 방법
	-> 이 경우에 스프링의 빈으로 등록해서 사용했던 첫 번째 이유인 싱글톤으로 만드려는 것은 포기해야 함
- DAO 메서드가 호출될 때마다 JdbcContext 오브젝트를 새로 생성하는 방법을 사용하는 것이 아니라, DAO마다 하나의 오브젝트를 가지고 있게 하는 것(개수가 훨씬 적어짐) 
- UserDao에서 JdbcContext를 직접 생성해서 사용하는 경우에도 JdbcContext는 DataSource 타입 빈을 동적으로 주입받아서 사용해야 한다.(이렇게 해야 DataSource 구현 클래스를 자유롭게 바꿔가면서 적용할 수 있다.)
	> but, JdbcContext 자신은 스프링의 빈이 아니므로 DI 컨테이너를 통해 DI 받을 수 없음
	
	-> JdbcContext에 대한 제어권을 갖고 생성과 관리를 담당하는 UserDao에게 DI까지 맡기면 된다.(UserDao가 임시로 DI 컨테이너처럼 동작하게 만드는 것)      
	-> JdbcContext에 주입해줄 의존 오브젝트인 DataSource는 UserDao가 대신 DI 받도록 한다.(UserDao가 직접 이를 필요로 하지는 않지만 JdbcContext에 대한 DI 작업에 사용할 용도)
- 이렇게 하게 된다면 굳이 인터페이스를 두지 않아도 될 만큼 긴밀한 관계를 갖는 DAO 클래스와 JdbcContext를 어색하게 따로 빈으로 분리하지 않고 내부에서 직접 만들어 사용하면서도 다른 오브젝트에 대한 DI를 적용할 수 있게 됨 
### 템플릿/콜백 패턴
- 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조로, 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식
	-> 스프링에서는 이런 방식을 템플릿/콜백 패턴이라고 부름
- 전략 패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부름 
- 템플릿 : 어떤 목적을 위해미리 만들어둔 모양이 있는 틀
- 콜백 : 실행되는 것을 목적으로 다른 오브젝트의 메서드에 전달되는 오브젝트  
##### 동작 원리
- 템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙은 이름이고 콜백은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트
- 템플릿/콜백 패턴의 콜백은 보통 단일 메서드 인터페이스를 사용
	-> 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문
	: 콜백은 일반적으로 하나의 메서드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어짐
- 하나의 템플릿에서 여러 가지 종류의 전략을 사용해야 한다면 하나 이상의 콜백 오브젝트를 사용할 수도 있다.
- 콜백 인터페이스의 메서드에는 보통 파라미터가 있고, 이 파라미터는 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용됨   
##### 일반적인 작업 흐름
![](https://i.imgur.com/i96mhq1.png)
### 콜백의 분리와 재활용
- 복잡한 익명 내부 클래스의 사용을 최소화할 수 있는 방법
	-> 변경되는 부분에 대한 정보를 파라미터로 받는 메서드로 분리
- 같은 구조의 코드가 자주 반복된다면 템플릿/콜백 패턴을 적용하기에 좋다
##### JdbcTemplate
- 스프링이 제공하는 JDBC 코드용 기본 템플릿 
- 지금까지 만들었던 JdbcContext와 유사한 기능을 하지만 더 강력하고 편리한 기능을 제공해줌  