```table-of-contents
```
## 들어가기 전에 (p.413)
- 지금까지 사용자 정보에 대한 DAO와 서비스 모듈을 만들고 발전시키는 과정을 통해 스프링의 주요 특징과 기술을 살펴봄 
- 스프링은 기본적으로 IoC와 DI를 위한 컨테이너로 동작하지만 "스플링은 단지 IoC/DI 프레임워크다"라고 말할 수 없다
	-> 스프링은 단순히 IoC/DI를 편하게 적용하도록 돕는 단계를 넘어 엔터프라이즈 애플리케이션 개발의 전 영역에 걸쳐 다양한 종류의 기술에 관여한다.
- 이번 장에서는 스프링의 이상과 가치, 그리고 적용된 원칙에 대해 좀 더 깊이 있게 살펴볼 것
	-> 스프링이란 무엇이고 왜 존재하는지 좀 더 체계적으로 이해하면 이를 통해 스프링을 더 쉽게 이해하는데 도움이 될 것   
## 8.1 스프링의 정의
- 스프링에 대해 가장 잘 알려진 정의
	: **자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크**
	-> 이것만 봐서는 바로 무엇인지 감이 오지 않을 것이지만 여기에는 스프링의 중요한 특징이 잘 담겨 있다.(이제부터 하나씩 살펴볼 것) 
##### 애플리케이션 프레임워크(p.714)
- 일반적으로 라이브러리나 프레임워크는 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어진다.(단일 목적 프레임워크)
	- 예를 들어 UI 프레임워크는 화면 구성에, ORM 프레임워크는 데이터베이스 연동에 특화되어 있습니다. 이런 전문화된 도구들은 해당 영역에서 뛰어난 기능을 제공하지만, 애플리케이션의 다른 부분은 다루지 않습니다.
		-> 프레임워크는 애플리케이션의 특정 계층에서 주로 동작하는 한 가지 기술 분야에 집중된다.
- 하지만 스프링은 일반적인 라이브러리나 프레임워크와는 다르게 '애플리케이션 프레임워크'라는 특성을 가진다.
>[!note] 애플리케이션 프레임워크
>특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말함 
>애플리케이션 개발의 전 과정을 빠르고 효율적으로 진행하는데 일차적인 목표를 두는 프레임워크이다.
>
- 스프링 프레임워크의 기원에 대한 내용이 나오는데 이 부분은 한 번 읽어보시면 좋을 듯(로드 존슨이 쓴 책의 예제에 포함된 프레임워크가 스프링 프레임워크의 기원)
	-> 이 프레임워크는 각종 자바 엔터프라이즈 개발 전략의 핵심을 담아서 개발되었고 이 책 자체가 자바 엔터프라이즈 개발의 전 계층에 등장하는 기술과 애플리케이션의 전 영역에 대한 효과적인 설계와 개발 기법을 다루고 있었기 때문에 예제 프레임워크 또한 애플리케이션 전반에 걸친 모든 분야를 포괄하고 있었다. 결과적으로 이 예제 프레임워크로부터 시작된 스프링은 자연스럽게 애플리케이션의 전 영역을 지원하는 종합적인 애플리케이션 프레임워크가 됨
- 단지 여러 계층의 다양한 기술을 한 데 모아뒀기 때문에 애플리케이션 프레임워크라고 불리는 건 아님
	-> 애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 해서 각 분야의 특성에 맞는 필요를 채워주고 있기 때문에, 애플리케이션을 빠르고 효과적으로 개발할 수 있음
	-> 스프링이 애플리케이션 프레임워크라고 불리는 이유
- 스플링이 특정 기능만을 제공하는 프레임워크라고 생각하는 이유는 스프링이 다루는 일부 영역만을 봤기 때문이며, 스프링의 일차적인 존재 목적은 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용해서 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과기능을 제공해줌으로써 애플리케이션을 편리하게 개발하게 해주는 애플리케이션 프레임워크로 사용되는 것
##### 경량급(p.716)
- 스프링 자체가 아주 가볍다거나 작은 규모의 코드로 이뤄졌다는 뜻은 아님
	-> 오히려 매우 복잡하고 방대한 규모의 프레임워크이지만 불필요하게 무겁지 않다는 의미
	-> 불필요한 복잡함의 예시는 자바 엔터프라이즈 기술
- 불필요한 복잡함의 예시로 EJB에 대한 내용이 나오는데 따로 읽어보기 바람
- EJB와 다르게 스프링은 가장 단순한 서버 환경인 톰캣이나 제티에서도 완벽하게 동작
	-> 단순한 개발툴과 기본적인 개발환경으로도 엔터프라이즈 개발에서 필요로 하는 주요한 기능을 갖춘 애플리케이션을 개발하기에 충분(그만큼 개발 과정이 단순해짐)
- 스프링을 기반으로 제작되는 코드가 기존 EJB나 다른 프레임워크에서 동작하기 위해 만들어진 코드에 비해 상대적으로 작고 단순하다는 뜻
	-> 코드에 불필요하게 등장하던 프레임워크와 서버 환경에 의존적인 부분을 제거해주기 때문
##### 자바 엔터프라이즈 개발을 편하게(p.717)
- 기존에 등장했던 대부분의 자바 엔터프라이즈 기술과 프레임워크는 저마다 '개발을 편하게 해준다.'라고 주장하고 있지만, 스프링이 말하는 같은 말은 그 무게가 다르다.
	-> 스프링은 근본적인 부분에서 엔터프라이즈 개발의 복잡함을 제거해내고 진정으로 개발을 편하게 해주는 해결책을 제시
- 편리한 애플리케이션 개발이란 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서도 애플리케이션의 핵심인 사용자의 요구사항, 즉 비즈니스 로직을 빠르고 효과적으로 구현하는 것을 말함
	-> EJB의 목표도 이와 같았으나, 이 과정에서 다른 차원의 더 큰 복잡함을 애플리케이션 개발에 끌고 들어오는 실수를 저지름. 스프링도 당시 EJB의 잘못된 접근 방법에 대한 대안을 모색하는 중에 등장했고 EJB가 궁극적으로 이루고자 했던 목적을 제대로 실현했다.
- 초기에 스프링의 기본 설정과 적용 기술만 잘 선택하고 준비해두면, 애플리케이션 개발 중에는 스프링과 관련되 코드나 API에 대해 개발자가 거의 신경 쓸 일이 없음
	-> 개발자들은 애플링케이션의 로직에 더 많은 관심과 시간을 투자할 수 있게됨


##### 오픈소스(p.718)
- 스프링은 오픈소스 프로젝트 방식으로 개발돼옴
	-> 지금도 여전히 오픈소스 개발 모델과 오픈소스 라이선스를 가지고 개발 중
> [!note] 오픈소스
> 소스가 모두에게 공개되고, 특별한 라이선스를 취득할 필요없이 얼마든지 가져다 자유롭게 이용해도 된다는 뜻
> 소스를 자유롭게 열람하고 자신의 목적에 맞게 사용할 수 있을 뿐만 아니라, 필요하면 맘대로 수정할 수 있고, 수정된 제품과 소스를 다시 공개적으로 배포하는 자유도 허용됨
- 스프링에 적용된 오픈소스 라이선스는 오픈소스 라이선스 중에서도 비교적 제약이 적고 사용이 매우 자유로운 편인 아파치 라이선스 버전 2.0
- 개발 과정에 많은 사람이 자유롭게 참여한다는 것이 오픈소스 프로젝트로서 스프링이 가진 장점
- 다음으로 오픈소스의 장단점에 대해 나오는데 이 부분은 읽어보면 좋을 듯
## 8.2 스프링의 목적(p.721)
- 어떤 기술이나 지식은 그 목표를 분명히 알고 사용하지 않으면 그 가치를 제대로 얻기 힘듦
	-> 스프링도 목적을 제대로 이해하고, 그 목적을 이루는 도구로 스프링을 잘 활용해야만 스프링으로부터 제대로 된 가치를 얻을 수 있음
- 스프링을 통해 궁극적으로 이루려고 하는 것
	: 경량급 프레임워크인 스프링을 활용해서 엔터프라이즈 애플리케이션 개발을 편하게 하는 것
### 8.2.1 엔터프라이즈 개발의 복잡함(p.723)
#### 복잡함의 근본적인 이유
1. 기술적인 제약조건과 요구사항이 늘어가기 때문
	- 엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템
		-> 많은 사용자의 요청을 동시에 처리해야 하기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다.
		-> 중요한 기업의 핵심 정보를 처리하거나 미션 크리티컬한 시스템을 다루기도 하기 때문에 보안과 안정성, 확장성 면에서도 뛰어나야 한다.
		=> 뛰어난 성능과 서비스의 안정성이 요구되고 그런 점을 고려한 개발 기술이 필요
	- 즉, 엔터프라이즈 시스템을 개발하는 데는 순수한 비즈니스 로직을 구현하는 것 외에도 기술적으로 고려할 사항이 많다는 뜻     
		-> 개발자는이런 종류의 기술적인 문제를 고려하면서 애플리케이션을 개발해야 하는 부담을 안게 됨
2. 엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복잡함이 증가하기 때문 
	- 예전에는 기업 업무 중 회계처럼 복잡한 계산이나 빠른 분석 작업이 필요한 영역에서만 IT 시스템을 활용했지만 점차 대부분의 업무 처리는 컴퓨터를 사용하지 않고는 처리하기 힘들 만큼 엔터프라이즈 시스템에 대한 업무 의존도가 높아짐
		-> 엔터프라이즈 시스템이 관여하는 업무의 비율이 급격하게 커지고 있기 때문에 애플리케이션 개발도 힘들고 복잡해짐
3. 경제 흐름과 사회의 변화, 업계의 추이에 따라서 수시로 업무 프로세스를 변경하고 조정하는 것을 상시화할 만큼 변화의 속도가 빨라짐
	- 업무구조와 프로세스의 변화는 이를 뒷받침해야 하는 엔터프라이즈 시스템의 변경을 요구할 수 밖에 없음
	- 기능 요구사항과 업무 정책 등의 변경에 따라 애플리케이션을 자주 수정해줘야 하는 시대가 됨
		-> 시스템 개발과 유지보수, 추가 개발 등의 작업에 대한 부담이 커지고 그에 따른 개발의 난이도가 증가
#### 복잡함을 가중시키는 원인(p.724)
- 엔터프라이즈 애플리케이션 개발이 실패하는 주요 원인은 비즈니스 로직의 복잡함과 기술적인 복잡함이다.
	-> 자바 엔터프라이즈 시스템 개발이 어려운 이유는 근본적인 비즈니스 로직과 엔터프라이즈 기술이라는 두 가지 복잡함이 한데 얽혀 있기 때문
- 전통적인 자바 엔터프라이즈 개발 기법은 대부분 비즈니스 로직의 복잡한 구현 코드와 엔터프라이즈 서비스를 이용하는 기술적인 코드가 자꾸 혼재될 수 밖에 없는 방식
	-> 개발자가 이 두 가지를 동시에 고려해서 개발해야 하는 과도한 부담을 주고, 전체적인 복잡함이 몇 배로 가중됨
### 8.2.2 복잡함을 해결하려는 도전(p.725)
##### 제거될 수 없는 근본적인 복잡함
- 근본적으로 엔터프라이즈 개발에 나타나는 복잡함의 원인은 제거 대상이 아니며, 대신 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 필요
	-> 구현해야 할 비즈니스 로직의 적용범위를 줄이고, 기술적인 요구조건을 일부 생략한다면 그만큼 개발은 편해질 것이고 적어도 실패하지 않을 수도 있음
	-> 이는 현실적으로 불가능함.(기술적인 복잡함을 해결하고자 보안을 취약하게 방치한다거나, 사용자가 늘어나도 더 이상 확장이 불가능한 시스템을 만들 수는 없다.)
- 비즈니스 로직의 복잡함을 효과적으로 다루기 위한 방법과 기술적인 복잡함을 효과적으로 처리하는데 적용되는 방법이 다름
	-> 두 가지 복잡함이 코드에 함께 나타나는 전통적인 개발 방식에서는 효과적으로 복잡함을 다루기가 힘듦
- 가장 먼저 성격이 다른 이 두 가지 복잡함을 분리해야 함
##### 실패한 해결책 : EJB
- EJB도 개발자가 로우레벨의 기술적인 복잡함에 신경 쓰지 않고 비즈니스 로직을 효과적으로 개발하는 데 더 집중할 수 있게 하자는 목표가 있었음  
	-> 두 가지 종류의 복잡함을 분리하는 것
	=> 하지만 실패함
- EJB를 통해 애플리케이션 로직을 담은 핵심 코드에서 일부 기술적인 코드가 제거된 것은 사실이지만, 오히려 EJB는 환경과 스펙에 종속되는 코드로 만들어져야 하는 더 큰 부담을 안게 됨
- EJB라는 틀 안에서 자바 코드를 만들게 강제함으로써 자바 언어가 갖고 있던 장점마저 사라짐
	1. EJB의 특정 클래스를 상속하게 하여 더 이상 상속구조를 적용하지 못하게 함
	2. 다형성 적용을 근본적으로 제한
	-> 객체지향적은 특성은 잃어버린 밋밋한 서비스 스크립트성 코드로 변질됨
- 어느정도 개선되긴 했지만 여전히 서버 환경에 의존적인 기능을 요구하는 단점이 남아 있고, 이미 인식이 나빠져서 외면 받고 있음. 추가적으로 발전 주기가 너무 느려서 엔터프라이즈 개발 기술의 발전을 따라잡지 못하는 중
##### 비전투적인 방식을 통한 효과적인 해결책: 스프링
- EJB의 목표와 같이 기술적인 복잡함을 애플리케이션 핵심 로직의 복잡함에서 제거하는데 목표를 둠
- EJB처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우, 이를 침투적인 기술이라고 함(꼭 필요한 경우는 어쩔 수 없긴 함)
	<-> 비침투적인 기술은 기술의 적용 사실이 코드에 직접 반영되지 않는다는 특징을 가짐(코드의 설계나 구현 방식을 제한하지 않음)
 - 스프링은 비침투적인 기술이라는 전략을 택했기 때문에 성공할 수 있었음
	 -> 결과는 성공적. 물론 스프링을 적용한다고 해서 근본적인 복잡함의 원인이 사라지지는 않지만, 스프링을 통해 성격이 다른 복잡함들을 깔끔하게 분리해줬기 때문에 각각을 효과적으로 상대할 수 있는 기반이 마련됨
### 8.2.3 복잡함을 상대하는 스프링의 전략(p.728)
#### 기술적 복잡함을 상대하는 전략
##### 첫 번째 문제 : 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다.
- 환경이 바뀌고, 서버가 바뀌고, 적용되는 조건이 바뀌면 적용하는 기술이 달라지고 그에 따라 코드가 바뀐다는 건 심각한 문제(일관성 X)
- 이런 일관성 없는 기술과 서버 환경의 변화에 대한 스프링의 공략 방법은 **서비스 추상화**
	-> 기술적인 복잡함은 일단 추상화를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고, 환경과 세부 기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책
##### 두 번째 문제 : 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.
ex) 비즈니스 로직전후로 경계가 설정돼야 하는 트랜잭션, 비즈니스 로직에 대한 보안 적용, 계층 사이에 주고받는 데이터와 예외의 일괄 변환이나 로깅이나 감사 기능 등이 대표적
	-> 책임에 따라 계층을 구분하고 그 사이에 서로의 기술과 특성에 의존적인 인터페이스나 예외처리 등을 최대한 제거한다고 할지라도 근본적으로 엔터프라이즈 서비스를 적용하는 한 이런 문제를 쉽게 해결할 수 없음
- 스프링은 이런 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하기 위해 AOP라는 접근 방법을 사용
- AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술
	1. **핵심 개념**: 비즈니스 로직과 부가 기능(로깅, 트랜잭션, 보안 등)을 분리하여 코드의 모듈성과 재사용성을 높입니다.
	2. **작동 방식**:
	    - 핵심 비즈니스 로직에 영향을 주지 않으면서 부가 기능을 추가할 수 있습니다.
	    - 관점(Aspect)에 기반하여 코드의 특정 지점(Join Point)에 기능을 삽입합니다.
	3. **주요 요소**:
	    - Aspect: 여러 객체에 적용되는 공통 기능
	    - Join Point: 코드 실행 중 Aspect가 적용될 수 있는 지점
	    - Advice: 특정 Join Point에서 실행되는 코드 (before, after, around 등)
	    - Pointcut: Advice가 적용될 Join Point를 선별하는 표현식
	4. **장점**:
	    - 코드 중복 감소
	    - 비즈니스 로직과 기술적 코드의 명확한 분리
	    - 유지보수성 향상
	    - 코드 가독성 증가
	5. **실제 응용**: 주로 로깅, 트랜잭션 관리, 보안, 캐싱, 에러 처리 등의 공통 기능을 구현할 때 사용됩니다.

	AOP는 객체지향 프로그래밍(OOP)을 보완하는 개념으로, 복잡한 시스템에서 코드의 모듈화와 관심사의 분리를 효과적으로 달성할 수 있게 해줍니다.
##### 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략(p.729)
- 비즈니스 로직을 담은 코드는 애플리케이션에서 가장 중요한 핵심이 되는 부분이며, 업무의 변화에 따라 자주 변경되거나 수정되는 부분
- 기술적인 부분이나 사용자 인터페이스에 관한 오류가 발생했을 경우에는 시스템을 복구하거나 빠르게 대응해주면 당장 큰 문제가 발생하지는 않지만, 비즈니스 로직을 다루는 핵심 코드에 오류가 있으면 엔터프라이즈 시스템을 사용하는 업무 자체에 큰 지장을 주거나 치명적인 손실을 끼칠 수 있음      
- 예전에는 비즈니스 로직의 상당 부분을 DB에 두는 것이 유행
	-> SQL을 통해 비즈니스 로직을 표현하고, DB에서 동작하는 저장 프로시저를 통해 핵심 로직을 처리하는 경우도 많았음
	-> 엔터프라이즈 시스템의 규모가 커지고, 복잡함이 증가하면서 DB에 비즈니스 로직을 두는 것은 매우 불편하고 위험한 일이라고 여겨짐
	1. 유지보수의 어려움
		- DB내 저장 프로시저나 트리거로 구현된 비즈니스 로직은 애플리케이션 코드보다 디버깅과 유지보수가 어려움
		- 변경사항 추적이 어려워 버전 관리 시스템을 효과적으로 활용하기 어려움
	2. 테스트의 복잡성
		- dB에 있는 로직은 단위 테스트가 어려움
		- 자동화된 테스트 환경 구축이 복잡해지고, 테스트 실행 속도가 느려짐
	3.  기술 종속성 증가
	    - 특정 DB 기술(Oracle PL/SQL, MS SQL 저장 프로시저 등)에 종속되어 DB 변경 시 많은 비용이 발생합니다.
	    - DB 벤더 종속성(vendor lock-in) 문제가 심화됩니다.
	4. 확장성 제한
	    - 부하 분산이나 스케일링 시 애플리케이션 레이어보다 DB 레이어 확장이 어렵습니다.
	    - 클라우드 환경에서의 유연한 확장을 방해합니다.
	5. 복잡한 배포 프로세스
	    - DB 스키마 변경과 비즈니스 로직 변경을 동시에 관리해야 하므로 배포가 복잡해집니다.
	    - 롤백이나 단계적 배포가 어려워집니다.
	6. 팀 협업의 어려움
	    - 개발자와 DBA 간의 역할 구분이 모호해지고 책임 소재가 불분명해집니다.
	    - 서로 다른 기술 스택을 가진 팀 간 협업이 어려워집니다.
	7. 보안 위험 증가
	    - 비즈니스 로직이 DB에 있으면 데이터 접근 권한이 필요한 영역이 넓어져 보안 취약점이 증가할 수 있습니다.
	8. 아키텍처 일관성 저하
	    - 비즈니스 로직이 애플리케이션과 DB에 분산되어 있으면 시스템 전체의 일관성과 이해도가 떨어집니다.
- 엔터프라이즈 시스템 개발의 흐름은 비즈니스 로직은 애플리케이션 안에서 처리하도록 만드는 추세   
	-> DB는 단지 데이터의 영구적인 저장과 복잡한 조건을 가진 검색과 같은 자체적으로 특화된 기능에만 활용하고, 데이터를 분석하고 가공하고 그에 따라 로직을 처리하는 부분은 확장하기 쉽고, 비용도 싼 애플리케이션 서버 쪽으로 이동하는것
	-> 오브젝트에 담긴 로직은 테스트하기 쉬움(목 오브젝트를 이용하면 DB가 없어도 테스트 가능)       
##### 핵심 도구 : 객체지향과 DI(p.731)
- 스프링의 모토는 '기본으로 돌아가자'이다 
	-> 자바의 기본인 객체지향에 충실한 설계가 가능하도록 단순한 오브젝트로 개발할 수 있고, 객체지향의 설계 기법을 잘 적용할 수 있는 구조를 만들기 위해 DI 같은 유용한 기술을 편하게 적용하도록 도와주는 것이 스프링의 기본 전략
- 기술적인 복잡함을 효과적으로 다루게 해주는 기법은 모두 DI를 바탕으로 함
	ex) 서비스 추상화, 템플릿/콜백, AOP 등
- 비즈니스 로직 자체의 복잡함을 해결하려면 DI보다는 객체지향 설계 기법이 더 중요
- 스프링이 비즈니스 로직 자체를 기술적인 코드와 특정 기술의 스펙이 침범하지 않는 코드로 만드려고 노력했는가?
	: 순수한 비즈니스 로직만을 담고 있는 코드에는 객체지향 분석과 설계에서 나온 도메인 모델을 쉽게 적용할 수 있기 때문
	-> 기술적인 코드에 침범당하지 않았다면 객체지향적인 특성을 잘 살린 설계를 비즈니스 로직을 구현하는 코드에 그대로 반영할 수 있음  
- 결국모든 스프링의 기술과 전략은 객체지향이라는 자바 언어가 가진 강력한 도구를 극대화해서 사용할 수 있도록돕는 것  
## 8.3 POJO 프로그래밍(p.732)
- 기술적인 부분에서의 스프링이 지향하는 목적
	-> 분리됐지만반드시 필요한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 애플리케이션 핵심 로직을 담은 코드에 제공
### 8.3.1 스프링의 핵심 : POJO
![](https://i.imgur.com/rKNLe4A.png)
- 그림 8-1은 스프링으로 개발한 애플리케이션의 기본 구조를 보여줌
	-> 스프링 애플리케이션은 POJO를 이용해서 만든 애플리케이션 코드와, POJO가 어떻게 관계를 맺고 동작하는지를 정의해놓은 설계정보로 구분됨  
- DI의 기본 아이디어는 유연하게 확장 가능한 오브젝트를 만들어두고 그 관계는 외부에서 다이내믹하게 설정해준다는 것(DI -> 객체 간의 의존성을 외부에서 주입)
- POJO(Plain Old Java Object): 특별한 제약 없이 단순하게 설계된 자바 객체로, 스프링의 중심 철학입니다.
- IoC/DI(Inversion of Control/Dependency Injection): 객체 간의 의존성을 외부에서 주입하는 방식으로, 객체 결합도를 낮추고 유연성을 높입니다.
- AOP(Aspect-Oriented Programming): 공통 관심사(로깅, 보안, 트랜잭션 등)를 모듈화하여 코드 중복을 줄이고 핵심 비즈니스 로직에 집중할 수 있게 합니다.
- PSA(Portable Service Abstraction): 특정 기술에 종속되지 않는 추상화 계층을 제공하여 기술 전환 시 코드 변경을 최소화합니다.
- 스프링의 주요 기술인 IoC/DI, AOP와 PSA는 애플리케이션을 POJO로 개발할 수 있게 해주는 가능 기술이라고 불림
### 8.3.2 POJO란 무엇인가?(p.734)
- Plain Old Java Object의 약자
- EJB와 같은 그럴듯한 이름이 없어서 사용하기 꺼린다고 생각해 마틴 파울러가 컨퍼런스 준비하다가 만들어낸 용어(생각보다 성공적..?) 
### 8.3.3 POJO의 조건
1. 특정 규약에 종속되지 않는다.
	- POJO는 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 함
		-> EJB2는 특정 규약을 따라 비즈니스 컴포넌트를 만들어야 하므로 POJO가 아님
		-> 특정 규약을 따라 만들게 하는 경우, 대부분 규약에서 제시하는 특정 클래스를 상속하도록 요규하고, 그럴 경우 자바의 단일 상속 제한 때문에 더 이상 해당 클래스에 객체지향적인 설계 기법을 적용하기 어려워지는 문제가 생김
		-> 규약이 적용된 환경에 종속적이 되기 때문에 다른 환경으로 이전이 힘들어짐
	- 규약에 종속되지 않아야 하고, 객체지향 설계의 자유로운 적용이 가능한 오브젝트여야만 POJO라고 불릴 수 있음     
2. 특정 환경에 종속되지 않는다.
	- 특정 환경에 종속적이어야만 동작하는 오브젝트는 POJO라고 할 수 없음 
	- 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안됨
		: 나중에 웹 컨트롤러와 연견돼서 사용될 것이 뻔하다고 할지라도 직접적으로 웹이라는 환경으로 제한해버리는 오브젝트나 API에 의존해선 안됨 
		-> 웹 외의 클라이언트가 사용하지 못하게 됨
		-> 웹 서버에 올리지 않고 독립적으로 테스트하기 힘들어짐
		-> 수정도 어려워짐
	- 어노테이션을 사용했을 경우에는 POJO일까?
		-> 어노테이션이 단지 코드로 표현하기는 적절치 않은 부가적인 정보를 담고 있고, 그 때문에 환경에 종속되지만 않는다면 여전히 POJO라고 할 수 있음
		-> 어노테이션이나 엘리먼트 값에 특정 기술과 환경에 종속적인 정보를 담고 있다면 그때는 POJO로서의 가치를 잃어버림
##### 많은 개발자들이 오해하는 부분
- 특정 기술규약과 환경에 종속되지 않으면 모두 POJO인가?
	-> 아니다!
- 진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말함
- POJO에 애플리케이션의 핵심 로직과 기능을 담아 설계하고 개발하는 방법을 POJO 프로그래밍이라고 함
### 8.3.4 POJO의 장점(p.737)
- POJO가 될 수 있는 조건이 그대로 POJO의 장점이 된다.
1. 특정한 기술과 환경에 종속되지 않는 오브젝트는 그만큼 깔끔한 코드가 될 수 있음 
	-> 개발, 디버깅, 검증 및 테스트 작성에 유리해짐 
2. POJO로 개발된 코드는 자동화된 테스트에 매우 유리
	-> 어떤 환경에도 종속되지 않은 POJO 코드는 매우 유연한 방식으로 원하는 레벨에서 코드를 빠르고 명확하게 테스트 가능
3. 객체지향적인 설계를 자유롭게 적용할 수 있음
	-> 도메인 모델과 디자인 패턴 등은 POJO가 아니라면 적용하기 힘듦
### 8.3.5 POJO 프레임워크(p.738)
- POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크를 POJO 프레임워크라고 한다.
	-> 스프링 프레임워크와 하이버네이트가 대표적
	1. 하이버네이트 : 주로 DB 이용 기술에 POJO를 적용하는 것을 목적으로 함
	2. 스프링 : 엔터프라이즈 애플리케이션 개발의 모든 영역과 계층에서 POJO 방식의 구현이 가능하게 하려는 목적
- 스프링을 이용하면 POJO 프로그래밍의 장점을 그대로 살려서 엔터프라이즈 애플리케이션의 핵심 로직을 객체지향적인 POJO를 기반으로 깔끔하게 구현하고, 동시에 엔터프라이즈 환경의 각종 서비스와 기술적인 필요를 POJO 방식으로 만들어진 코드에 적용할 수 있음  
 ![](https://i.imgur.com/n5bGy2h.png)
- POJO 프레임워크로서 스프링은 자신을 직접 노출하지 않으면서 애플리케이션을 POJO로 쉽게 개발할 수 있게 해줌
	-> 스프링은 매우 자연스럽게 개발자가 좋은 코드를 작성하게 해줌
## 8.4 스프링의 기술
- 스프링은 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 세 가지 가능기술을 제공
### 8.4.1 제어의 역전(IoC)/의존관계 주입(DI)
- 나머지 두 기술인  APO와 PSA도 IoC/DI을 바탕으로 함(템플릿/콜백 패턴이 적용된 부분도)
- 기본 원리에 대해서는 1장에서 살펴봤으니 여기서는 활용 방법에 대해 생각해볼 것
- 두 개의 오브젝트를 분리해서 만드록, 인터페이스를 두고 느슨하게 연결한 뒤, 실제 사용할 대상은 DI를 통해 외부에서 지정하는 이유
	-> 유연한 확장이 가능하게 하기 위해서
- DI는 개방 폐쇄 원칙이라는 객체지향 설계 원칙으로 잘 설명될 수 있음
	-> 유연한 확장이라는 장점은 OCP의 '확장에 열려 있다(개방)'에 해당하며, DI는 OCP의 '변경에는 닫혀 있다(폐쇄)'라는 말로 설명이 가능하다. 
##### DI의 활용 방법
1. 핵심 기능의 변경
	- DI의 가장 대표적인 적용 방법은 의존 대상의 구현을 바꾸는 것
		ex) DAO의 구현을 JDBC로 했다가, 그것을 JPA, 하이버네이트, JDO, iBatis 등으로 변경하는 것 
2. 핵심 기능의 동적인 변경
	- 첫 번째와 비슷하게 의존 오브젝트의 핵심 기능 자체를 바꾸는 것
		-> 일반적인 DI를 이용한 변경 방법과는 달리, 동적으로 매번 다르게 변경 가능 
	- DI도 기본적으로는 런타임 시에 동적으로 의존 오브젝트를 연결해주지만 일단 DI되고 나면 그 후로는 바뀌지 않음
		-> 즉 동적인 방식으로 연결되지만 한 번 DI되면 바뀌지 않는 정적인 관계를 맺는 것
	- DI를 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존 대상을 동적으로 변경할 수 있음
		ex) DAO 하나가 여러 개의 DataSource에 의존하게 만들고 접속한 사용자의 등급에 따라 그때그때 다른 DataSource를 DAO가 사용하게 함
		ex) 사용자별로 모두 독립적인 의존 오브젝트를 둠
			-> 핵심기능이 바뀐다기보다는 기능은 같지만 독립적인 상태 정보를 저장할 수 있는 자신만의 오브젝트를 가질 수 있음
	- 동적인 방식으로 핵심 기능을 변경하는 것은 기술적으로 다이나믹 라우팅 프록시나 프록시 오브젝트 기법을 활용한 것
3. 부가 기능의 추가
	- 핵심 기능은 그대로 둔 채로 부가 기능을 추가하는 것
	- 대표적인 예로 데코레이터 패턴
		: 인터페이스를 두고 사용하게 하고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용해두면 데코레이터 패턴을 쉽게 적용할 수 있음
		-> 핵심 기능과 클라이언트 코드에는 전혀 영향을 주지 않으면서 부가적인 기능을 얼마든지 추가할 수 있음
	- 부가 기능의 추가 방식을 특정 오브젝트가 아니라 좀 더 많은 대상으로 일반화해서 적용하면 APO가 됨
4. 인터페이스의 변경
	- 클라이언트가 사용하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우에도 DI가 유용
		-> 디자인 패턴에서 말하는 오브젝트 방식의 어댑터 패턴의 응용으로 볼 수 있음
	- 이를 좀 더 일반화해서 아예 인터페이스가 다른 다양한 구현을 같은 방식으로 사용하도록, 중간에 인터페이스 어댑터 역할을 해주는 레이어를 하나 추가하는 방법
		-> DI의 응용 방법 중 하나이자 스프링의 대표적인 기술로도 분류되는 일관성 있는 서비스 추상화(PSA)가 그 방법이다.
	 - PSA는 클라이언트가 일관성 있게 사용할 수 있는 인터페이스를 정의해주고 DI를 통해 어댑터 역할을 하는 오브젝트를 이용하게 해줌
		-> 이를 통해 다른 인터페이스를 가진 로우레벨의 기술을 변경하거나 확장해가면서 사용 가능해짐
5. 프록시
	- 프록시 패턴의 전형적인 응용 방법
		-> 필요한 시점에서 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연된 로딩을 적용하려면 프록시가 필요
		-> 원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 프록시 필요
		=> 두 방법 모두 DI를 필요로 함
6. 템플릿과 콜백
	- 템플릿/콜백패턴은 DI의 특별한 적용 방법
		-> 반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿과 콜백으로 만들고 이를 DI 원리를 응용해 적용하면 코드를 간결하게 만들 수 있음
	- DI의 원리에 가장 충실한 응용 방법
		- 콜백을얼마든지만들어 사용할 수 있다는 것은 개방을 통한 유연한 확장성을 보여줌
		- 템플릿은 한 번 만들어두면 계속 재사용할 수 있다는 것으로 기능의 확장에도 변하지 않는 다는 것을 보여줌(폐쇄)
7. 싱글톤과 오브젝트 스코프
	- DI가 필요한 중요한 이유 중 한가지는 DI 할 오브젝트의 생명주기를 제어할 수 있다는 것
		-> DI를 프레임워크로 이용한다는 건 DI 대상 오브젝트를 컨테이너가 관리한다는 의미
		-> 오브젝트의 스코프를 자유롭게 제어 가능
	- 가장 기본이 되는 스코프는 싱글톤
		- 하나 또는 소수의 오브젝트가 수많은 클라이언트를 상대로 고성능 서비스를 제공하는 방식은 엔터프라이즈 개발에서 매우 중요
		- 상태를 갖지 않도록 만든 오브젝트가 동시에 여러 스레드의 요청을 처리하는 이런 방식을 적용하려면, 만들어지는 오브젝트의 개수를 제어하는 일이 매우 중요
		- 전통적인 싱글톤 패턴은 오브젝트에 많은 제약을 가해서 만들어지기 떄문에 그다지 권장되지 않음
			-> 컨테이너가 오브젝트를관리하는 IoC 방식이 유용
		- 스프링의 DI는기본적으로 싱글톤으로 오브젝트를 만들어서 사용하게 하며 컨테이너가 알아서 싱글톤을 만들고 관리하기 때문에 클래스 자체는 싱글톤을 고려하지 않고 자유롭게 설계해도 된다는 장점이 있음
	- 스플링에서는 싱글톤 외에도 다양한 스코프를 갖는 오브젝트를 만들어 DI 에 사용할 수도 있다.(prototype 같은게 있었던 것 같음 -> 요청할 때마다 새롭게 생성해서 반환해주는 것)
8. 테스트
	- 여러 오브젝트와 협력해서 동작하는 오브젝트를 효과적으로 테스트하는 방법은 가능한 고립시키는 것
		-> 다른 오브젝트와의 사이에서 일어나는 일을 테스트를 위해 조작할 수 있게 만듦
		->이래야 테스트 대상인 오브젝트의 기능에 충실하게 테스트가 가능
	- 위의 것을 지키지 않는다면 원래 테스트하는 클래스 이외의 것에 대해서도 테스트를 진행해야 하는 오버헤드 발생
	- 테스트할 대상이 의존하는 오브젝트를 테스트를 목적으로 만들어진 목 오브젝트로 대체하면 유용
9. 이외
	- DI의 용도는 디자인 패턴 중에서 인터페이스르 두고 오브젝트를 분리하는 구조를 가진 오브젝트 스코프의 패턴은 DI의 구조에 대부분 잘 들어맞음
		-> 이런 패턴의 장점들을 애플리케이션 전 영역에서 간단한 설정만으로 자연스럽게 적용할 수 있게 만들어주는 것이 DI
	- 이런 활용 방법은 한 번에 한 가지만 선택적으로 사용해야 하는게 아니라 여러 가지 활용 방법을 한 번에 적용할 수도 있음
### 8.4.2 AOP
- 스프링의 목적인 POJO 만으로 엔터프라이즈 애플리케이션을 개발하면서도 엔터프라이즈 서비스를 선언적으로 제공하는 데 반드시 필요한 것이 AOP 기술
1. 스프링과 같이 다이나믹 프록시를 사용하는 방법
	- 기존 코드에 영향을 주지 않고 부가 기능을 적용하게 해주는 데코레이터 패턴을 응용한 것
	- 자바의 객체지향 패턴을 활용한 방법이기 때문에 만들기 쉽고 적용하기 간편하지만 부가 기능을 부여할 수 있는 곳은 메소드의 호출이 일어나는지점뿐이라는 제약이 있음
	- 부가 기능을 구현한 코드나 기능을 적용할 대상을 찾는 방법 모두 평범한 자바 클래스로 만들면 됨
	- 스프링의 기본적인 AOP 구현 방법은 다이나믹 프록시를 이용하는 프록시 AOP 방식이며 엔터프라이즈 개발에서 필요로 하는 AOP는 대부분이 이 프록시 방식의 AOP면 됨
2. 자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법
	- AspectJ는 강력한 고급 기능을 가진 AOP를 제공
	- AspectJ는 프록시 방식의 AOP에서는 불가능한 다양한 조인 포인트를 제공
		-> 메서드 호출뿐 아니라 인스턴스 생성, 필드 액세스, 특정 호출 경로를 가진 메서드 호출 등에도 부가 기능 제공 가능
	- 위에서 언급한 고급 AOP 기능은 자바 언어와 JDK의 지원만으로는 사용 불가능
##### AOP의 적용 단계(p.747)
1. 미리 준비된 AOP 이용
	- 처음에는 스프링이 미리 만들어서 제공하는 AOP 기능을 그대로 가져다 적용하는 것으로 시작
	- 트랜잭션과 @Configurable 어노테이션은 스프링이 미리 준비해서 제공하는 대표적인 AOP 기능
2. 전담팀을 통한 정책 AOP 적용
	- AOP를 책임지는 소수의 팀
	- 읽어보면 될 듯
3. AOP의 자유로운 이용
	- 개발자가 스스로 AOP를 활용 -> 읽어보자
### 8.4.3 포터블 서비스 추상화(PSA)
- 환경과 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해주는 PSA
- POJO로 개발된 코드는 특정 환경이나 구현 방식에 종속적이지 않아야 함
	-> 스프링은 JavaEE를 기본 플랫폼으로 하는 자바 엔터프라이즈 개발에 주로 사용되기 때문에 다양한 JavaEE 기술에 의존적일 수 밖에 없다.
- 특정 환경이나 기술에 종속적이지 않다는 것은 그런 기술을 사용하지 않느다는 뜻이 아니라 POJO 코드가 그런 기술에 직접 노출되어 만들어지지 않는다는 의미
	-> 이를 위해 스프링이 제공하는 대표적인 기술이 일관성 있는 서비스 추상화 기술 
- 스프링은 엔터프라이즈 개발에 사용되는 다양한 기술에 대한 서비스 추상화 기능을 제공
	-> 어떤 것은 AOP나 템플릿/콜백 패턴과 결합되어 사용되기 때문에 직접적으로 서비스를 이용할 필요가 없지만 대신 설정을 통해 어떤 종류의 기술을 사용할지 지정해줘야 함
- 때에 따라 직접 서비스 추상화 기법을 적용할 필요가 있음
- 서비스 추상화를 위해 필요한 기술은 DI 뿐
	-> 결국 DI 응용 방법의 한 가지이므로 DI를 적극 활용해서 개발한다면 서비스 추상화는 자연스럽게 만들어 쓸 수 있음
- 서비스 추상화는 구체적인 기술에 종속되지 않게 하기 위해서 사용되기도 하고 테스트가 어렵게 만들어진 API나 설정을 통해 주요 기능을 외부에서 제어하게 만들고 싶을때 사용되기도 함 