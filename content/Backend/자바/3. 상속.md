
### 있는 이유?

- 상위 클래스의 변수들을 자식 클래스에서 재사용하기 위한 것. 
- 상위클래스의 생성자와 초기화블록은 상속하지 않는다. 

### Object 클래스

- 모든 클래스의 조상 클래스
- 별도의 extends 선언이 없는 클래스들은 모두 extends Object 가 생략되어있음. 
- 따라서 모든 클래스에는 Object 클래스에 정의된 메서드가 있다. 

### 자바는 단일 상속만 지원한다. 

- 만약 다중상속을 하게되면 여러 클래스의 기능을 받는데 만약 메서드의 명이 같다면 어느 메서드를 사용할지 모름. 
- 이러한 문제들 때문에 자바에서는 단일 상속만 가능하게 해놨음. 

###### **조상과 부모 클래스 둘 다 같은 이름의 메서드를 가지고 있을 때, 어떤 게 호출돼?**
- **답:**  
    👉 자식 클래스에서 `print()`를 호출하면, **가장 가까운 클래스의 메서드가 호출돼**.  
    즉, 부모 클래스에 있는 `print()`가 먼저 사용되고, 자식이 다시 오버라이딩하면 그게 우선됨.  
    조상의 메서드는 부모와 자식 모두에 정의가 없을 때만 호출돼.

> [!important] 참고
> 다중 상속이 안되는 이유는 어떤 메서드를 사용할지 혼동이 와서 안쓴다고 했는데
> 
> 그러면 부모의 메서드들이 누적합 느낌으로 내려오니까 어떤걸 사용하냐? 
> -> 이때 부모와 자식 관계가 있을경우에는 자식의 메서드를 우선적으로 사용한다. 
> - 여기서 다중 상속을 이용해버리면 관계가 동등해서 문제가 생기는 것. 


## Sealed Class란?

`sealed class`는 **상속을 제한**할 수 있는 기능이야.
> 특정 클래스가 **누구에게만 상속 가능한지**를 명시할 수 있어.

Java 15부터 도입되었고, Java 17부터 정식 기능이야.

```
sealed class SealedStudyGroup permits Algo, CS, Java {
    public void study() {
        System.out.println("공부 공부 공부!!");
    }
}
```
- `SealedStudyGroup`은 **sealed class**로 선언되었고
- 오직 `Algo`, `CS`, `Java` 클래스만 이 클래스를 **상속**할 수 있어 (`permits` 키워드)


### 메서드 오버라이딩

- 조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정하는 것.
##### 오버라이딩 조건
- 메서드 이름이 같아야 한다. 
- 매개변수의 개수, 타입, 순서가 같아야한다. 
- 리턴타입이 같아야한다.
- 접근제한자는 부모보다 범위가 넓거나 같아야한다. 
- 조상보다 더 큰 예외를 던질 수 없다. 
- \

### Annotation 

- 사전적 의미 : 주석
- 컴파일러, JVM, 프레임워크 등이 보는 주석. 
- 소스코드에 메타 데이터를 삽입하는 형태. 
	- 소스코드에 붙여놓은 라벨
	- 코드에 대한 정보 추가, 소스 코드의 구조 변경. 


### 제한자 (modifier)

- 클래스, 변수, 메서드 선언부에 함께 사용되어 부가적인 의미를 부여한다. 
- 접근 제한자 종류 :
	- public 
	- protected
	- (default = package)
	- private

범위 차이 
> public > protected > default > private 

- 그 외 제한자
	- static
	- final
	- abstract
	- synchronized

### final class 로 선언하면 더이상 상속할 수 없음. 
- 오버라이드 방지, 상속 금지.
### final method 로 선언하면 더이상 재 정의 할 수 없음.
- 오버라이드 방지. 

