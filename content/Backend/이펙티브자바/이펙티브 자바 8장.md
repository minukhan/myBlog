## 메서드

> [!info] 메서드 
> 이번 장에서는 메서드를 설계할 때 주의할 점들을 다룬다. 매개변수와 반환값을 어떻게 처리해야 하는지, 메서드 시그니처는 어떻게 설계해야 하는지, 문서화는 어떻게 해야 하는지를 다룬다. 이번 장의 상당 부분은 메서드뿐 아니라 생성자에도 적용된다. 이전 장들과 마찬가지로 사용성, 견고성, 유연성에 집중한다.

---
### Item 49. 매개변수가 유효한지 검사하라

메서드와 생성자의 대부분은 **입력 매개변수의 값이 특정 조건을 만족하기를 바란다.**
- 예컨대 인덱스 값은 음수이면 안 되고, 객체 참조는 null이 아니어야 하는 식이다.
- 이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다.

> [!question] 
> "오류는 가능한 한 빨리 (발생한 곳에 가까운 곳에서) 잡아야 한다"는 일반 원칙의 한 사례다.
##### 매개변수 검사를 하지 않을 때의 문제점
1. **메서드가 수행되는 중간에 모호한 예외를 던지며 실패**할 수 있다.
2. 메서드가 잘 수행되지만 **잘못된 결과를 반환**할 수 있다.
3. 메서드는 문제없이 수행됐지만, **어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼** 수 있다. (실패 원자성을 어기는 결과)
##### public과 protected 메서드
- 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.
- 보통 `IllegalArgumentException`, `IndexOutOfBoundsException`, `NullPointerException` 중 하나가 될 것이다.
- 자바독의 `@throws` 태그를 사용할 수 있다.

```java
/**
 * (현재 값 mod m) 값을 반환한다. 이 메서드는
 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
 *
 * @param m 계수(양수여야 한다.)
 * @return 현재 값 mod m
 * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0)
        throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
    // 계산 수행
}
```
##### null 검사
- 자바 7에 추가된 `java.util.Objects.requireNonNull` 메서드는 유연하고 사용하기도 편하다.

```java
// 자바의 null 검사 기능 사용
this.strategy = Objects.requireNonNull(strategy, "전략");
```

- 자바 9에서는 Objects에 범위 검사 기능도 더해졌다: `checkFromIndexSize`, `checkFromToIndex`, `checkIndex`. null 검사 메서드만큼 유연하지는 않다 (예외 메시지를 지정할 수 없고, 리스트와 배열 전용으로 설계됨).
##### 단언문(assertion)
- 공개되지 않은 메서드라면 패키지 제작자가 메서드가 호출되는 상황을 통제할 수 있다.
- 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 보증할 수 있고, 그렇게 해야 한다.
- 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다.

```java
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
    // 계산 수행...
}
```

**단언문의 특징:**
- 실패하면 `AssertionError`를 던진다.
- 런타임에 아무런 효과도, 아무런 성능 저하도 없다. (단, java를 실행할 때 명령줄에서 `-ea` 혹은 `--enableassertions` 플래그를 설정하면 런타임에 영향을 준다.)
##### 매개변수 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때
- `Collections.sort(List)`처럼 객체 리스트를 정렬하는 메서드를 생각해보자.
- 리스트 안의 모든 객체들은 상호 비교될 수 있어야 하며, 정렬 과정에서 이 비교가 이뤄진다.
- 만약 상호 비교될 수 없는 타입의 객체가 들어 있다면 그 객체와 비교할 때 `ClassCastException`을 던질 것이다.
- 따라서 비교하기 앞서 리스트 안의 모든 객체가 상호 비교될 수 있는지 검사해봐야 별다른 실익이 없다.
##### 계산 과정에서 암묵적으로 검사가 수행되는 경우도 있다
- `Collections.sort(List)`에서 상호 비교될 수 없는 타입의 객체가 들어 있다면 비교 시 `ClassCastException`을 던진다.
- 하지만 때로는 계산 과정에서 던져지는 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다.
- 이런 경우라면 **예외 번역(exception translation)** 관용구를 사용하여 API 문서에 기재된 예외로 번역해줘야 한다. (Item 73)
##### 메서드는 최대한 범용적으로 설계해야 한다
- 메서드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을수록 좋다.
- 하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 많다.

> [!important] 핵심 정리 
> 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다. 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다. 이런 습관을 반드시 기르도록 하자. 그 노력은 유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상받을 것이다.

---
### Item 50. 적시에 방어적 복사본을 만들라
자바는 안전한 언어다. 이것이 자바를 쓰는 즐거움 중 하나다. 네이티브 메서드를 사용하지 않으니 C, C++ 같이 안전하지 않은 언어에서 흔히 보는 **버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전**하다.
##### 하지만 아무리 자바라 해도 불변식을 지키려 노력해야 한다
- 클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.
- 악의적인 의도가 없어도 실수로 클래스를 오작동하게 만들 수 있으니 방어적 복사를 사용해야 할 상황은 더욱 늘어난다.
##### 방어적 복사의 필요성
```java
// 잘못된 예 - 불변식을 보장하지 않는다!
public final class Period {
    private final Date start;
    private final Date end;
    
    /**
     * @param start 시작 시각
     * @param end 종료 시각; 시작 시각보다 뒤여야 한다.
     * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
     * @throws NullPointerException start나 end가 null이면 발생한다.
     */
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        this.start = start;
        this.end = end;
    }
    
    public Date start() { return start; }
    public Date end() { return end; }
}
```
- 이 클래스는 불변처럼 보이지만 `Date`가 가변이라는 사실을 이용하면 어렵지 않게 그 불변식을 깨뜨릴 수 있다.

```java
// Period 인스턴스의 내부를 공격해보자.
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78);  // p의 내부를 변경했다!
```
##### 올바른 방어적 복사 : 생성자
```java
// 수정된 생성자 - 매개변수의 방어적 복사본을 만든다.
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
    
    if (this.start.compareTo(this.end) > 0)
        throw new IllegalArgumentException(this.start + "가 " + this.end + "보다 늦다.");
}
```

**주의사항:**
- **매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사한다.**
- 순서가 부자연스러워 보이겠지만 반드시 이렇게 해야 한다.
- 멀티스레딩 환경에서는 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다. (검사시점/사용시점(time-of-check/time-of-use) 공격 혹은 TOCTOU 공격이라 한다.)
##### 접근자가 가변 필드의 방어적 복사본을 반환하게 하자
```java
// 수정된 접근자 - 필드의 방어적 복사본을 반환한다.
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```
- 이제 Period는 완벽한 불변객체가 되었다. 모든 필드가 객체 안에 캡슐화되어 있다.
##### 방어적 복사에 clone을 사용하지 말자
- **매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.**
- Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수 있다.
- 악의적인 하위 클래스가 clone을 재정의해서 원본 참조를 몰래 저장할 수도 있다.

- **다만 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다.**
- 이미 우리가 신뢰하는 객체(클래스의 필드)를 복사하는 것이기 때문이다.
- 배열은 무조건 가변이므로 clone 사용이 관용적이다.
##### 방어적 복사를 생략해도 되는 경우
- 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때
- 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때
	- e.g. 래퍼 클래스 패턴([[이펙티브 자바 4장#Item 18. 상속보다는 컴포지션을 사용하라|Item 18]])

- **다만 방어적 복사는 불변 객체를 만들기 위해서만 쓰이는 것이 아니다.** 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.

> [!important] 핵심 정리 
> 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다. 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.

---
### Item 51. 메서드 시그니처를 신중히 설계하라

이번 아이템에서는 API 설계 요령들을 모아 소개한다. 개별 항목들 중에는 자명한 것도 있지만, 이들을 숙지하여 습관화한다면 훨씬 쓰기 쉽고, 견고하고, 유연한 API를 만들 수 있을 것이다.
##### 메서드 이름을 신중히 짓자
- 항상 표준 명명 규칙을 따라야 한다. (Item 68)
- 이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는게 최우선 목표다.
- 그 다음 목표는 더 넓은 합의에 따라 짓는 것이다.
- 긴 이름은 피하자. 애매하면 자바 라이브러리의 API 가이드를 참조하라.
##### 편의 메서드를 너무 많이 만들지 말자
- 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다.
- 인터페이스도 마찬가지다. 메서드가 너무 많으면 이를 구현하는 사람과 사용하는 사람 모두를 고통스럽게 한다.
- 클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 한다.
- 아주 자주 쓰일 경우에만 별도의 약칭 메서드를 두기 바란다.
- **확신이 서지 않으면 만들지 말자.**
##### 매개변수 목록은 짧게 유지하자
- **4개 이하가 좋다.** 4개가 넘어가면 매개변수를 전부 기억하기 어렵다.
- **같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.** 사용자가 매개변수 순서를 기억하기 어려울 뿐만 아니라, 실수로 순서를 바꿔 입력해도 그대로 컴파일되고 실행된다. 단지 의도와 다르게 동작할 뿐이다.
###### 과하게 긴 매개변수 목록을 짧게 줄여주는 기법 세 가지
**1. 여러 메서드로 쪼개기**
- 쪼갠 메서드 각각은 원래 매개변수 목록의 부분집합을 받는다.
- 잘못하면 메서드가 너무 많아질 수 있지만, 직교성(orthogonality)을 높여 오히려 메서드 수를 줄여주는 효과도 있다.
- 예: `java.util.List` 인터페이스를 보자. 지정된 범위의 부분리스트에서 인덱스를 찾는 기능이 필요하다고 해보자. 이 기능을 하나의 메서드로 구현하려면 '부분리스트의 시작', '부분리스트의 끝', '찾을 원소' 이렇게 3개의 매개변수가 필요하다. 하지만 List는 `subList` 메서드와 `indexOf` 메서드를 별도로 제공한다. 덕분에 `list.subList(fromIndex, toIndex).indexOf(o)`로 원하는 목적을 달성할 수 있다.
**2. 매개변수 여러 개를 묶어주는 도우미 클래스를 만들기**
- 일반적으로 이런 도우미 클래스는 정적 멤버 클래스로 둔다. ([[이펙티브 자바 4장#Item 24. 멤버 클래스는 되도록 static으로 만들라|Item 24]])
- 특히 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 때 추천하는 기법이다.
- 예를 들어, 카드게임을 클래스로 만든다고 해보자. 메서드를 호출할 때 카드의 숫자(rank)와 무늬(suit)를 뜻하는 매개변수를 항상 같은 순서로 전달한다면, 이 둘을 묶는 도우미 클래스를 만들어 하나의 매개변수로 주고받으면 API는 더 나아질 것이다. 특히 이 도우미 클래스를 불변으로 만들면 더욱 좋다. ([[이펙티브 자바 4장#Item 17. 변경 가능성을 최소화하라|Item 17]])
**3. 빌더 패턴을 메서드 호출에 응용**
- 매개변수가 많을 때, 그 중 일부는 생략해도 괜찮을 때 특히 도움이 된다.
- 모든 매개변수를 하나로 추상화한 객체를 정의하고, 클라이언트에서 이 객체의 setter 메서드를 호출해 필요한 값을 설정하게 하는 것이다.
- 이때 각 setter 메서드는 매개변수 하나 혹은 서로 연관된 몇 개만 설정하게 한다.
- 클라이언트는 먼저 필요한 매개변수를 다 설정한 다음, execute 메서드를 호출해 앞서 설정한 매개변수들의 유효성을 검사한다.
- 마지막으로, 설정이 완료된 객체를 넘겨 원하는 계산을 수행한다.
##### 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다 (Item 64)
- 매개변수로 적합한 인터페이스가 있다면 그 인터페이스를 직접 사용하자.
- 예를 들어, 메서드에 `HashMap`을 넘길 일은 전혀 없다. 대신 `Map`을 사용하자.
- 그러면 `HashMap`뿐 아니라 `TreeMap`, `ConcurrentHashMap`, `TreeMap`의 부분맵 등 어떤 `Map` 구현체도 인수로 건넬 수 있다.
- 심지어 아직 존재하지 않는 `Map` 구현체라도 언젠가는 건넬 수 있다.
- **인터페이스 대신 클래스를 사용하면 클라이언트에게 특정 구현체만 사용하도록 제한하는 꼴이며, 혹시라도 입력 데이터가 다른 형태로 존재한다면 명시한 특정 구현체의 객체로 옮겨 담느라 비싼 복사 비용을 치러야 한다.**
##### boolean보다는 원소 2개짜리 열거 타입이 낫다 (단, 의미가 명확할 때)
- 열거 타입을 사용하면 코드를 읽고 쓰기가 더 쉬워진다.
- 나중에 선택지를 추가하기도 쉽다.
- 예를 들어, 다음 메서드는 화씨온도와 섭씨온도를 원소로 하는 열거 타입을 입력받는다.
```java
public enum TemperatureScale { FAHRENHEIT, CELSIUS }

// 나쁜 예
Thermometer.newInstance(true);

// 좋은 예  
Thermometer.newInstance(TemperatureScale.CELSIUS);
```
`Thermometer.newInstance(TemperatureScale.CELSIUS)`가 `Thermometer.newInstance(true)`보다 하는 일을 훨씬 명확하게 알려준다. 그리고 나중에 켈빈온도(Kelvin)도 지원해야 한다면, `TemperatureScale` 열거 타입에 `KELVIN`을 추가하면 된다. 또한 온도 단위에 대한 메서드들을 온도별 열거 타입 상수 안에 정의할 수도 있다. ([[이펙티브 자바 6장#아이템 34 int 상수 대신 열거 타입을 사용하라|Item 34]])

---
### Item 52. 다중정의는 신중히 사용하라

- 다음은 컬렉션을 집합, 리스트, 그 외로 구분하여 출력하는 프로그램이다.
```java
public class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "집합";
    }
    
    public static String classify(List<?> lst) {
        return "리스트";
    }
    
    public static String classify(Collection<?> c) {
        return "그 외";
    }
    
    public static void main(String[] args) {
        Collection<?>[] collections = {
            new HashSet<String>(),
            new ArrayList<BigInteger>(),
            new HashMap<String, String>().values()
        };
        
        for (Collection<?> c : collections)
            System.out.println(classify(c));
    }
}
```
- 이 프로그램은 "집합", "리스트", "그 외"를 차례로 출력할 것 같지만, 실제로는 **"그 외"만 세 번 연달아 출력**한다.
- [>] 왜냐하면.. **다중정의된 메서드 중 어느 것을 호출할 지가 컴파일타임에 정해지기 때문**이다.
- 컴파일타임에는 for 문 안의 c는 항상 `Collection<?>` 타입이다.
- 런타임에는 타입이 매번 달라지지만, 호출할 메서드를 선택하는 데는 영향을 주지 못한다.
##### 재정의(overriding)와의 차이
- **재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다.**
- 메서드를 재정의했다면 해당 객체의 런타임 타입이 어느 메서드를 호출할지의 기준이 된다.
```java
class Wine {
    String name() { return "포도주"; }
}

class SparklingWine extends Wine {
    @Override String name() { return "발포성 포도주"; }
}

class Champagne extends SparklingWine {
    @Override String name() { return "샴페인"; }
}

// 이 경우 "포도주", "발포성 포도주", "샴페인"을 차례로 출력한다.
for (Wine wine : wineList)
    System.out.println(wine.name());
```
##### 다중정의 사용 시 주의사항
- **안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.**
- 가변인수(varargs)를 사용하는 메서드라면 다중정의를 아예 하지 말아야 한다. ([[#Item 53. 가변인수는 신중히 사용하라|Item 53]])
- 다중정의하는 대신 메서드 이름을 다르게 지어주는 방법도 있다.
    - 예: `ObjectOutputStream`의 `writeBoolean(boolean)`, `writeInt(int)`, `writeLong(long)`
##### 생성자 다중정의
- 생성자는 이름을 다르게 지을 수 없으니 두 번째 생성자부터는 무조건 다중정의가 된다.
- 하지만 정적 팩터리라는 대안을 활용할 수 있는 경우가 많다. ([[이펙티브 자바 1장 + 2장#2장 들어가기|Item 1]])
##### 매개변수가 "근본적으로 다르면" 안전하다
- 두 타입의 (null이 아닌) 값을 서로 어느 쪽으로든 형변환할 수 없다면 헷갈릴 일이 없다.
- 예: `ArrayList`의 `int`를 받는 생성자와 `Collection`을 받는 생성자
##### 오토박싱과 제네릭이 다중정의에 미치는 영향
```java
// List<Integer>의 remove 메서드
list.remove(i);     // remove(int index) - 위치 제거
list.remove((Integer) i);  // remove(Object) - 값 제거
```
- 자바 4까지는 기본 타입과 참조 타입이 근본적으로 달랐지만, 오토박싱이 도입되면서 더는 그렇지 않게 되었다.

> [!important] 핵심 정리
> 프로그래밍 언어가 다중정의를 허용한다고 해서 다중정의를 꼭 활용하라는 뜻은 아니다. 일반적으로 매개변수 수가 같을 때는 다중정의를 피하는 게 좋다. 특히 생성자라면 이 조언을 따르기가 불가능할 수 있다. 그럴 때는 헷갈릴 만한 매개변수는 형변환하여 정확한 다중정의 메서드가 선택되도록 해야 한다.

---
### Item 53. 가변인수는 신중히 사용하라

가변인수(varargs) 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있다.
##### 가변인수 메서드의 동작 방식
- 가변인수 메서드를 호출하면, 가장 먼저 인수의 개수와 길이가 같은 배열을 만든다.
- 인수들을 이 배열에 저장하여 가변인수 메서드에 건네준다.
```java
// 간단한 가변인수 활용 예
static int sum(int... args) {
    int sum = 0;
    for (int arg : args)
        sum += arg;
    return sum;
}
```
##### 인수가 1개 이상이어야 하는 경우
```java
// 잘못된 예 - 인수가 0개일 수도 있다!
static int min(int... args) {
    if (args.length == 0)
        throw new IllegalArgumentException("인수가 1개 이상 필요합니다.");
    int min = args[0];
    for (int i = 1; i < args.length; i++)
        if (args[i] < min)
            min = args[i];
    return min;
}
```
**문제점:**
- 인수를 0개만 넣어 호출하면 컴파일타임이 아닌 **런타임에 실패**한다.
- `args` 유효성 검사를 명시적으로 해야 한다.
- 코드가 지저분하다.
```java
// 올바른 예 - 첫 번째로 평범한 매개변수를 받고, 가변인수는 두 번째로 받는다.
static int min(int firstArg, int... remainingArgs) {
    int min = firstArg;
    for (int arg : remainingArgs)
        if (arg < min)
            min = arg;
    return min;
}
```
##### 성능 문제
- 가변인수 메서드는 호출될 때마다 배열을 새로 하나씩 할당하고 초기화한다.
- 성능이 민감한 상황이라면 가변인수가 걸림돌이 될 수 있다.
###### 성능 최적화 패턴
- 메서드 호출의 95%가 인수를 3개 이하로 사용한다면...
```java
public void foo() { }
public void foo(int a1) { }
public void foo(int a1, int a2) { }
public void foo(int a1, int a2, int a3) { }
public void foo(int a1, int a2, int a3, int... rest) { }
```
- 마지막 다중정의 메서드가 인수 4개 이상인 5%의 호출을 담당한다.
- 따라서 메서드 호출 중 단 5%만이 배열을 생성한다.
- `EnumSet`의 정적 팩터리도 이 기법을 사용한다.

> [!important] 핵심 정리 
> 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다. 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려하자.

---
### Item 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라

##### null을 반환하면 안 되는 이유
- **클라이언트에서 방어 코드를 작성해야 한다.**
```java
List<Cheese> cheeses = shop.getCheeses();
if (cheeses != null && cheeses.contains(Cheese.STILTON))
    System.out.println("좋았어, 바로 그거야.");
```
- 컬렉션이나 배열 같은 컨테이너가 비었을 때 null을 반환하는 메서드를 사용할 때면 항시 이와 같은 방어 코드를 넣어줘야 한다.
- 방어 코드를 빼먹으면 오류가 발생할 수 있다.
- 실제로 객체가 0개일 가능성이 거의 없는 상황에서는 수년 뒤에야 오류가 발견되기도 한다.
##### 성능 걱정은 대부분 기우다
**"빈 컨테이너를 할당하는 데도 비용이 든다"** 는 주장이 있지만,
1. 성능 분석 결과 **이 정도의 성능 차이는 신경 쓸 수준이 못 된다.**
2. 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.
##### 올바른 해법
```java
// 올바른 예 - 빈 컬렉션을 반환한다.
public List<Cheese> getCheeses() {
    return new ArrayList<>(cheesesInStock);
}
```
##### 최적화 - 불변 객체 공유
```java
// 최적화 - 빈 컬렉션을 매번 새로 할당하지 않도록 했다.
public List<Cheese> getCheeses() {
    return cheesesInStock.isEmpty() ? Collections.emptyList()
        : new ArrayList<>(cheesesInStock);
}
```
- `Collections.emptyList()`, `Collections.emptySet()`, `Collections.emptyMap()` 를 활용하면 매번 새로운 객체를 만들지 않는다.
- 불변 객체는 자유롭게 공유해도 안전하다. ([[이펙티브 자바 4장#Item 17. 변경 가능성을 최소화하라|Item 17]])
##### 배열의 경우
```java
// 올바른 예 - 길이가 0일 수도 있는 배열을 반환한다.
public Cheese[] getCheeses() {
    return cheesesInStock.toArray(new Cheese[0]);
}

// 최적화 - 빈 배열을 미리 선언해두고 매번 그 배열을 반환한다.
private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];

public Cheese[] getCheeses() {
    return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);
}
```

> [!error] Tip
> 성능 개선을 목적으로 길이 0 배열 대신 toArray에 넘기는 배열을 미리 할당하는 것은 추천하지 않는다. 오히려 성능이 떨어진다는 연구 결과도 있다.

```java
// 나쁜 예 - 배열을 미리 할당하면 성능이 나빠진다.
return cheesesInStock.toArray(new Cheese[cheesesInStock.size()]);
```

> [!important] 핵심 정리 
> null이 아닌, 빈 배열이나 컬렉션을 반환하라. null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다. 그렇다고 성능이 좋은 것도 아니다.

---
