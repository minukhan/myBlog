
깊이 있는 내용을 다루다 보니 결코 쉽지 않다는 게 이 책이 가진 유일한 단점이라고 함.
최대한 직관적이고 일관되면서도 서로 잘 구분되는 용어를 선택


한국어판 깃허브 저장소: https://git.io/fAm6s

> [!note] 공부하는 법 
프로그래밍 언어를 공부할 때 언어의 핵심(절차적'이냐 함 수형이냐 객체 지향이냐)을 이해하고, 어휘(자료구조, 연산자, 표준 라이브러 리의 기능)를 알고, 코드를 구성하는 관례적이고 효과적인 방법에 숙달해야 한다.

---
### **초판 서문 (2001년)**

- 자바 플랫폼 아키텍트로 일하며 얻은 **경험을 공유**하려 책을 썼다.
- **이펙티브 C++ 처럼 실전 조언을 아이템 형식으로 정리.
- **API 설계의 중요성**을 강조하고, 리팩터링과 경량 개발 방법론과도 잘 맞는다고 언급.

---
###  **2판 서문 (2008년)**
- 자바 5~6 버전의 **제네릭, 열거형, 애너테이션, 동시성 라이브러리** 같은 큰 변화들을 반영.
- IDE와 정적 분석 도구의 발전도 언급.
- 아이템 수도 57개 → 78개로 늘고, 낡은 내용은 정리.
- **2판은 실용적인 예시와 최신 자바 기능에 더 집중.**

---
### **3판 서문(2017년)**

- 자바가 처음엔 단순한 “노동자용 언어”로 설계됐지만, 지금은 **복잡하고 거대해졌다.**
- 이번 3판에서는 그런 배경에서 **최신 자바에 맞는 조언과 사례**를 정리했다.

--- 

감사의 글 ~~ 하면서 책 서론 마무리

## 1 장 들어가기

이 책은 여러분이 자바 언어와 그 기반 라이브러리, 즉 java.lang, java.util, java.io, java.util.concurrent, java.util.function 같은 하위 패키지를 효과 적으로 사용하게끔 구성했다고 함.

이 책은 총 90개의 아이템을 담았다. 각각의 아이템이 하나의 규칙을 다루 며, 각 규칙은 업계 최고의 베테랑 프로그래머들이 유익하다고 인정했다고 함.

아이템들은 서로 독립적이라 책을 처음부터 순서대로 읽을 필요는 없다. 또한, 아이템들이 서로를 참조하는 경우가 많으니 여러분 각자 마음이 이끄는 대로 읽어도 좋다.

책에 예제코드를 곁들여놓았고 피해야할 관행들을 표시해서 나타내줌 (안티코드들) 

이 책의 규칙 대부분은 아주 핵심적인 기본 원칙 몇 개에서 파생된다. 바로 명료성(clarity)과 단순성(simplicity)이다.

자바가 지원하는 타입(type; 자료형)은 인터페이스(interface), 클래스(class), 배열(array), 기본 타입(primitive)까지 총 네 가지다.


---
## 2장 들어가기 

이번 장은 객체의 생성과 파괴를 다룬다. 객체를 만들어야 할 때와 만들지 말 아야 할 때를 구분하는 법, 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법, 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령을 알아본다.

>[!important] 참고
>지금 얘기하는 정적 팩터리 메서드는 디자인 패턴[Gamma95]에서의 팩터리 메서드 (Factory Method)와 다르다. 디자인 패턴 중에는 이와 일치하는 패턴은 없다.


클래스는 클라이언트에 public 생성자 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있다.

>[!note] 아이템 1 
>생성자 대신 정적 팩터리 메서드를 고려하라

그래서 많이 사용해본 record 를 이용해서 불변객체를 만든다음

거기 안에다가 메서드들을 추가하면 정적 펙토리 메서드 패턴이 되는것
**정적 팩터리 메서드 패턴**처럼 활용할 수 있다. 다시 말해서, `record`를 기반으로 객체를 **불변으로** 만들고, 그 안에서 객체 생성에 대한 로직을 **유연하게 제어**하려면 정적 메서드를 추가하면 된다는 것.

```
public record Point(int x, int y) {

    // 정적 팩터리 메서드처럼 사용할 수 있는 정적 메서드
    public static Point of(int x, int y) {
        // 객체 생성 로직을 추가할 수 있다.
        // 예를 들어, x, y 값이 특정 조건을 만족하는지 확인하고
        // 다른 값을 반환할 수도 있다.
        if (x < 0 || y < 0) {
            throw new IllegalArgumentException("x와 y는 음수가 될 수 없습니다.");
        }
        return new Point(x, y);
    }

    // 다른 정적 메서드도 정의 가능
    public static Point origin() {
        return new Point(0, 0);
    }
}

```

### 1. **이름을 가질 수 있다**

- 생성자와 달리 이름을 통해 **객체의 용도나 특징**을 명확히 드러낼 수 있다.
- 예: `LocalDate.of(year, month, day)` vs. `new LocalDate(...)`
    
---

### 2. **호출할 때마다 새로운 객체를 만들 필요가 없다**

- **객체 재사용**이 가능 → 성능 향상 및 **불필요한 객체 생략** 가능.
- 예: `Boolean.valueOf(true)`는 `Boolean.TRUE`를 반환 (객체 생성 X)
- **싱글턴**, **캐싱**, **플라이웨이트 패턴** 활용 가능.
- 인스턴스 생명주기 통제 → **인스턴스 통제 클래스**로 만들 수 있다.
    - 예: 싱글턴, 인스턴스 제한, 동치 인스턴스 하나만 존재 등.
---
### 3. **반환 타입의 하위 타입 객체를 반환할 수 있다**

이 기능은 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 '엄청난 유연성'을 선물한다.
API를 만들 때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객 체를 반환할 수 있어 API를 작게 유지할 수 있다.

- API 사용자에게는 **구현을 감추고 유연성 제공**.
- 핵심 기술: **인터페이스 기반 프레임워크 설계** 가능.

- **장점**:
    1. **API가 작아진다** → 공개할 요소가 줄어들기 때문.
    2. **개념적 복잡도도 줄어든다** → 개발자가 익혀야 할 개념 수와 난이도가 낮아짐.
    3. 개발자는 **구현 클래스에 신경 쓰지 않고**, 그 객체가 따르는 **인터페이스만 알면 된다**.
    4. 결과적으로, 클라이언트 코드는 **인터페이스 기반으로 설계**되어 더 유연하고 견고해진다.


- **자바 8 전에는**
    - 인터페이스에 **정적(static) 메서드**를 선언할 수 없었어요.
    - 그래서 정적 메서드나 유틸리티를 만들려면 **동반 클래스**를 따로 만들어야 했어요.  
        예: `Collections`, `Math` 같은 클래스들.
        
- **자바 8부터는**
    - 인터페이스에도 **정적 메서드 정의가 가능해짐!**
    - 그래서 많은 `public static` 메서드를 **인터페이스 안에 직접 넣을 수 있게 됨.**
    - 결과적으로, 꼭 별도의 동반 클래스가 필요하지 않은 경우가 많아짐.
        
- **하지만 여전히 제한 있음**
    - 인터페이스에 넣을 수 있는 건 **public static 멤버**만!
    - 그래서 **package-private** 수준의 헬퍼 메서드나 클래스는 인터페이스에 둘 수 없음.
    - 그런 코드는 여전히 **별도의 package-private 클래스에 따로 구현**해야 함.

- **자바 9에서는 좀 더 유연해짐**
    - **private static 메서드**도 인터페이스에 넣을 수 있게 되었어요!
    - 그래도 여전히 **정적 필드(static field)**나 **정적 멤버 클래스(static nested class)**는 무조건 `public`이어야 함.

#### java.util.Collection 
- **컬렉션 프레임워크**는 내부적으로 45개의 클래스가 있지만, 이들을 **공개하지 않고**, 대신 **인터페이스와 정적 팩터리 메서드만**을 통해 접근하게 함.
    
---

### 4. **입력 매개변수에 따라 서로 다른 클래스의 객체를 반환할 수 있다**

- **정적 팩터리 메서드는 항상 같은 클래스의 객체를 반환하지 않아도 된다.**
- **입력 매개변수**에 따라 **다른 구현 클래스**를 선택해서 반환할 수 있다.
- 단, 반환하는 객체는 **반환 타입의 하위 타입**이면 OK!
- 반환 타입이 같기만 하면, 내부적으로 어떤 구현을 선택해도 무방.
- 예: `EnumSet.of()`는 매개변수 수에 따라 서로 다른 구현 클래스 반환.
---

### 5. **반환할 객체의 클래스가 나중에 만들어져도 된다**

- **정적 팩터리 메서드**를 활용하면, 객체를 반환할 때 그 클래스가 **처음부터 존재하지 않아도** 된다.
- **서비스 제공자 프레임워크**는 다양한 구현체를 제공하고, 클라이언트는 구체적인 구현체와 관계 없이 **인터페이스만 사용**해서 서비스를 이용할 수 있도록 해줍니다.
    
- **서비스 제공자 프레임워크**의 구성 요소는 다음과 같습니다:
    
    1. **서비스 인터페이스 (Service Interface)**: 서비스의 동작을 정의한 인터페이스.
    2. **제공자 등록 API (Provider Registration API)**: 서비스 구현체가 이 API를 통해 등록.
    3. **서비스 접근 API (Service Access API)**: 클라이언트가 서비스를 요청할 때 사용하는 API.
    4. (선택적) **서비스 제공자 인터페이스 (Service Provider Interface)**: 서비스 구현체를 생성할 팩터리 객체를 정의.

**JDBC** (Java Database Connectivity)는 서비스 제공자 프레임워크의 대표적인 예시입니다.

**클라이언트는 서비스 제공자 구현체를 몰라도 된다.**
- 클라이언트는 서비스 인터페이스만 알고, 정적 팩터리 메서드를 통해 원하는 구현체를 얻을 수 있습니다.

# 단점

### **상속 제한**

- **문제**: 정적 팩터리 메서드만 제공하는 클래스는 **상속**이 불가능하다. 
- 왜냐하면 **public**이나 **protected** 생성자가 없으면, 상속을 통해 하위 클래스를 만들 수 없기 때문.
- **예시**: 컬렉션 프레임워크에서 `HashMap`과 같은 클래스는 정적 팩터리 메서드만 제공하기 때문에, 이를 상속할 수 없음
- **장점**:
    - 이 제약은 사실 **컴포지션(아이템 18)**을 사용하도록 유도할 수 있고, 클래스가 **불변 타입(아이템 17)**이라면 더 안정적이고 효율적인 설계를 할 수 있습니다.
### **정적 팩터리 메서드 찾기 어려움**

- **문제**: **정적 팩터리 메서드**는 생성자처럼 API 설명서에 명확하게 드러나지 않아서, **사용자가 어떻게 클래스를 인스턴스화할지 알아내기 어렵습니다**.
    
- **해결책**:
    - 이 문제를 완화하려면 **API 문서를 잘 작성**하고, **메서드 이름**을 잘 지어야 합니다. 보통 정적 팩터리 메서드에는 잘 알려진 규약을 따르는 이름을 붙이는 것이 좋습니다.

## 명명규칙

- **from**: 하나의 매개변수를 받아 변환.
- **of**: 여러 매개변수를 받아 인스턴스 생성.
- **valueOf**: `from`과 `of`의 자세한 버전.
- **instance/getInstance**: 인스턴스를 반환하지만 동일 인스턴스를 보장하지 않음.
- **create/newInstance**: 새로운 인스턴스를 생성하여 반환.
- **getType/newType**: 다른 클래스에서 팩터리 메서드를 정의할 때 사용.
- **type**: `getType`과 `newType`의 간결한 버전.

### 1. **from**

- **용도**: 매개변수를 하나 받아 해당 타입의 인스턴스를 반환하는 형변환 메서드.
- **예시**:
    `Date d = Date.from(instant);`
### 2. **of**

- **용도**: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드.
- **예시**:
    `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);`
### 3. **valueOf**

- **용도**: `from`과 `of`의 더 자세한 버전.
- **예시**:
    `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);`
### 4. **instance** 혹은 **getInstance**

- **용도**: 매개변수를 받는다면 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
- **예시**:
    `Stackwalker luke = StackWalker.getInstance(options);`
### 5. **create** 혹은 **newInstance**

- **용도**: `instance`나 `getInstance`와 유사하지만, 매번 새로운 인스턴스를 생성해 반환할 것을 보장한다.
- **예시**:
    `Object newArray = Array.newInstance(classObject, arrayLen);`
### 6. **getType**

- **용도**: `getInstance`와 유사하나, 팩터리 메서드를 정의할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용된다.
- **예시**:
    `FileStore fs = Files.getFileStore(path);`
### 7. **newType**

- **용도**: `newInstance`와 유사하나, 팩터리 메서드를 정의할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용된다.
- **예시**:
    `BufferedReader br = Files.newBufferedReader(path);`
### 8. **type**

- **용도**: `getType`과 `newType`의 간결한 버전.
- **예시**:
    `List<Complaint> litany = Collections.list(legacyLitany);`


--- 

>[!note] 아이템 2
>생성자에 매개변수가 많다면 빌더를 고려하라

#### 정적 팩터리와 생성자에는 똑같은 제약이 하나 있다. 선택적 매개변수가 많을 때 적절히 대응하기 어렵다는 점


- 식품 포장의 영양정보를 표현하는 클래스를 예시를 들며 설명하고있음.
- 지방, 트랜스지방, 포화지방, 콜레스테롤, 나트륨 등 총 20개가 넘는 선택 항목으로 이뤄진다.
- 그런데 대부분 제품은 이 선택 항목 중 대다수의 값이 그냥 0이다.
- 점층적 생성자 패턴(telescoping constructor pattern)을 즐겨 사용했음 
- -> **생성자 오버로딩(overloading)**
- 하지만 이 방식은 한계가 있었음. 
- 매개변수 수가 늘어나면 생성자 오버로드도 끝없이 늘어나야 함
- 코드가 복잡해지고 가독성이 떨어짐
- 매개변수 순서를 잘못 입력해도 컴파일러가 잡지 못함 → 버그 유발 가능

점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다. 코드를 읽을 때 각 값의 의미가 무엇인지 헷갈릴 것이고, 매개변수가 몇 개인지도 주의해서 세어 보아야 할 것 이다.

그래서 나온 두번째 대안책이 자바빈즈 패턴!

### 자바빈즈 패턴이란?

- **기본 생성자 + setter 메서드들**을 조합해서 객체를 생성하는 방식임.
- 객체 생성 후 필요한 값들을 setter를 통해 하나씩 설정해주는 구조이다.

- **일관성(consistency)이 깨질 수 있다**
    - 객체가 완전히 생성되기 전에 **중간 상태**가 생김
    - → 잘못된 상태의 객체가 생성될 수 있음
        
- **불변(immutable)하게 만들 수 없다**
    - setter 때문에 값이 언제든지 바뀔 수 있음
    - → 안전하지도 않고, 스레드 세이프(thread-safe)하지도 않음
- **추가 로직이 필요**
    - 생성 완료 전에 객체 사용을 막기 위해 `freeze()` 같은 수동 제어가 필요한데, 이건 번거롭고 실수하기 쉬움


	#### 그래서 나온게 빌더패턴

- 점층적 생성자 패턴의 안전성과 자바 빈즈 패턴의 가독성을 겸비한 빌더 패턴(Builder pattern) 

코드를 보면 
`
```

public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // 필수 매개변수
        private final int servingSize;
        private final int servings;

        // 선택 매개변수 - 기본값으로 초기화한다.
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            calories = val;
            return this;
        }

        public Builder fat(int val) {
            fat = val;
            return this;
        }

        public Builder sodium(int val) {
            sodium = val;
            return this;
        }

        public Builder carbohydrate(int val) {
            carbohydrate = val;
            return this;
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}

```

- 내부 정적 클래스 `Builder`가 실제로 값을 설정하고,
- 마지막에 `.build()`를 호출하면 `NutritionFacts` 인스턴스를 리턴하는 구조 
- 가독성도 좋은데 코드가 길고 반복도 많아.
- 원래는 이렇게 구현을 해놓고 사용을 해야하는데 그래서 이제는 쉽게 사용하도록 해주는 라이브러리 lombok 을 이용하면 어노테이션 @Builder  하나만 붙이면 편하게 사용할 수 있는것.

- **빌더 패턴을 사용한 객체 생성**: 빌더 패턴을 사용할 때는 매개변수 유효성 검사를 통해 잘못된 값을 처리하고, `IllegalArgumentException`을 던지는 방식으로 유효성을 관리할 수 있다.

- 빌더 패턴은 계층적인 설계와 잘 어울린다. 여기서는 피자 클래스 계층을 예시로 사용하고 있음. 피자 클래스는 여러 종류의 피자(예: 뉴욕 피자, 칼초네 피자)를 표현하는 추상 클래스로, 각 피자의 특성에 맞게 빌더 패턴을 사용한다는 것임.
    
- **계층적인 클래스 설계에 빌더 패턴 적용**: 여러 하위 클래스들이 공통된 추상 클래스에서 빌더 패턴을 활용하는 구조. 하위 클래스는 각자 필요한 필수 매개변수를 `Builder` 클래스에서 정의하고, `build()` 메서드를 통해 객체를 생성한다.
    
- **재귀적 타입 한정**: 제네릭을 활용하여 빌더 메서드 체이닝을 지원하고, 하위 클래스에서는 `self()` 메서드를 통해 자신을 반환하게 하여 메서드 체이닝을 자연스럽게 이어갈 수 있다.

### 빌더 패턴의 장점


1. **가변 인수(varargs) 처리**  

> [!note] 가변인수 
> 가변 인수(varargs)는 메서드에서 파라미터로 받는 인수의 개수가 정해져 있지 않고, 여러 개를 받을 수 있는 기능을 말함
 
 
빌더 패턴을 사용하면 가변 인수를 유연하게 처리할 수 있음. 생성자에서는 가변 인수를 처리하기 어렵지만, 빌더 패턴을 사용하면 여러 개의 인수를 적절한 메서드로 나누어 처리할 수 있음.

예를 들어, `addTopping` 메서드를 여러 번 호출해서 매개변수들을 하나의 필드로 모을 수 있음.
    
2. **유연성**  
    빌더 패턴은 매개변수를 여러 번 나누어 설정하거나 가변 인수 처리에 유리함. 하나의 빌더 객체로 여러 객체를 만들 수 있음.
    
3. **유일한 필드 관리**  
    빌더 패턴을 통해 객체를 생성할 때 일련번호나 고유 필드 같은 값들을 자동으로 채울 수 있음.
    

### 빌더 패턴의 단점

1. **빌더 객체 생성 비용**  
    빌더 객체를 먼저 만들어야 하므로 추가적인 작업이 필요함. 성능에 민감한 상황에서는 이 추가 비용이 문제가 될 수 있음.
    
2. **장황한 코드**  
    빌더 패턴은 점층적 생성자 패턴보다 코드가 장황해질 수 있음. 매개변수가 적을 때는 코드가 불필요하게 길어질 수 있음.
    
3. **매개변수의 증가**  
    API가 시간이 지나면서 매개변수가 많아지는 경향이 있음. 처음에는 생성자나 정적 팩터리 메서드를 사용하다가 나중에 매개변수가 많아지면 빌더 패턴으로 전환할 수 있지만, 그 경우 이전에 만든 생성자나 정적 팩터리 메서드가 도드라지게 보일 수 있음.
    

### 결론

- 매개변수가 많아지거나 객체 생성이 복잡해질 경우 빌더 패턴이 유리함.
- 빌더 패턴은 유연성은 높지만 성능과 코드 장황성 문제를 고려해야 함.
- 매개변수가 적다면 생성자나 정적 팩터리 메서드를 사용하는 것이 더 나을 수 있음.

>[!important] 마무리
>핵심 정리 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫 다. 매개변수 중 다수가 필수가 아니거나 같은 타입이면 특히 더 그렇다. 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다.

--- 

>[!note] 아이템 3
>private 생성자나 열거 타입으로 싱글턴임을 보증하라

### 싱글턴 패턴

**싱글턴(Singleton) 패턴**은 **인스턴스가 오직 하나만 생성될 수 있는 클래스**를 만드는 설계 패턴을 의미함. 싱글턴 패턴을 적용하면, 특정 클래스의 인스턴스가 프로그램 내에서 **단 하나만 존재**하도록 보장할 수 있음. 이 패턴은 전역적으로 접근 가능한 객체가 하나만 존재해야 할 때 유용함. 예를 들어, 설정 객체나 데이터베이스 연결 객체 등이 싱글턴 패턴을 통해 관리될 수 있음.

### 싱글턴 구현 방식

싱글턴을 만드는 방식은 **주로 세가지**로 나눌 수 있음:
1. **public static final 필드 방식**
2. **정적 팩터리 메서드 방식**
3. **열거 타입 방식**
    

각 방식의 예시와 특징을 설명함.

---

### 1. **public static final 필드 방식**

이 방식에서는 싱글턴 인스턴스를 **public static final** 필드로 선언함. 클래스가 처음 로딩될 때 인스턴스가 생성되고, 이 인스턴스를 **절대로 변경할 수 없도록** 보장함.

```
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    
    private Elvis() { 
        // private 생성자로 외부에서 인스턴스 생성 못하게 함
    }

    public void leaveTheBuilding() {
        // 메서드 구현
    }
}


```

- **장점**: 간결하고, 싱글턴 객체가 **명백하게 드러남**.
- **단점**: 리플렉션(Reflection)을 사용하면 **예외가 발생할 수 있음**.
---

### 2. **정적 팩터리 메서드 방식**

이 방식에서는 **정적 팩터리 메서드**(static factory method)를 사용하여 인스턴스를 생성하고 반환함. 이 방식도 **유일한 인스턴스**를 반환하지만, **팩터리 메서드를 사용**하여 객체를 제공함.

```
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();

    private Elvis() {
        // private 생성자로 외부에서 인스턴스 생성 못하게 함
    }

    public static Elvis getInstance() {
        return INSTANCE;
    }

    public void leaveTheBuilding() {
        // 메서드 구현
    }
}

```

- **장점**:
    - 유연성이 높고, **기존 클래스를 수정하지 않고** 싱글턴을 쉽게 변경할 수 있음.
    - **팩터리 메서드를 활용**하면, 다른 설정을 가진 인스턴스를 생성하거나, 다른 방식으로 싱글턴을 관리할 수 있음.
        
- **단점**:
    - `public static final` 방식보다는 **길어짐**.
---

### 3. **열거 타입 방식** (가장 바람직한 방법)

**열거 타입(Enum)**을 사용하여 싱글턴을 구현하면, 싱글턴을 생성하고 관리하는 것이 간결하고, **리플렉션 공격이나 직렬화 문제를 완벽히 방어**할 수 있음. 이 방법은 자바에서 **싱글턴을 구현할 때 가장 안전하고 확실한 방식**으로 권장됨.

```
public enum Elvis {
    INSTANCE;

    public void leaveTheBuilding() {
        // 메서드 구현
    }
}
```

- **장점**:
    - **리플렉션 공격**이나 **직렬화 문제**에 대한 안전성 보장.
    - 간결하고, **추가 작업 없이 직렬화 가능**.
    - **열거 타입**의 특징 덕분에 객체가 하나만 생성되며, 인스턴스가 **직렬화**될 때 문제가 생기지 않음.
- **단점**:
    - 싱글턴 클래스가 **Enum을 상속해야** 하므로, 다른 클래스를 상속하려면 사용할 수 없음.
---
### 결론

- **public static final 필드 방식**: 간결하고, 직관적이지만 리플렉션을 통한 인스턴스 생성 공격에 취약함.
- **정적 팩터리 방식**: 더 유연하지만 코드가 길어지고, 기본 방식보다 복잡함.
- **열거 타입 방식**: 가장 안전하고 직렬화 및 리플렉션 공격에 강한 방식임. 싱글턴을 구현할 때 가장 권장되는 방법.
---

>[!note] 아이템 4
 인스턴스화를 막으려거든 private 생성자를 사용하라

**객체를 못 만들게 하고 싶으면 생성자를 `private`으로 만들어라** 이 뜻임.

- **`private` 생성자** 만들어서 인스턴스화 막기
- 안에서 `throw new AssertionError();` 하면 **실수로 내부에서 호출하는 것도 방지** 가능

```
public class UtilityClass {
    private UtilityClass() {
        throw new AssertionError();  // 생성 막기
    }
    // 전부 static 메서드만 넣기
}

```

**정적 메서드만 있는 클래스 만들 땐 `private` 생성자 꼭 넣자.**  
그래야 인스턴스 못 만들고, 상속도 못 함.


---

>[!note] 아이템 5
>자원을 직접 명시하지 말고 의존 객체 주입을 사용하라


**의존 객체 주입" 클래스 안에서 필요한 자원을 **직접 만들지 말고**, 밖에서 넣어줘라 이말임.

```
public SpellChecker(Lexicon dictionary) {
    this.dictionary = Objects.requireNonNull(dictionary);
}
```
- 이러면 어떤 언어든, 어떤 종류의 사전이든 넣을 수 있음
- 테스트할 땐 **가짜 사전(mock)** 도 주입 가능
- **유연성 증가**  
    → 다양한 사전 사용 가능
- **테스트 쉬움**  
    → 테스트용 가짜 자원 넣기 가능
- **재사용성 증가**  
    → 자원만 바꿔 끼우면 다른 환경에서도 재사용 가능
- **불변성 유지**  
    → final로 유지하니까 안정성도 좋음

**Spring**을 사용하면, **의존성이 많아져도 지저분하지 않게 관리**할 수 있음 의존성 많아도 **Spring이 알아서 정리해줘.**


>[!note] 아이템 6
>불필요한 객체 생성을 피하라

##### 상수 풀 (Constant Pool) 이란?

자바에서 `"hello"` 같은 **문자열 리터럴**은  **JVM이 미리 저장해두는 특별한 공간**에 들어감 
- 그걸 **"상수 풀"** 또는 **"문자열 풀(String Pool)"** 이라고 해

리터럴 : “직접 써놓은 고정된 값”

#####  `String a = new String("bikini");`

- **새로운 String 객체를 강제로 생성함**
- "bikini"라는 값은 이미 **상수 풀에 있음** (리터럴)
- 그런데도 **굳이 또 새 객체 만듦**
- → 메모리 낭비, 성능 저하
##### `String b = "bikini";`

- **리터럴 문자열** 사용
- JVM이 **상수 풀(intern pool)** 에서 같은 문자열 재사용함
- 같은 "bikini" 리터럴을 쓰면 항상 **같은 객체**를 가리킴
- → 빠르고 효율적임


**정적 팩터리 메서드**:

- **Boolean.valueOf(String)**와 같은 정적 팩터리 메서드는 객체 생성을 **최소화**하고 **불필요한 객체 생성을 방지**하는 데 사용됨.
    
- 생성자는 매번 새로운 객체를 만들지만, 팩터리 메서드는 이미 생성된 객체를 **재사용**할 수 있기 때문에 **성능과 메모리 효율성**이 높아짐.


- **불변 객체**는 **재사용**을 통해 성능을 개선할 수 있음.
- 객체 생성이 비용이 많이 드는 경우, **정적 팩터리 메서드**나 **캐싱** 기법을 사용해 불필요한 객체 생성을 피하고 성능을 개선해야함.

##### 왜 이렇게 중요한가?
- 반복적으로 **비용이 큰 객체**를 생성하면 **메모리**와 **CPU 시간**을 낭비하게 되며, 특히 성능이 중요한 상황에서는 이로 인해 큰 차이가 나기 때문에, **최적화**가 필요함.

### **지연 초기화 (Lazy Initialization)**

- **지연 초기화**는 객체가 실제로 필요할 때까지 객체를 생성하지 않는 방법임.
- 예를 들어, `Pattern` 객체처럼 **비용이 많이 드는 객체**는 필요할 때까지 생성하지 않고, **필요한 순간**에만 생성하는 방식으로 성능을 개선함.
- 하지만 이 방식은 코드가 복잡해지므로 **성능 개선이 큰 차이를 만들지 않는 경우**에는 사용을 자제하는 것이 좋음.
- **효율성**과 **코드의 명확성**을 고려해야 하므로, 지연 초기화는 성능이 중요한 경우에만 사용하는 것이 좋음.

### **필요한 객체 생성 방지**

- 객체를 **불필요하게** 생성하면 성능에 **심각한 영향을 미칠 수 있음**. 예를 들어, **오토박싱**(자동으로 기본 타입을 래핑된 객체로 변환)에서 발생하는 불필요한 객체 생성은 성능을 저하시킬 수 있음.
    
- 예시 코드에서 `Long` 객체를 사용했을 때, `long` 기본 타입을 사용하면 성능이 **6.3초에서 0.59초**로 개선된다는 사실을 강조하고 있음.

**어댑터 패턴 (Adapter Pattern)**  
    어댑터 패턴은 기존 객체의 인터페이스를 바꾸지 않고, 새로운 인터페이스로 재사용할 수 있게 도와주는 디자인 패턴임.
    
 **객체 풀 (Object Pool)**  
    객체 풀을 사용하면 자원 소모가 큰 객체들을 재사용할 수 있음. 예를 들어, 데이터베이스 연결 같은 자원은 매번 생성하는 것보다는 풀에서 가져오는 방식이 훨씬 효율적임.
    


#### 정리 

불필요한 객체 생성을 피하는 게 중요하지만, 그것만으로 성능을 크게 향상시키는 경우는 많지 않음.

객체가 비싼 객체일 경우에만 재사용을 고려하고, 작은 객체들은 적당히 생성하는 것이 더 나을 수 있음.

하지만, 작은 객체들에 대해서는 자체 객체 풀을 만드는 게 별로 좋지 않음. JVM의 가비지 컬렉터가 객체 회수하는데 이미 최적화가 잘 되어 있기 때문에, 간단한 객체들에 대해서는 객체 풀을 관리하는 게 성능 저하를 일으킬 수 있음.




>[!note] 아이템 7
>다 쓴 객체 참조를 해제하라

C, C++처럼 메모리를 직접 관리해야 하는 언어를 쓰다가 자바처럼 가비지 컬 렉터를 갖춘 언어로 넘어오면 프로그래머의 삶이 훨씬 평안해진다함. 알아서 다 쓴 객체들을 회수해 가니까.

그래서 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데, 절대 사실이 아니다 하면서 소개

### **메모리 누수와 해결 방법**

- **메모리 누수**는 가비지 컬렉터가 회수하지 못하는 객체들이 계속해서 메모리를 차지하는 문제임.

- **문제**: `Stack` 클래스처럼 객체가 꺼내지더라도 그 객체를 참조하는 배열이 참조를 계속 유지하고 있다면, 해당 객체는 메모리에서 회수되지 않음. 결국, 프로그램이 실행될수록 메모리 사용량이 증가하고 성능이 저하될 수 있음.

- **배열이 스택의 데이터를 저장하는 핵심 구조**야. 객체들을 효율적으로 저장하려면 배열이 필요하고, 배열의 크기를 동적으로 늘려줘야 하기 때문이지.
    

### **메모리 누수가 발생하는 이유**

- **다 쓴 참조**: 스택에서 꺼낸 객체를 참조하는 배열의 원소들이 여전히 참조를 유지하고 있어서, 가비지 컬렉터가 해당 객체들을 회수할 수 없음. 이로 인해 객체들이 메모리에서 해제되지 않음.
    
- **가비지 컬렉터의 한계**: 가비지 컬렉터는 참조가 없어진 객체들을 자동으로 회수하지만, 비활성화된 영역에 있는 객체 참조는 여전히 유효한 참조로 인식됨.
    

### **해결 방법**

1. **다 쓴 참조를 null 처리**:
    - 객체를 다 사용한 후, 참조를 `null`로 설정하여 가비지 컬렉터가 객체를 회수할 수 있게 해야 함.
    - 예를 들어, `pop` 메서드에서 꺼낸 객체가 더 이상 필요 없을 때 해당 참조를 `null` 처리함.
        
2. **유효 범위 내에서 참조를 관리**:
    - 참조가 더 이상 필요 없을 때, 해당 참조를 사용하는 변수를 범위(scope) 밖으로 밀어내어 자연스럽게 객체가 회수되도록 함.
        
3. **자기 메모리 관리하는 클래스 주의**:
    - 예를 들어, `Stack`처럼 객체 배열을 관리하는 클래스에서는 메모리 누수가 발생할 수 있음. 원소를 다 사용한 즉시 그 원소가 참조한 객체들을 `null` 처리하여 메모리 누수를 방지해야 함.
        
4. **캐시 처리**:
    - **WeakHashMap**을 사용하여 캐시에서 객체가 더 이상 참조되지 않으면 자동으로 제거되게 할 수 있음.
    - **ScheduledThreadPoolExecutor**나 **LinkedHashMap**을 사용하여 주기적으로 사용하지 않는 캐시 엔트리를 청소할 수 있음.
        
5. **리스너와 콜백 관리**:
    - 리스너나 콜백이 해지되지 않으면 계속 쌓여서 메모리 누수가 발생할 수 있음. 이를 방지하려면 **약한 참조(weak reference)**를 사용하여 가비지 컬렉터가 해당 객체를 회수할 수 있도록 해야 함.
        

### **핵심 정리**

- 메모리 누수는 눈에 띄지 않아서 오랜 시간 동안 시스템에 영향을 미칠 수 있음. 이를 예방하기 위해서는 코드 리뷰나 힙 프로파일러와 같은 디버깅 도구를 활용해 문제를 미리 발견하는 것이 중요함.
    
- **다 쓴 참조를 `null` 처리하거나, 객체의 유효 범위를 최소화**하는 것이 메모리 누수를 방지하는 가장 중요한 방법임.



>[!note] 아이템 8 
>finalizer와 cleaner 사용을 피하라


자바에서 **finalizer**와 **cleaner**는 객체가 더 이상 사용되지 않게 된 후 자원을 해제하는 메커니즘이지만, **두 가지 모두 위험하고 예측 불가능한 문제를 일으킬 수 있다**는 점에서 사용을 피해야 한다.

### 1. **Finalizer**

- **Finalizer**는 객체가 더 이상 사용되지 않게 되면 가비지 컬렉터에 의해 호출된다.
    
- 그러나 **Finalizer**는 예측할 수 없고, 실행 시점이 불확실하다. 가비지 컬렉터가 언제 실행될지 모르기 때문에 **즉시 필요한 작업을 처리하는 데 사용할 수 없다**.
    
- 예외 발생 시, **finalizer**에서 처리되지 않은 예외가 있을 경우 객체는 제대로 종료되지 않으며, 이로 인해 **예측할 수 없는 동작**이 발생할 수 있다.
### 2. **Cleaner**

- **Cleaner**는 **finalizer보다는 나은 대안**이지만 여전히 예측 불가능하고, 실행 시점이 보장되지 않는다.
    
- **Cleaner**는 실행을 담당할 스레드를 제어할 수 있으므로 **finalizer보다는 나은 성능**을 제공하지만 여전히 백그라운드에서 실행되며 **즉시 수행된다는 보장이 없다**.
    
- **Finalizer**보다는 조금 더 나은 대안일 수 있지만 여전히 **예측할 수 없는 지연**을 야기할 수 있기 때문에, **즉시 처리해야 하는 작업에 의존하면 안 된다**.

- **자원 해제**와 같은 중요한 작업을 **finalizer나 cleaner에 의존하면 안 된다**. 예를 들어, **데이터베이스 연결 종료**와 같은 중요한 작업을 finalizer나 cleaner에 맡기면 시스템 전체에 큰 문제가 발생할 수 있다.

자원 해제와 같은 중요한 작업은 Finalizer, **Cleaner** 이게 문제가 있으니까 try-finally 를 사용하는게 좋다. 
    
- 전통적으로 **`try-finally`**를 사용하여 자원을 닫아왔지만, 코드가 복잡해지고 예외가 발생할 경우 처리하기 어려운 단점이 있음.
    
### 2. **`try-finally`의 문제점**

- 자원이 여러 개일 경우, **`try-finally`** 방식은 코드가 복잡해지고, 자원 해제 코드가 중첩되면서 지저분해짐.
    
- 또한, 예외가 두 군데(try 블록과 finally 블록)에서 발생할 수 있기 때문에 첫 번째 예외가 두 번째 예외에 의해 덮어씌워져 디버깅이 어려워질 수 있음.
    

### 3. **`try-with-resources` (자원 회수 최적화)**

- **Java 7**부터 도입된 **`try-with-resources`**는 자원을 자동으로 닫아줌.
- 자원을 관리하려면 자원이 **`AutoCloseable`** 인터페이스를 구현해야 함.
- `try-with-resources` 구조는 코드가 간결하고 예외 관리가 용이함.

### 4. **예외 처리 개선**

- `try-with-resources`에서는 자원에서 발생한 예외 외에도 **다른 예외들이 `suppressed`**(숨겨짐) 상태로 출력됩니다. 이렇게 함으로써, 두 번째 예외가 첫 번째 예외를 덮어쓰지 않도록 하여 디버깅에 유용한 정보를 제공.
    
    - **`getSuppressed()`** 메서드를 통해 숨겨진 예외도 프로그램에서 처리할 수 있음.
        

### 5. **`catch` 절과 함께 사용**

- `try-with-resources`에서는 `catch` 절을 함께 사용할 수 있어, 예외를 적절하게 처리할 수 있음. 예외를 던지지 않고 기본값을 반환하는 등의 처리가 가능함.
    
### **핵심 정리**

- 자원 관리 시 **`try-with-resources`**를 사용하면 **`try-finally`**보다 코드가 간결하고, 예외 처리가 용이함.
    
- 예외가 발생하더라도, 자원 해제가 확실히 이루어지고, 숨겨진 예외에 대한 정보도 확인할 수 있어 디버깅이 용이하다함.
    
- 자원을 닫을 때는 **`AutoCloseable`**을 구현한 객체를 사용하고, `try-with-resources`를 활용해 자원 회수를 처리하는 것이 최선의 방법.
    

따라서, 자원 회수와 관련된 코드 작성 시 **`try-finally`**보다는 **`try-with-resources`**를 사용하는 것이 더 안전하고 효율적인 방법이라고 소개함..