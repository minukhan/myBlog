## 클래스와 인터페이스

클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법을 알아본다.

---
### Item 15. 클래스와 멤버의 접근 권한을 최소화하라

#### 정보 은닉 (캡슐화)

잘 설계된 컴포넌트는 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐가 중요하다.
이는 **정보은닉**, 혹은 **캡슐화**라고 하는 개념으로 소프트웨어 설계의 근간이 되는 원리다.

정보 은닉의 장점은 다음과 같이 정리할 수 있다.
- 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
- 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문이다.
- 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음, 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다.
- 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다.
- 큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.

#### 접근 제한자

클래스, 인터페이스, 멤버의 접근성은 선언된 위치와 **접근 제한자**로 정해진다.
기본 원칙은 모든 클래스와 멤버의 접근성을 *가능한 좁혀야한다.*

사용할 수 있는 접근 제한자는 다음과 같다.
- **private**: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
- **package-private**: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다.(단, 인터페이스의 멤버는 기본적으로 public이 적용된다)
- **protected**: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
- **public**: 모든 곳에서 접근할 수 있다.

가장 바깥의 톱레벨 클래스와 인터페이스는 package-private, 혹은 public 접근 제한자가 붙는다.
public이 붙으면 공개 API가 되며, package-private는 해당 패키지 안에서만 이용할 수 있다.
클래스의 접근 권한을 결정하는 방법은 공개 API를 설계한 후, 나머지 모든 멤버는 private로 만든다.
그리고 같은 패키지에서 접근해야하는 멤버에 한하여 package-private로 풀어준다.

#### public static final

public 클래스의 인스턴스 필드는 thread-safe하지 않기 때문에 되도록 public이 아니어야 한다. 그러나 상수로써 public static final 필드로 사용하는 것은 상관없다. 단 기본타입 값이나 불변 객체를 참조해야 하고, 가변 객체를 사용한다면 참조된 객체 자체가 수정가능 하기 때문에 의도치 않은 결과를 유발한다.

public static final의 배열 필드를 생성한다고 생각해보자.
```java
public static final Thing[] VALUES = {...};
```

이 필드는 참조를 반환하여 **배열을 수정할 수 있는 보안 허점**이 있다.
따라서 private필드로 변경하고, public 타입의 불변 리스트 혹은 복사본을 반환하는 메서드를 제공하는 방식을 사용해야 한다.

```java
private static final Thing[] PRIVATE_VALUES = { ... }; 

//방법 1. 불변 리스트 제공 
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)); 

//방법 2. 복사본 제공 
public static final Thing[] values() {
return PRIVATE_VALUES.clone(); 
}
```


#### 모듈 시스템

자바 9에서 도입된 모듈 시스템은 속한 패키지 중에 선택적으로 공개할 수 있다. 
공개되지 않은 패키지의 protected, 혹은 public 멤버는 접근 권한과 상관없이 모듈 외부에서 접근이 불가능하다. 이를 활용한 가장 대표적은 예는 JDK로, JDK외에는 아직 모듈 개념이 받아 들여질지 예측하기 힘들다.

---
### Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

public 클래스에서 public 필드를 두면 데이터 필드에 직접 접근할 수 있기 때문에 캡슐화의 이점이 없다.
따라서 객체 지향을 지키기 위해 필드는 모두 private로 두고 public 접근자(getter)를 추가한다.

필드를 직접적으로 제공하지 않고 접근자를 제공한다면 **클래스 내부 표현을 변경할 수 있는 유연성**을 얻을 수 있다.
그리고 만약 package-private클래스나 private 중첩 클래스라면 데이터 필드를 노출해도 문제가 없다.
그 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 된다.

---
### Item 17. 변경 가능성을 최소화하라

#### 불변 클래스

불변클래스는 **인스턴스 내부 값을 수정할 수 없는 클래스**로,
가변 클래스보다 설계하고, 구현하고, 사용하기 쉬우며, 오류가 생길 여지도 적고 안전하다.

다음은 클래스를 불변으로 만드는 다섯가지 규칙이다.
- 객체의 상태를 변경하는 **메서드(변경자)를 제공하지 않는다.**
- 클래스를 **확장할 수 없도록** 한다. 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다. 상속을 막는 대표적인 방법은 클래스를 *final*로 선언하는 것이지만, 다른 방법도 존재한다. (뒤에서 살펴볼 것임)
- **모든 필드를 final로 선언**한다. 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법이다. 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장하는 데도 필요하다.
- **모든 필드를 private으로 선언**한다. 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다. 기술적으로는 기본 타입 필드나 불변 객체를 참조하는 필드를 public final로만 선언해도 불변 객체가 되지만, 이렇게 하면 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권하지는 않는다.
- 자신 외에는 **내부의 가변 컴포넌트에 접근할 수 없도록** 한다. 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다. 이런 필드는 절대 클라이언트가 제공한 객체 참조를 가리키게 해서는 안 되며, 접근자 메서드가 그 필드를 그대로 반환해서도 안 된다. 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행하라.

불변 클래스의 장점으로는 다음과 같다.
- 불변 객체는 변할 가능성이 없으니 thread-safe하며, 안심하며 공유할 수 있다.
	스레드 안전하여 여러 스레드 동시에 사용해도 절대 훼손되지 않는다.
- 블변 객체끼리는 내부 데이터를 공유할 수 있다.
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 불변식을 유지하기 쉽다.
	값이 바뀌지 않는 구성요소들로 이루어진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문이다.
- 불변 객체는 그 자체로 실패 원자성(failure atomicity)를 제공한다. 실패 원자성이란, 메서드에서 예외가 발생한 후에도 여전히 유효한 상태임을 증명하는 성질이다.

그러나 단점도 존재한다.
- 값이 다르면 반드시 독립된 객체로 만들어야하기 때문에 가짓수가 많을수록 성능이 떨어진다.

불변 클래스는 불변을 보장하기 위해 상속하지 못하게 하는 방법으로 final 클래스로 만들 수 있다. 그러나 더 유연한 방법으로 모든 생성자를 private, 혹은 package-private로 만들고 public 정적 팩토리를 제공하는 방법이 있다.

---
### Item 18. 상속보다는 컴포지션을 사용하라

* 여기서 말하는 상속은 클래스의 인터페이스 구현, 인터페이스의 인터페이스 확장과는 다른 **클래스 상속**을 말한다.

메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 
상위 클래스가 **어떻게 구현되느냐에 따라** 하위 클래스의 동작에 이상이 생길 수 있다.

상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야하는데, is-a 관계일 때도 안심할 수만은 없는 게 하위 클래스의 패키지가 상위 클래스와 다르고 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 터질 수 있다.

책에서는 문제가 되는 두가지 상황을 예시로 든다.
- 상위 클래스의 메서드를 이용시, 메서드의 내부 구현에서 예상치 못한 재정의 메서드를 호출하는 경우.
- 상위 클래스에 하위 클래스의 조건을 깨뜨리는 새로운 메서드가 추가되는 경우.  
    클래스가 특정 조건을 만족해야만 하는데 새로운 메서드가 이를 만족하지 않는다면, 다시 하위 클래스에서 이를 수정해야하는 번거로움이 있다.

#### 컴포지션 (Composition)

따라서 상속보다는 **컴포지션**을 활용해 문제점을 해결하고자 한다.
컴포지션은 기존 클래스를 확장하는 대신, **새로운 클래스에서 private필드로 기존 클래스 인스턴스를 참조하는 설계방식**을 말한다.
기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션 이라 하는 것이다.

새 클래스의 인스턴스 메서드들은 (private 필드로 참조하는) 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다. 이 방식을 전달(forwarding)이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다.
그 결과 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향받지 않는다.

컴포지션을 사용해 구현한 클래스를 다른 인스턴스를 감싸고 있다는 뜻에서 *래퍼 클래스*라고 부르며,
다른 기능을 덧씌운다는 듯으로 *데코레이터 패턴*이라고 한다.
* 컴포지션과 전달의 조합은 넓은 의미로 위임(delegation)이라고 하는데, 정확히는 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 해당된다.

콜백을 사용하는 경우에는 래퍼 클래스가 아닌 자신의 참조를 넘기고 내부 객체를 호출하는 SELF 문제가 발생한다. 이렇게 콜백을 구현하는 것이 아니라면, 대부분 **상속보다는 컴포지션을 구현하는 것이 더 유용하다.**

---
### Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- [?] 상속을 고려한 설계와 문서화란 정확히 무얼 뜻할까?
###### 1. 메서드를 재정의하면 어떤 일이 일어나는 지를 정확히 정의하여 문서로 남겨야 한다

> [!todo] 달리 말하면...
   상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야한다.
- API로 공개된 메서드에서, 클래스 자신의 또 다른 메서드를 호출 할 수 있다.
	- 마침 호출되는 메서드가 재정의 가능 메서드(public, protected 메서드 중 final이 아닌 모든 메서드)라면... 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다.
	- 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다.
- 더 넓게 말하면, **재정의 가능 메서드를 호출할 수 있는 모든 상황**을 문서로 남겨야 한다.
- API 문서의 메서드 설명 끝에서 종종 *"Implementation Requirements"* 로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.
	- `@implSpec` 태그를 붙여주면 자바독 도구가 생성해준다.
	- *122p* ==`java.util.AbstractCollection` 부분 참고==
- 하지만 이런 식은, "좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다"라는 격언과는 대치된다.
	- 상속이 캡슐화를 해치기 때문에 일어나는 안타까운 현실
###### 2. 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야할 수도 있다
- 드물게는 protected 필드로 공개해야할 수도 있다.
	- *124p* ==`java.util.AbstractList` 부분 참고==
- List 구현체의 최종 사용자는 `removeRange` 메서드에 관심이 없다. 그럼에도 이 메서드를 제공한 이유는 단지 하위 클래스에서 부분리스트의 `clear` 메서드를 **고성능으로 만들기 쉽게 하기 위해서**다.
- [?] 상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출하도록 결정할까?
	- 심사숙고해서 잘 예측해본 다음, **실제 하위 클래스를 만들어 시험해보는 것이 최선**
	- protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 함
	- 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의
- 상속용으로 설계한 클래스는 배포전에 반드시 하위 클래스를 만들어 검증해야 한다.
	- 상속하는 사람을 위해 덧붙인 설명은 단순히 그 클래스의 인스턴스만 만들어 사용할 프로그래머에게는 필요없는 군더더기일 뿐이다.
	- 하지만 이 책을 쓰는 시점엔 일반적인 API 설명과 상속용 설명을 구분해주는 도구가 마땅치 않다.
###### 3. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다
- 이 규칙을 어기면 프로그램이 오동작할 것이다.
- 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로, **하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출**된다.
	- 이 때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다.

> [!done] private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다

 - `Clonable`과 `Serializable` 인터페이스는 상속용 설계의 어려움을 한층 더해준다.
	 - 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다.
	 - 원한다면 하위 클래스에서 이 인터페이스들을 구현하도록 하는 특별한 방법도 있다. ([[이펙티브 자바 3장#Item 13. clone 재정의는 주의해서 진행하라|Item 13]], Item 86 참고)
- `clone`과 `readObject` 메서드는 생성자와 비슷한 효과를 낸다(새로운 객체를 만든다).
	- 즉, `clone`과 `readObject` 모두 **직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.**

다음과 같이 클래스를 **상속용으로 설계하려면 엄청난 노력**이 들고, 그 클래스에 안기는 **제약도 상당함**을 알았다.
- 절대 가볍게 생각하고 정할 문제가 아니다.
- 따라서 이러한 문제를 해결하는 가장 좋은 방법은 *상속용으로 설계하지 않은 클래스는 상속을 금지* 하는 것이다.
	- 클래스를 `final`로 선언하거나
	- 모든 생성자를 `private`이나 `package-private`으로 선언하고 `public` 정적 팩터리를 만들어주면 된다.
- 구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해질 수 있다.
	- 합당한 방법이 하나 있다, 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 하고 이 사실을 문서로 만드는 것이다.

> [!important] 핵심 정리
> 상속용 클래스를 설계하기란 결코 만만치 않다.
> 1. 클래스 내부에서 스스로를 어떻게 사용하는지(자기 사용) 모두 문서로 남겨야하며,
> 2. 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.
> 
> 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다.

---
### Item 20. 추상 클래스보다는 인터페이스를 우선하라

- 자바가 제공하는 다중 구현 메커니즘은 다음과 같다.
	1. 인터페이스
	2. 추상 클래스
- 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다.
	- 자바는 단일 상속만을 지원하므로, 추상 클래스 방식은 새로운 타입을 정의하는 데 큰 제약을 안게 된다.
- 반면 인터페이스는 **기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.**
	- `Comparable`, `Iterable`, `AutoClosable` 인터페이스가 새로 추가됐을 때에도, 표준 라이브러리의 수많은 기존 클래스가 이 인터페이스들을 구현한 채 릴리스됐다.
- 인터페이스는 **믹스인(mixin) 정의에도 안성맞춤**이다.
	- 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.
- 인터페이스로는 **계층구조가 없는 타입 프레임워크를 만들 수 있다.**
	- 타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현할 수 있지만, 현실에는 계층을 엄격히 구분하기 어려운 개념도 있다.
	- 예를 들어 `Singer`와 `Songwriter`가 그렇다. (*131p*  참고)
- 래퍼 클래스 관용구([[#Item 18. 상속보다는 컴포지션을 사용하라|Item 18]] 참고)와 함께 사용하면 인터페이스는 **기능을 향상시키는 안정하고 강력한 수단**이 된다.
	- 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속 뿐이다.

- 한편, 인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공하는 식으로 **인터페이스와 추상 클래스의 장점을 모두 취하는 방법**도 있다.
	- 인터페이스로는 타입을 정의하고, 필요하면 디폴트 메서드 몇 개도 함께 제공한다. 그리고 골격 구현 클래스는 나머지 메서드들까지 구현한다.
	- 이렇게 해두면 단순히 골격 구현을 확장하는 것만으로 이 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다. 이것은 바로 **템플릿 메서드 패턴**의 일종이라 볼 수 있다.
		- 관례상 인터페이스의 이름이 `Interface`라면 그 골격 구현 클래스의 이름은 `AbstractInterface`로 짓는다.
		  e.g. `AbstractCollection`, `AbstractSet`, `AbstractList` ...
		- [>] 이러한 각각이 바로 핵심 컬렉션 인터페이스의 골격 구현이다.
		- List 구현체를 반환하는 정적 팩터리 메서드를 보면 이를 더 확실히 확인해볼 수 있다. 이 예제는 int 배열을 받아 Integer 인스턴스의 리스트 형태로 보여주는 **어댑터 패턴**이기도 하다.
			- *133p* ==코드 20-1 부분 참고==
- 골격 구현은 기본적으로 상속해서 사용하는 걸 가정하므로 [[#Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라|Item 19]]에서 이야기한 설계 및 문서화 지침을 모두 따라야 한다.
- 단순 구현(simple implementation)은 골격 구현의 작은 변종으로, `Abstract.Map.SimpleEntry`가 좋은 예다.
	- 골격 구현과 같이 상속을 위해 인터페이스를 구현한 것이지만, 추상클래스가 아니다.

> [!note] 템플릿 메서드 패턴
> 상위 클래스에서 알고리즘의 구조(골격)를 정의하고, 하위 클래스에서 알고리즘의 특정 단계들을 구현하는 패턴

> [!note] 어댑터 패턴
> 호환되지 않는 인터페이스를 가진 클래스들을 함께 동작할 수 있게 해주는 패턴.
> 기존 클래스를 수정하지 않고도 필요한 인터페이스에 맞출 수 있다.

---
### Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

- 자바 8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다. 자바 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 **디폴트 메서드**를 소개했지만, **위험이 완전히 사라진 것은 아니다.**

> [!question] 디폴트 메서드란?
> 인터페이스에 구현을 가진 메서드를 추가할 수 있게 해주는 기능

- 주의해야 할 점은 디폴트 메서드는 구현 클래스에 대해 아무것도 모른 채 **합의 없이 무작정 '삽입'될 뿐**이라는 것이다.
- 자바 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다.
	- 주로 람다를 활용하기 위함이다.
	- 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분의 상황에서 잘 작동하지만, **생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법**이다.
		- *136p* Collection 인터페이스에 추가된 `removeIf` 메서드 예시를 들 수 있다.
- 디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.
	- 자바 8은 컬렉션 인터페이스에 꽤 많은 디폴트 메서드를 추가했고, 그 결과 기존에 짜여진 많은 자바 코드가 영향을 받은 것으로 알려졌다.
- 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.
- 반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는 데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해준다.([[#Item 20. 추상 클래스보다는 인터페이스를 우선하라|#Item 20]])
- 핵심은, **인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다**는 것이다.
	- 인터페이스를 릴리스한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.

---
### Item 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

- 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.
	- 달리 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 **자신의 인스턴스로 무엇을 할 수 있는 지를 클라이언트에 얘기해주는 것**이다.
	- [i] 인터페이스는 오직 이 용도로만 사용해야 한다.
###### 상수 인터페이스
- 메서드 없이, 상수를 뜻하는 `static final` 필드로만 가득한 인터페이스를 말한다.
- 상수들을 사용하려는 클래스에서는 정규화된 이름을 쓰는 것을 피하고자 이런 인터페이스를 구현하곤 한다.
- 하지만 **상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예**다.
	- 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다. 따라서 상수 인터페이스 구현은 **내부 구현을 클래스의 API로 노출하려는 행위**다.
- 상수를 공개할 목적이라면 더 합당한 선택지가 몇 가지 있다. 
	- 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 **클래스나 인터페이스 자체에 추가**해야 한다.
		- `Integer`, `Double` 등 숫자 박싱 클래스 등에 선언된 `MIN_VALUE`와 `MAX_VALUE` 상수가 이런 예다.
	- 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들어 공개하면 된다.(Item 34)
	- 그것도 아니라면, 인스턴스화할 수 없는 유틸리티 클래스([[이펙티브 자바 1장 + 2장#^b3e45a|Item 4]])에 담아 공개하자.

---
### Item 23. 태그 달린 클래스보다는 클래스 계층 구조를 활용하라

- 두 가지 이상의 의미를 표현할 수 있으며, 그 중 현재 표현하는 의미를 태그 값으로 알려주는 클래스를 사용하지 마라
	- [c] 열거 타입 선언, 태그 필드, `Switch` 문 등 쓸데없는 코드가 많다.
	- [c] 여러 구현이 한 클래스에 혼합돼 있어서 가독성도 나쁘다.
	- [c] 다른 의미를 위한 코드도 언제나 함께 하니 메모리도 많이 사용한다.
	- [c] 필드들을 `final`로 선언하려면 해당 의미에 쓰이지 않는 필드들까지 생성자에서 초기화 해야한다.
- **태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적**이다.
- 다행히 자바와 같은 객체 지향 언어는 타입 하나로 다양한 의미의 객체를 표현하는 훨씬 나은 수단을 제공한다. 바로 **서브타이핑(subtyping)**이다.
- 서브타이핑을 통해 클래스 계층 구조를 만들면 다음과 같은 이점을 얻을 수 있다.
	- [p] 쓸데없는 코드가 모두 사라진다.
	- [p] 살아남은 필드들은 모두 `final`이며, 각 클래스의 생성자가 모든 필드를 남김없이 초기화하고 추상 메서드를 모두 구현했는지 컴파일러가 확인해준다.
	- [p] 실수로 빼먹은 `case`문 때문에 런타임 오류가 발생할 일도 없다.
	- [p] 루트 클래스의 코드를 건들지 않고도 독립적으로 계층구조를 확장하고 함께 사용할 수 있다.
	- [p] 타입이 의미별로 따로 존재하니 변수의 의미를 명시하거나 제한할 수 있고, 또 특정 의미만 매개변수로 받을 수 있다.
	- [p] 타입 사이의 자연스러운 계층 관계를 반영할 수 있어서 유연성은 물론 컴파일타임 타입 검사 능력을 높여준다는 장점도 있다.

---
### Item 24. 멤버 클래스는 되도록 static으로 만들라

> [!question] 중첩 클래스(nested class)란?
> 다른 클래스 안에 정의된 클래스. 
> 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다.
- 중첩 클래스의 종류는 **정적 멤버 클래스, (비 정적) 멤버 클래스, 익명 클래스, 지역 클래스**, 이렇게 4가지이다.
- Item 24에서는 각각의 중첩 클래스를 언제 그리고 왜 사용해야 하는지 이야기한다.
###### 정적 멤버 클래스
- 다른 클래스 안에 선언되고, 바깥 클래스의 `private` 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스와 동일하다.
- 정적 멤버 클래스는 다른 정적 멤버와 똑같은 접근 규칙을 적용 받는다.
- 정적 멤버 클래스는 흔히 바깥 클래스와 함께 쓰일 때만 유용한 **`public` 도우미 클래스로 쓰인다.**
- `private` 정적 멤버 클래스는 흔히 바깥 클래스가 표현하는 **객체의 한 부분(구성요소)을 나타낼 때** 쓰인다.
	- 많은 `Map` 구현체는 각각의 키-값 쌍을 표현하는 엔트리(Entry) 객체들을 가지고 있다. 모든 엔트리가 맵과 연관되어 있지만 엔트리의 메서드들(`getKey`, `getValue`, `setValue`)은 맵을 직접 사용하지는 않는다.
	- 따라서 엔트리를 비정적 멤버 클래스로 표현하는 것은 낭비고, private 정적 멤버 클래스가 가장 알맞다.
###### (비정적) 멤버 클래스
- 정적 멤버 클래스와 비정적 멤버 클래스의 구문상 차이는 단지 `static`이 붙어있고 없고 차이지만, 의미상 차이는 의외로 꽤 크다.
- 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.
	- 그래서 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 `this`를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.
		- [?] 정규화된 `this`는 *클래스명.this* 형태로 바깥 클래스의 이름을 명시하는 용법을 말한다.
	- 따라서 개념상 중첩 클래스의 인스턴스가 **바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다**.
- 비정적 멤버 클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스가 인스턴스화될 때 확립되며, 더 이상 변경할 수 없다.
	- 바깥 클래스의 인스턴스 메서드에서 비정적 멤버 클래스의 생성자를 호출할 때 자동으로 만들어지는게 보통이지만..
	- 드물게는 직접 `바깥 인스턴스의 클래스.new Member Class(argument)`를 호출해 수동으로 만들기도 한다.
		- 이 관계 정보는 비정적 멤버 클래스의 인스턴스 안에 만들어져 메모리 공간을 차지하며, 생성 시간도 더 걸린다.
- **비정적 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다.**
	- 즉, 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용한다.
- 멤버 클래스에서 **바깥 인스턴스에 접근할 일이 없다면 무조건 `static`을 붙여서 정적 멤버 클래스로 만들어야 한다.**
	- `static`을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다.
	- 시간과 공간이 추가로 더 소비되기도 하고,
	- 더 심각한 문제로 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수도 있다.([[이펙티브 자바 1장 + 2장#^0a260f|Item 7]])
	- 참조가 눈에 보이지 않으니 문제의 원인을 찾기 어려워 때때로 심각한 상황을 초래하기도 한다.
###### 익명 클래스
- 익명 클래스는 당연히 이름이 없다. 또한 바깥 클래스의 멤버도 아니다.
- 멤버와 달리, 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다. 코드의 어디서든 만들 수 있다.
- 그리고 오직 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.
- 정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다. 즉, 상수 표현을 위해 초기화 된 `final` 기본 타입과 문자열 필드만 가질 수 있다.
- 익명 클래스는 응용하는데 제약이 많은 편이다.
	- 선언한 지점에서만 인스턴스를 만들 수 있고,
	- `instanceof` 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
	- 익명 클래스는 표현식 중간에 등장하므로 짧지 않으면 가독성이 떨어진다.
- 자바가 람다를 지원하기 전에는 즉석에서 작은 함수 객체나 처리 객체를 만드는 데 익명 클래스를 주로 사용했다.
- 물론 이제는 **람다에게 그 자리를 물려줬다**.(Item 42)
- 익명 클래스의 또 다른 주 쓰임은 **정적 팩터리 메서드를 구현할 때**다.(*133p* ==코드 20-1 부분 참고==)
###### 지역 클래스
- 4가지 중첩 클래스 중 가장 드물게 사용된다.
- 지역 클래스는 지역변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언할 수 있고, 유효 범위도 지역변수와 같다.
- 접근 제어자 및 `static`으로 선언할 수 없다.
- 멤버 클래스처럼 이름이 있고 반복해서 사용할 수 있다.
- 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있으며, 정적 멤버는 가질 수 없고, 가독성을 위해 짧게 작성해야 한다.
- **익명 클래스보다 복잡한 로직이 필요하거나 특정 메서드에서만 필요한 헬퍼 클래스를 캡슐화할 때** 사용된다.

> [!important] 핵심 정리
> 1. 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 **멤버 클래스**
> 2. 멤버 클래스의 인스턴스 각각이 **바깥 인스턴스를 참조한다면 비정적**으로, **그렇지 않으면 정적**으로 만든다.
> 3. 중첩 클래스가 **한 메서드 안에서만 쓰이면서** 그 인스턴스를 생성하는 지점이 **단 한 곳**이고 **해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스**, **아니라면 지역 클래스**로 만든다.

---
### Item 25. 톱레벨 클래스는 한 파일에 하나만 담으라

- 소스 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 자바 컴파일러는 불평하지 않는다.
- **하지만 아무런 득이 없을 뿐더러 심각한 위험을 감수해야 하는 행위**이다.
	- 이렇게 하면 한 클래스를 여러 가지로 정의할 수 있게 되며, 그 중 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하냐에 따라 달라지기 때문이다.
- 다행히 해결책은 아주 간단하다. 단순히 톱레벨 클래스들을 서로 다른 소스 파일로 분리하면 그만이다.
	- 굳이 여러 톱레벨 클래스를 한 파일에 담고 싶다면 정적 멤버 클래스([[#Item 24. 멤버 클래스는 되도록 static으로 만들라|Item 24]])를 사용하는 방법을 고민해 볼 수 있다.
	- 다른 클래스에 딸린 부차적인 클래스라면 정적 멤버 클래스로 만드는 쪽이 일반적으로 더 나을 것이다.
	- 읽기 좋고, `private`으로 선언하면([[#Item 15. 클래스와 멤버의 접근 권한을 최소화하라|Item 15]]) 접근 범위도 최소로 관리할 수 있기 때문이다.