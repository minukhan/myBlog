```table-of-contents
```
### 아이템 28 : 배열보다는 리스트를 사용하라
#### 배열과 제네릭 타입의 중요한 차이점 2가지
##### 1. **배열은 공변(covariant)이고 제네릭은 불공변이다.**
> [!note] 공변(Covariant)이란?
> 어떤 타입 A가 타입 B의 하위 타입이라면, A[]도  B[]의 하위 타입으로 인정되는 성질
> 쉽게 말하면, 자식 타입이 부모 타입 자리에 들어갈 수 있다는 개념이 배열 등에서 유지되는 것을 공변이라고 함.

- 배열 -> Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 됨(공변)
- 제네릭 -> 서로 다른 타입 Type1과 Type2가 있을 때, List< Type1>은 List< Type2>의 하위 타입도 아니고 상위 타입도 아님(불공변)
	-> 이렇게만 보면 제네릭에 문제가 있다고 생각할 수 있지만, 사실 문제가 있는 것은 배열쪽
- 무슨 문제가 있는가?
```java
Object[] object Array = new Long[1]; // Long[] -> Object[]로 자동 변환됨(공변)
objectArray[0] = "타입이 달라 넣을 수 없다."; // 문자열(String)을 넣으려고 함
                                           // -> ArrayStoreException을 던진다. 
```
- 배열의 경우
	- Long[]은 Object의 하위 타입으로 컴파일 타임에는 허용됨
	- 하지만 실제 배열은  Long[]이기 때문에 문자열을 넣는 순간 런타임 오류가 발생
	- 공변성은 편하지만 타입 안정성을 완벽히 보장하지 못함
```java
List<Object> ol = new ArrayList<Long>(); // 컴파일 오류(호환되지 않는 타입)
ol.add("타입이 달라 넣을 수 없다."); // 이 줄까지 도달하지도 못함
```
- 리스트의 경우
	- List< Long>은 List< Object>의 하위 타입이 아니라서 대입 자체가 불가능함
	- 컴파일러가 타입이 다르다는 걸 미리 감지해서 막아줌 -> 안전함
	- 제네릭은 불공변이기 때문에,  List< T> 는 타입 파리미터가 다르면 서로 다른 타입으로 간주됨(저번에 한얼이가 계속 설명함)
- 결론
	: 어느 쪽이든 Long 용 저장소에 String을 넣을 수는 없음. 하지만 에러가 발생하는 시점이 다름. 하지만 컴파일 시점에 문제가 있다는 사실을 알 수 있는 것이 더 나을 것(안정성 측면에서도)
##### 2. 배열은 실체화된다.
- 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인함
	-> 이 때문에 위에 코드 28-1에서 본 것처럼 ArrayStoreException이 발생
- 반면, 제네릭은 타입 정보가 런타임에는 소거(erasure)된다.
	-> 원소 타입을 컴파일 타입에만 검사하며 런타임에는 알 수 없음
- 소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘
	-> 자바 5가 제네릭으로 순조롭게 전환될 수 있도록 해줌
- **제네릭 배열은 사용 불가**(만들 수 없음)
	- new List< E>[], new ArrayList< String>[10] 같은 제네릭 배열 생성은 허용되지 않음
	- 타입 안정성을 보장할 수 없기 때문
	- 제네릭 배열을 금지한 이유
		- 자바에서 제네릭은 컴파일 타임에만 정보를 가지며, 런타임에는 타입 정보가 지워지는 방식(type erasure)
			-> List< String>[]는 컴파일 타임에는 분명 String 용 배열이지만, 런타임에는 그냥 List[] 가 되어 버려서 타입 구분이 불가능해짐
			-> 이런 상황에서 잘못된 타입을 저장하더라도 컴파일러가 막을 수 없고, 결국 런타임에 ClassCastException이 발생할 수 있음
			(런타임에 ClassCastException이 발생하는 일을 막아주겠다는 제네릭 타입 시스템의 취지에 어긋남)
		- 제네릭에서는 소거가 발생하기 때문에 컴파일러는 타입 안전을 위해 다음과 같은 형변환을 자동으로 삽입해줌
			-> 이 형변환은 런타임에 실행되기 때문에 잘못된 타입이 들어가 있으면 ClassCastExeption이 발생
```java
		List<String> list = new ArrayList<>();
		String s = list.get(0);
		---------- 위 코드는 컴파일 후 아래의 코드로 변환됨 -----------
		List list = new ArrayList(); // 타입 소거로 인해 List<String> -> List
		String s= (String) list.get(0); // 컴파일러가 (String) 캐스팅을 자동 추가
```
-  위의 이유로 제네릭 배열 생성을 금지함으로써 이러한 위험한 상황을 사전에 차단
- E, List< E>, List< String> 같은 타입을 실체화 불가 타입이라고 함
	- 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입
		-> 런타임에 타입 정보가 소거되어 있음(List< String>이지만, 런타임에는 그냥 List)
	- 배열의 원소 타입으로 쓸 수 없음
	- 예외적으로 List< ?> 와 같은 비한정 와일드카드 타입은 실체화 가능
- 아래에 나오는 Chooser 예제는 비검사 형변환 경고를 제거하기 위해 배열 대신 리스트를 사용하는 것을 조금씩 변경하면서 보여주는 예제이고 한 번 읽어보면 좋을듯
	-> 이 과정에서 코드양이 조금 늘어나고 속도도 조금 느려지지만, 런타임에 ClassCastException이 발생하지 않게 됨
### 아이템 29 : 이왕이면 제네릭 타입으로 만들라
- JDK가 제공하는 제네릭 타입과 메서드를 사용하는 일은 일반적으로 쉬운 편이지만, 제네릭 타입을 새로 만드는 일은 조금 더 어려움
- 코드 29-1
	- 처음에 나온 Object를 기반으로 구현된 스택의 경우에는 스택에서 꺼낸 객체를 형변환 해야하기 때문에 런타임 오류가 발생할 위험이 있음
		-> 제네릭으로 만들어야 함
	- 일반 클래스를 제네릭 클래스로 만들기
		1. 클래스 선언에 타입 매개변수를 추가하기(Object -> E)
			-> 타입 이름으로는 보통 E를 사용
			-> E와 같은 실체화 불가 타입으로는 배열을 만들 수 없으므로 이 단계에서 오류 발생(배열을 사용하는 코드를 제네릭으로 만들려 할 때 자주 발생하는 문제)
			- 제네릭 배열 생성 오류를 해결하는 방법
				1. 제네릭 배열 생성을 금지하는 제약을 우회
					- Object 배열을 생성한 다음 제네릭 배열로 형변환하게 된다면 컴파일러는 오류 대신 경고를 내보냄
					  but, 타입 안전하지 않음
						-> 비검사 형변환이 프로그램의 타입 안정성을 해치지 않음을 스스로 확인해야 함
						-> 비검사 형변환이 안점함을 증명했다면 범위를 최소로 좁혀 @SuppressWarnings 어노테이션으로 해당 경고를 숨김
					- 이 예제에서는 비검사 배열 생성 말고는 하는 일이 없으니 생성자 전체에서 경고를 숨겨도 괜찮음
				2. elements 필드의 타입을 E[]에서 Object[]로 바꾸는 것
					- 여기서도 오류가 발생하는데 배열이 반환한 원소를 E로 형변환하면 오류 대신 경고가 발생(unchecked cast)
					- E는 실체화 불가 타입이므로 컴파일러는 런타임에 이뤄지는 형변환이 안전한지 증명할 방법이 없음
						-> 이번에도 안전함을 직접 증명하고 경고를 숨길 수 있음
						  (메서드 전체에서 경고를 숨기지 말고 비검사 형변환을 수행하는 할당문에서만 숨기자)
			- 첫 번째 방법이 가독성이 더 좋고 코드도 더 짧음
				-> 배열의 타입을 E[]로 선언하여 오직 E 타입 인스턴스만 받음을 확실히 어필
			- 첫 번째 방식에서는 형변환을 배열 생성 시 단 한 번만 해주면 되지만, 두 번째 방식에서는 배열에서 원소를 읽을 때마다 해줘야 함.
				-> 이러한 이유들로 현업에서는 첫 번째 방식을 선호
			- 하지만 배열의 런타임 타입이 컴파일 타임 타입과 달라 힙 오염(heap pollution)을 일으킴
				-> 힙 오염이 맘에 걸리는 경우에는 두 번째 방식을 사용하기도 함
- 코드 29-5에서 이렇게 수정된 제네릭 Stack 클래스를 사용하고 Stack에서 꺼낸 원소에서 String의 toUpperCase 메서드를 호출할 때 명시적 형변환을 수행하지 않고 오류가 발생하지 않음
	-> 컴파일러에 의해 자동 생성된 형변환이 항상 성공함을 보장
- 지금까지 다룬 내용들은 아이템 28의 내용과 모순됨
	-> 사실 제네릭 타입 안에서 리스트를 사용하는 게 항상 가능하지도, 꼭 더 좋은 것도 아님
	 (실제로는 현실적 필요와 성능 때문에 배열을 사용할 수도 있음)
	 - 왜 배열을 쓰는가?
		 - ArrayList, Stack 같은 표준 제네릭 컬렉션은 내부 구현에 배열을 사용
		 -> 성능(빠른 접근), 공간 효율, 배열 복사 등의 이유
		 - 배열을 외부에 노출하지 않고, 타입 안전하게 감싸서 사용하면 문제 없음
>[!note] 핵심은 "외부에서 제네릭 배열을 직접 다루지 말고, 내부 구현에만 사용하라"는 것
- 기본 타입은 제네릭에 사용하지 못함
	: Java의 제네릭은 기본 타입(int, double)을 허용하지 않고 대신 박싱 타입(Integer, Double)을 사용해야 함
```java
Stack<int> // 컴파일 에러 발생
```
- 한정적 타입 매개변수(Bounded Type Parameter)
	- E는 반드시 Delayed의 하위 타입이어야 함 -> 한정적 타입 매개변수
	- 클라이언트 코드에서 E의 메서드를 바로 호출할 수 있고, 형변환 없이도 타입 안전성을 확보할 수 있음
	- 모든 타입은 자기 자신의 하위 타입이므로 DelayQueue< Delayed>도 사용 가능
```java
class DelayQueue<E extends Delayed> implements BlockingQueue<E>

Delayed d = ququq.take(); // 형변환 필요 없음
```
### 아이템 30 : 이왕이면 제네릭 메서드로 만들라
- 클래스와 마찬가지로, 메서드도 제네릭으로 만들 수 있음
	-> 매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭
	 (Collections의 '알고리즘' 메서드 binarySearch, sort 등은 모두 제네릭)\
 - 제네릭 메서드란?
	 - 메서드 선언에 타입 매개변수 < E> 등을 직접 명시하여 사용하는 메서드
	- 반환 타입 앞에 < T> 같은 매개변수 선언부가 들어감
	- 형변환 없이 사용할 수 있는 타입 안전한 메서드
		-> 사용자가 명시적 형변환 없이도 정확한 타입으로 결과를 받을 수 있음
```java
public static <E> E identity(E value) { 
	return value; 
}
 ```
 - 가장 먼저 코드 30-1에 잘못된 예가 나옴
	 -  여기서는 Set이라는 raw 타입을 사용했고, 컴파일러는 타입 정보를 알 수 없으므로 경고 발생
	 - 결과적으로 타입 안정성 없음
 - 코드 30-2에 올바른 제네릭 메서드가 나옴
	 - 타입 매개변수 < E>를 선언하고 이를 파라미터와 반환값에 일관되게 사용
	 - 경고 없이 컴파일되고, 형변환 없이 안전하게 사용 가능
	 - 제네릭 메서드란?
		 - 메서드 선언에 타입 매개변수 < E> 등을 직접 명시하여 사용하는 메서드
		 - 반환 타입 앞에 < T> 같은 매개변수 선언부가 들어감
```java
public static <E> E identity(E value) { return value; }
 ```
##### 제네릭 싱글턴 팩터리 패턴
- 불변 객체(or  상태 없는 객체)를 다양한 제네릭 타입으로 재사용할 수 있도록 만든 패턴
- 사용 이유
	- 제네릭은 타입마다 따로 인스턴스를 생성하지 않아도 되도록, 타입 소거를 기반으로 동작
		-> Set< String>, Set< Integer> 등 서로 다른 타입으로 보이지만, 런타임엔 모두 동일한 클래스로 취급됨
	- 하나의 인스턴스만 만들어 재사용하면 성능과 메모리 측면에서 유리하고, 로직도 단순해짐

- 항등함수 예시는 한 번 읽어보면 좋을 듯
##### 재귀적 타입 한정(Recursive Type Bound)
```java
public static <E extends Comparable<E>> E max(Collection<E> c)
```
- 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정하는 것
- 주로 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰임
- 타입 E는 자기 자신과 같은 타입의 원소와만 비교 가능(거의 모든 타입의 경우)
	-> E는 Comparable< E>를 구현함
- 사용 이유
	- 컬렉션에 있는 모든 원소가 서로 비교 가능해야 검색, 최소값, 최댓값 등의 기능 수행 가능
### 아이템 31 : 한정적 와일드카드를 사용해 API 유연성을 높이라
- **아이템 28에서 배운 내용 복습**  
    → 제네릭 타입은 불공변(invariant)이다.  
    → 예: `List<String>`은 `List<Object>`의 하위 타입이 아님
- **직관적으로 이해하기**  
    → `List<Object>`에는 어떤 타입이든 넣을 수 있지만  
    `List<String>`에는 오직 문자열만 넣을 수 있음  
    → 즉, 하위 타입으로 대체 불가 → **리스코프 치환 원칙** 위반
- 가끔씩은 불공변 방식보다 유연한 무언가가 필요
	- 문제 상황 : API가 불필요하게 제한적일 때(코드 31-1 -> 와일드카드를 사용하지 않은 pushAll)
		`public void pushAll(Iterable<E> src)`
		- `Stack<Number>`에 `Iterable<Integer>`를 넣으려 하면 컴파일 오류 발생(타입이 완벽하게 일치해야 함)
			-> `Iterable<Integer>` ≠ `Iterable<Number>`이기 때문
	- 해결 방법 : 와일드카드로 생산자 허용 범위 확장(자바는 이런 상황에 대처할 수 있는 한정적 와일드카드 타입이라는 특별한 매개변수화 타입 지원)
		-> pushAll의 입력 매개변수 타 입은 ‘E의 Iterable’이 아니라 'E의 하위 타입의 Iterable’이어야 하며, 와일드 카드 타입 Iterable가 정확히 이런 뜻임
		- `? extends E` -> E의 하위 타입까지 허용
- **유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라**
- 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없음
	-> 타입을 정확히 지정해야 하는 상황으로, 이때는 와일드카드 타입을 쓰지 말아야 함
##### 팩스(PECS) : producer-extends, consumer-super
- 와일드카드 타입을 사용하는 기본 원칙
- 겟풋 원칙으로 부르기도 했음(나프탈린과 와들러... 이런게 있다 정도...)
- 매개변수화 타입 T가 생산자라면 `<? extends T>`를 사용하고, 소비자라면 `<? super T>`를 사용하라는 것
	-> Stack 예에서 pushAll의 src 매개변수는 Stack이 사용 할 E 인스턴스를 생산하므로 src의 적절한 타입은 Iterable
	-> popAll의 dst 매개변수는 Stack으로부터 E 인스턴스를 소비하므로 dst어의 적절한 타입은 Collection
>[!note]
>반환 타입에는 한정적 와일드카드 타입을 사 용하면 안됨
>유연성을 높여주기는커녕 클라이언트 코드에서도 와일드카드 타입을 써야 하기 때문

- 클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 문제가 있을 가능성이 큼
	-> 제대로 사용한다면 받아들여야 할 매개변수를 받고 거절해야 할 매개변수는 거절하는 작업이 알아서 이루어짐
- 자바 8 이상에서는 타입 추론이 잘 되지만, 7 이하에서는 명시적 타입 인수가 필요

- max 예제는 한 번 읽어보면 될 듯
```java
public static <E> void swap(List<E> list, int i, int j);
public static void swap<List<?> list, int i, int j);

/* 두 번째 방법 */
public static void swap(List<?> list, int i, int j) {
    list.set(i, list.set(j, list.get(i))); // ❌ 컴파일 오류
}

/* 도우미 제네릭 메서드 */
public static void swap(List list, int i, int j) { swapHelper(list, i, j); } // 와일드카드 타입을 실제 타입으로 바풔주는 private 도우미 메서드 
private static void swapHelper(List list, int i, int j) { 
list.set(i, list.set(j, list.get(i))); 
}
```
- 코드 31-7 : swap 메서드 예제
	-> public API라면 간단한 두 번째가 나음(어떤 리스트든 이 메서드에 넘기면 명시한 인덱스의 원소들을 교환해 줄 것이고 신경 써야 할 타입 매개변수도 없음)
- **메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하라**
	-> 비한정적 타입 매개변수라면 비한정적 와일드카드로 바꾸고, 한정적 타입 매개변수라면 한정적 와일드카드로 바꾸면 됨
- 하지만 두 번째 방법은 컴파일되지 않음(와일드카드 버전의 내부 구현은 불가능)
	-> `List<?>`에는  null 외에는 값을 다시 넣을 수 없음
	-> 컴파일러는 타입을 Object로 간주하고 다시 넣으려 하면 타입 안정성 위배라고 판단
- 해결 방법 : 도우미 제네릭 메서드 사용(와일드카드 타입의 실제 타입을 알려주는 메서드)
	- swapHelper()는 제네릭 메서드 -> 타입 E가 명확함
	- 외부에서는 간단한 와일드카드 버전 API, 내부에서는 타입 안정성 확보된 제네릭 사용
	- 도우미 메서드의 시그니처는 앞에서의 첫 번째 swap 메서드의 시그니처와 완전히 같음
- 와일드카드 타입을 적절히 사용하면 API가 훨씬 유연해짐
### 아이템 32 : 제네릭과 가변인수를 함께 쓸 때는 신중하라
- 여기서는 제네릭과 가변인수(varargs)를 함께 사용할 때 발생할 수 있는 문제점과 해결책을 다룸
- 자바 5에서 **제네릭과 varargs**(가변인수)가 함께 도입되었지만, 둘의 궁합은 좋지 않음
- varargs는 호출 시 **배열을 자동 생성**하는데, 이 배열이 **클라이언트에 노출**되며 **타입 안전성 문제가 발생**
- **실체화 불가 타입**이 varargs 매개변수에 포함되면 **컴파일 경고 발생**
- 힙 오염 : 제네릭 타입 배열이 다른 타입 객체를 참조하면서 타입 안정성이 깨지는 현상
- 코드 32-1은 제네릭과 varargs(가변인수)를 혼요한 위험한 메서드 예시
	-> 명시적 형변환은 없지만, 컴파일러가 삽입한 자동 형변환으로 인해 런타임 오류 발생
- 제네릭 배열을 프로그래머가 직 접 생성하는 건 허용하지 않으면서 제네릭 varargs 매개변수를 받는 메서드 를 선언할 수 있게 한 이유
	- 실무에서 유용하기 때문 -> 대표 메서드 : Arrays.asList(T... a), Collections.addAll(), EnumSet.of()
	- 이런 메서드들은 타입 안전한 방식으로 잘 설계됨
##### @SafeVarargs 어노테이션
- 자바 7부터 도입된 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치
	-> 컴파일러는 이 약속을 믿고 그 메서드가 안전하지 않을 수 있다는 경고를 더 이상 하지 않음
- 메서드가 안전한게 확실하지 않다면 절대 @SafeVarargs 어노테이션을 달면 안됨
- 메서드가 안전하다고 간주되는 조건
	1. varargs 매개변수 배열에 값을 저장하지 않음
	2. 배열(또는 그 복제본)의 참조를 외부에 노출하지 않음
	-> varargs 매개변수 배열이 호출자로부터 그 메서드로 순수하게 인수를 전달하는 일만 한다면(varargs의 목적대로만 쓰인다면) 그 메서드는 안전한 것
- 코드 32-2는 자신의 제네릭 매개변수 배열의 참조를 노출하는 안전하지 않은 경우의 예시이고 설명은 읽어보면 좋을 듯
	- 이 배열의 타입은 컴파일 타임에 결정되며 Object[]로 생성될 수 있음
	- 배열이 외부로 노출되면 힙 오염 발생 가능
	- pickTwo 예시와 main
		: pickTwo의 반환값으로 나오는 배열이 Object[]로 생성되고 반환값을 attributes에 저장하기 위해 String[]로 형변환하는 코드가 자동으로 생성됨
		-> Object[]는 String[]의 하위 타입이 아니므로 이 형변환은 실패함
	- 이 예제를 통해 **제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.**라는 점을 다시 한 번 상기할 수 있음
		- 예외 2가지
			1. @SafeVarargs로 제대로 어노테이트된 또 다른 varargs 메서드에 넘기는 것은 안전
			2. 이 배열 내용의 일부 함수를 호출만 하는(varargs를 받지 않는) 일반 메서드에 넘기는 것도 안전
```java
/* 코드 32-3 */
@SafeVarargs static List flatten(List... lists) { 
	List res니It = new ArrayListo(); 
	for (List list : lists) result.addAll(list); 
	return result; 
}
```
- 코드 32-3은 제네릭 varargs 매개변수를 안전하게 사용하는 전형적인 예시
	-> @SafeVarargs 어노테이션이 달려 있어 선언하는 쪽과 사용하는 쪽 모두에서 경고를 내지 않음
- @SafeVarargs 어노테이션을 사용할 때를 정하는 규칙
	-> 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @SafeVarargs를 달아라
	-> 이렇게 되면 사용자를 헷갈리게 하는 컴파일러 경고를 없앨 수 있음
	-> 따라서 안전하지 않은 varargs 메서드는 절대 작성해서는 안됨
	- 다음 두 조건을 모두 만족하는 제네릭 varargs 메서드는 안전(둘 중 하나라도 어겼다면 수정해야 함)
		1. varargs 매개변수 배열에 아무것도 저장하지 않는다.
		2. 배열(혹은 복제본)을 신뢰할 수 없는 코드에 노출하지 않는다.
> [!note]
> @SafeVarargs 어노테이션은 재정의할 수 없는 메서드에만 달아야 함.
> -> 재정의한 메서드도 안전할지는 보장할 수 없기 때문

- varargs 매개변수를 List 매개변수로 바꾸는 방법도 존재(아이템 28에 해당하는 내용)
- 코드 32-4가 위의 방법에 해당하는 예제
	- 정적 패터리 메서드 List.of를 사용하면 임의 개수의 인수 전달 가능
		-> 가능한 이유 : List.of에도 @SafeVarargs 어노테이션이 달려있기 때문
	- List 방식의 장단점
		- 장점 : 컴파일러가 메서드의 타입 안정성을 검증할 수 있음
			-> @SafeVarargs 어노테이션을 직접 달지 않아도 되고 실수로 안전하다고 잘못 판단할 걱정이 없음
		- 단점 : 클라이언트 코드가 살짝 지저분해지고 속도가 조금 느려질 수 있음
- 다음으로 pickTwo 메서드에 List 방식을 적용하는 예시가 나오는데, 결론적으로 결과 코드는 배열 없이 제네릭만 사용하므로 타입 안전함
### 아이템 33 : 타입 안전 이종 컨테이너를 고려하라.
- 제네릭의 일반적 사용
	- `Set<E>`, `Map<K,V>` 등의 컬렉션과 `ThreadLocal<T>` 등의 단일원소 컨테이너에 흔히 사용
	- 보통 컨테이너 자신이 매개변수화되어 컨테이너당 매개변수화 할 수 있는 타입의 수가 제한됨
##### 타입 안전 이종 컨테이너 패턴(type safe heterogeneous container pattern)
- 더 유연한 수단이 필요할 때 사용
- 컨테이너가 아닌 키를 매개변수화하고, 값을 넣거나 뺄 때 이 매개변수화한 키를 함께 제공
- 제네릭 타입 시스템의 값의 타입이 키와 같음을 보장
>[!note]
>컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴을 타입 토큰(type token)이라 함
- 예시로 나온 Favorites 클래스의 구현
	- 와일드카드 타입이 중첩됨(맵이 아닌 키가 와일드카드 타입)
	- 맵의 값 타입은 Object이므로 키와 값 사이의 타입 관계를 직접 보증하지는 않음
	- getFavorite에서 Class의 cast 메서드를 사용해 동적 형변환 수행
- Favorites 클래스의 제약
	1. **타입 안전성 위반 가능성** 
		→ 악의적인 클라이언트가 Class 객체를 로 타입으로 넘기면 타입 안전성 훼손 
		→ 다음과 같이 런타임 타입 안전성을 확보할 수 있음
	2. **실체화 불가 타입에는 사용 불가** 
		→ String이나 String[]은 저장 가능하지만 `List<String>`은 불가능 
		→ `List<String>.class`와 같은 리터럴은 문법 오류 
		→ 이 제약에 대한 완벽한 우회로는 없음
- 한정적 타입 토큰
	- 허용하는 타입을 제한하고 싶을 때 사용
	- 한정적 타입 매개변수나 한정적 와일드카드로 표현 가능한 타입을 제한하는 토큰
	- 어노테이션 API에서 적극적으로 사용됨
- Favorites가 사용하는 타입 토큰은 비한정적
	-> 즉, getFavorite과 putFavorite은 어떤 Class 객체든 받아들임
	-> 이 메서드들이 허용하는 타입을 제한하고 싶을 때 한정적 타입 토큰을 활용하면 가능
- Class.asSubclass 메서드
	- 한정적 타입 토큰으로 안전하게 형변환할 때 사용
	- 호출된 인스턴스의 Class 객체를 인수로 명시한 클래스로 형변환
	- 성공하면 인수로 받은 클래스 객체를 반환, 실패하면 ClassCastException 발생