## 아이템 69. 예외는 진짜 예외 상황에서만 사용해라

> [!note] 정리
> - 예외는 정상 흐름을 제어하는 용도로 사용해서는 안된다. 
> - 예외는 진짜 예외 상황에서만 사용해라!

#### 책에서의 예시 

```
try {
    int i = 0;
    while (true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```

- 코드를 보면 반복문을 도는데 만약 끝까지 가서 ArrayIndexOutOf 오류가 뜨면 종료하게끔 작성해서 끔찍하다고 소개

#### 왜 이렇게 사용하면 안돼?

- 직관성이 매우 떨어진다 
- 성능이 저하된다고 한다. 
	- 예외처리가 반복문보다 느리다고 한다.
- 버그 은폐를 시킬 수 있다. 예외가 다른 원인일 수 있다고 함.
- JVM 최적화를 방해한다고 합니다. 

#### 바람직한 코드 

```
for (Mountain m : range)
    m.climb();
```

#### 보통 잘못된 생각?

- 예외가 경계 검사를 생략하니까 더 빠르겠지? 
	- -> No 
	- JVM은 반복문에선 중복 검사 최적화가 가능하다. 

- 예외 처리가 더 효율적일 수 있다. 
	- 실제로는 2배 이상 느리다고 한다. 

- 예외 처리로 종료가 간편하다. 
	- 버그가 숨겨지는 오류가 발생할 수 있다. 


#### API 설계 원칙에도 적용된다. 

- API 사용자에게 예외를 강요하지마라. 
- 상태 의존적 메서드가 있다면 상태 검사 메서드도 제공하라고 함. 

- 예시로 Iterator 를 들고있음
```
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
}
```

- 잘못된 사용
```
try {
    Iterator<Foo> i = collection.iterator();
    while (true) {
        Foo foo = i.next();
    }
} catch (NoSuchElementException e) {
}
```
> 위 코드는 예외를 흐름 제어에 사용하는 **전형적인 안티패턴**

#### 상태검사 vs 예외 vs Optional 어떻게 선택할까?

- 상태가 외부 요인으로 바뀔 수 있는 경우 
	- Optional 을 사용해라.
	- 그 이유는 상태를 먼저 검사한 뒤 작업을 하려는 사이에 상태가 바뀌면 엉뚱한 결과를 초래할 수 있기 때문.
- 상태 검사 메서드와 실제 작업이 비슷한 일을 2번하는경우.
	- 이때도 Optional 을 사용해라. 

- 그 이외의 일반적인 경우에는 
	- 상태 검사 메서드 + 예외를 함께 사용해서 쓰는게 좋다. 
	- 상태를 확인하고 그에 맞게 동작하도록 명확하기 나눠지기 때문. 

#### 정리 

- 반복문 종료를 예외로 처리하지말고
	 -> for, while, foreach 일반 반복문 써라

- 상태검사 없이 예외로 흐름 제어하지 말고  
	 -> hasNext() 같은 상태 검사 메서드를 사용해라.

- 예외로 로직 분기하지말고 
	 -> is-else , Optional 등을 사용해라. 

> 예외는 진짜 예외에서만 사용해라
> 정상 흐름을 제어하는데 쓰면 안됨. 

## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용해라. 

#### 복구가 가능하면 - > 검사 예외

- 호출자가 예외 상황을 복구할 수 있다고 판단되면, 검사예외를 사용한다. 
- 검사 예외는 throws, catch 로 반드시 처리하도록 강제한다. 
- 호출자에게 이 상황은 예외지만 너가 해결해! 라고 알려주는 것. 
	- ex) 파일이 존재하지 않는경우, 네트워크 일시적 실패, 사용자 잔고 부족 등
#### 프로그래밍 오류면 -> 런타임 예외

- 전제조건을 위반한느 프로그래밍 실수에 해당하면 런타임예외.
- 복구할 수 없는 문제니까 catch는 필요가 없음!
- ex) NullPointerException, ArrayIndexOutOfBoundsException

#### 확신이 없다면? -> 런타임 예외를 사용해라

- 복구가 가능할지 확실하지 않으면 그냥 비검사 예외를 사용해라. 


#### 사용하지 말아야 할 것들

- Error 를 상속한 예외는 사용하지 마라
	
	- JVM의 심각한 메모리부족문제를 나타냄. 
	- 직접 정의하거나 던지면 안됨. 

- 검사/ 비검사 예외가 아닌 throwable 하위 클래스 
	- Exception 도 아니고 RuntimeException 도 아닌 예외는 그냥 사용하지 마라 
	- API 사용자에게 혼란만 준다. 

#### 권장하는 것

- 만약에 검사예외를 만들때, 복구에 필요한 정보를 제공하는 메서드를 함께 제공해라. 
	- 잔고 부족이면 -> 얼마나 잔고가 부족한지 반환하는 메서드를 포함시켜라!
- 예외 메시지를 파싱하지 마라.
	- 대신 명시적인 정보를 제공하는 메서드를 만들어라. 
#### 정리

> 복구할 수 있는 상황? -> 검사 예외
> 복구할 수 없다 -> 비검사 예외
> 
> throwable 만 상속한 예외나 Error 는 절대 만들지 마라.
> 검사 예외를 만든다면 복구에 필요한 정보를 함께 제공해라. 


## 아이템 71. 필요없는 검사 예외 사용은 피해라

> [!note] 정리
> 
> - 검사 예외는 꼭 필요한 곳에만 사용해라.
> - 검사 예외는 복구 가능하고, 의미있는 처리를 호출자가 해야할때 사용해라.
> - 무조껀 검사예뢰를 쓰면 API 사용이 불편해지고 스트림에서 사용이 어려워짐. 


#### 자바 예외의 상속 구조 간단히. 
```
Throwable
├── Error                  // 시스템 오류 (비검사 예외)
├── Exception              // 일반 예외 (검사 예외의 부모)
│   ├── IOException        // 대표적인 검사 예외
│   └── RuntimeException   // 비검사 예외의 시작점

```
#### 발생할 수 없는 예외 

```
public void doSomething() {
    try {
        Class.forName("java.lang.String"); // 항상 존재하는 클래스
    } catch (ClassNotFoundException e) {
        throw new AssertionError(); // 발생할 리 없음
    }
}

```

- 위처럼 복구할 수 없거나 예외 상황을 포기하는 코드라면, 검사 예외는 부적절하다.
- 비검사 예외를 사용해라. 

#### 만약에 이런 검사 예외를 회피하고싶다??

- 옵셔널을 사용하면 된다. 
	- 예외 대신에 Optional.empty() 를 반환
	- 단점 : 왜 이 코드가 실패했는지 정보가 부족하다. 
	- 장점 : 코드가 간결해지고 스트림과 호환성이 좋음. 

	- Optional 은 실패 원인 설명이 부족하므로 단순 실패 처리에만 적합하다. 

#### 정리 

> 검사 예외는 복구할 수 있고 의미있는 처리가 가능할때만 사용해라.
> 복구 방법이 없거나 예외 의미가 단순하면 비검사 예외나 Optional 로 대체해라. 

## 아이템 72. 표준 예외를 사용해라

- 숙련된 프로그래머는 예외도 재사용한다.
	- 자바 표준 라이브러리는 이미 충분한 예외 클래스를 제공함. 
	- 새로 만들기보단 표준 예외를 사용해라.

#### 표준 예외의 장점? 

- 다른사람이 API 를 익히고 사용하기 쉽다. 
- API 를 사용하는 코드가 읽기 쉽다. 
- 예외 클래스 수가 적어 메모리 사용과 클래스 적재 시간이 줄어든다. 

#### 자주 재사용되는 표준 예외 참고하자

|예외명|용도|
|---|---|
|`IllegalArgumentException`|잘못된 인수 값이 넘어왔을 때 (null은 제외)|
|`IllegalStateException`|객체 상태가 메서드 실행에 부적합할 때|
|`NullPointerException`|null이 허용되지 않는 곳에 null이 들어왔을 때|
|`IndexOutOfBoundsException`|인덱스가 허용 범위를 벗어났을 때|
|`ConcurrentModificationException`|단일 스레드용 객체에 동시 수정 시도 시|
|`UnsupportedOperationException`|호출된 메서드를 지원하지 않을 때|


#### 예외 선택할때 참고할 것.

- 예외 이름 뿐만 아니라 예외가 던져지는 상황과 의미를 문서로 확인해라.
- 상황에 맞지 않는 예외를 억지로 쓰지말고 표준예외를 확장해서 써라.
- 예외는 직렬화 가능하므로 불필요한 커스텀 예외 생성은 부담이 될 수 있다함. 

#### 정리

> 항상 표준예외를 우선 사용하되 너무 의미가 맞지 않으면 확장해서 써라.
> 
> 항상 예외를 고를때 의미와 맥락이 맞는지 꼼꼼히 확인해라. 더 혼동을 줄 수 있다. 

