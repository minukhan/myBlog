### Item 46. 스트림에서는 부작용 없는 함수를 사용하라

스트림은 그저 또 하나의 API가 아닌, **함수형 프로그래밍에 기초한 패러다임**이다.
- 스트림이 제공하는 표현력, 속도, (상황에 따라서는) 병렬성을 얻으려면 API는 말할 것도 없고 이 패러다임까지 함께 받아들여야 한다.
##### 스트림 패러다임의 핵심
- 계산을 일련의 변환(transformation)으로 재구성하는 부분
- 이 때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 **순수함수**여야 한다.
- 이렇게 하려면 (중간 단계든, 종단 단계든) 스트림 연산에 건네는 함수 객체는 모두 부작용(side effect)이 없어야 한다.

> [!question] 순수 함수란?
> 오직 입력만이 결과에 영향을 주는 함수. 다른 가변 상태를 참조하거나, 함수 스스로 다른 상태를 변경하지 않는다.
##### for-each 반복문
- `for-each` 반복문은 `forEach` 종단 연산과 비슷하게 생겼다.
- 하지만 `forEach` 연산은 종단 연산 중 기능이 가장 적고 가장 '덜' 스트림답다.
	- 대놓고 반복적이라 병렬화 할 수도 없다.
- [>] 따라서, `forEach` 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산할 때는 쓰지 말자.
##### Collector(수집기)
- 수집기(Collector)를 사용하면 스트림의 원소를 손쉽게 컬렉션(Collection)으로 모을 수 있다.
- `java.util.stream.Collectors` 클래스는 메서드는 무려 39개(자바 10에서는 4개가 더 늘어 43개이다.)나 가지고 있고, 그 중에는 타입 매개변수가 5개나 되는 것도 있다. 
- `toList()`, `toSet()`, `toCollection(collectionFactory)`
	- 차례로 리스트, 집합, 프로그래머가 지정한 컬렉션 타입을 반환한다.
- Collectors의 나머지 36개 메서드 중 대부분은 스트림을 맵으로 취합하는 기능으로, 진짜 컬렉션에 취합하는 것보다 훨씬 복잡하다.
- 가장 간단한 맵 수집기는 `toMap(keyMapper, valueMapper)`.
	- 스트림의 각 원소가 고유한 키에 매핑되어 있을 때 적합하다.
	- [!] 만약 같은 키를 사용한다면? 파이프라인이 `IllegalStateException`을 던지며 종료된다!
- Collectors의 나머지 메서드(`groupingBy`, `joining`, `filtering`, `minBy` ...)는 *책 읽어보기*

> [!important] 핵심 정리
> 스트림 파이프라인 프로그래밍의 핵심은 **부작용 없는 함수 객체**에 있다. 스트림뿐 아니라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야 한다.
> 종단 연산 중 forEach는 스트림이 수행한 계산 결과를 보고할 때만 이용하라.
> 스트림을 올바로 사용하려면 수집기(Collector)를 잘 알아두어야 한다.

---
### Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다

원소 시퀀스를 반환할 때는 당연히 스트림을 사용해야 한다는 이야기를 들어봤을지 모르지만, [[이펙티브 자바 7장#아이템 45 스트림은 주의해서 사용하라|Item 45]] 에서 이야기 했듯이 스트림은 반복(iteration)을 지원하지 않는다.
- 따라서 스트림과 반복을 알맞게 조합해야 좋은 코드가 나온다.
- 사실 Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함할 뿐만 아니라, *Iterable 인터페이스가 정의한 방식대로 동작*한다.
- 그럼에도 for-each로 스트림을 반복할 수 없는 까닭은 바로 **Stream이 Iterable을 확장(extend)하지 않아서**다.
##### 스트림과 반복의 양립성 문제
- 클라이언트가 스트림만 사용하거나 반복만 사용할 것이라고 가정하면 안 된다.
- Stream을 Iterable로 중개해주는 어댑터 메서드를 사용할 수 있지만, 코드가 복잡해지고 성능도 좋지 않다.
```java
// Stream<E>를 Iterable<E>로 중개해주는 어댑터
public static <E> Iterable<E> iterableOf(Stream<E> stream) {
    return stream::iterator;
}

// Iterable<E>를 Stream<E>로 중개해주는 어댑터  
public static <E> Stream<E> streamOf(Iterable<E> iterable) {
    return StreamSupport.stream(iterable.spliterator(), false);
}
```
##### 컬렉션을 반환하는 것이 최선
- `Collection` 인터페이스는 `Iterable`의 하위 타입이고 `stream` 메서드도 제공한다.
- 따라서 반복과 스트림을 동시에 지원할 수 있다.
- **원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위 타입을 쓰는 게 일반적으로 최선이다.**
- 반환할 시퀀스가 크지만 표현을 간결하게 할 수 있다면 전용 컬렉션을 구현하는 방안을 검토하라.
	- e.g. 주어진 집합의 멱집합을 반환하는 경우

> [!warning] 주의사항 
> 단지 컬렉션을 반환한다는 이유로 덩치 큰 시퀀스를 메모리에 올려서는 안 된다. 컬렉션을 반환할 수 없으면 스트림과 Iterable 중 더 자연스러운 것을 반환하라.

> [!important] 핵심 정리 
> 원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하기를 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 떠올리자. 양쪽을 다 만족시키려 노력하자.

---
### Item 48. 스트림 병렬화는 주의해서 적용하라

자바로 동시성 프로그래밍을 할 때 주의사항이 늘 따라다니듯, **병렬 스트림을 사용할 때도 주의사항**이 따라다닌다.
##### 병렬화의 함정
- 데이터 소스가 `Stream.iterate`이거나 중간 연산으로 `limit`를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.
- `Stream.iterate`나 `limit`를 쓴 파이프라인을 병렬화하면 CPU 코어가 남아돌아도 성능이 늘지 않는다.
##### 병렬화에 적합한 스트림 소스들
스트림의 소스가 다음과 같을 때 병렬화의 효과가 가장 좋다:
- `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스
- 배열, `int` 범위, `long` 범위
**이유:**
1. **데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있다** - 일을 다수의 스레드에 분배하기 좋다
2. **참조 지역성(locality of reference)이 뛰어나다** - 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있다

> [!question] 참조 지역성이란? 
> 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있다는 뜻이다. 참조들이 가리키는 실제 객체가 메모리에서 서로 떨어져 있을 수 있는데, 그러면 참조 지역성이 나빠진다. 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 대부분 시간을 멍하니 보내게 된다.
##### 병렬화가 효과적인 종단 연산
- **축소(reduction)**: `reduce` 메서드 중 하나, 혹은 `min`, `max`, `count`, `sum` 같이 완성된 형태로 제공되는 메서드
- **조건부 단락 연산**: `anyMatch`, `allMatch`, `noneMatch`처럼 조건에 맞으면 바로 반환되는 메서드
- [c] **가변 축소(mutable reduction)**: `collect` 메서드는 병렬화에 적합하지 않다 
	- 컬렉션들을 합치는 부담이 크기 때문
##### 직접 구현한 Stream, Iterable, Collection
- `spliterator` 메서드를 재정의하고 결과 스트림의 병렬화 성능을 강도 높게 테스트하는 것도 좋으나..
- 고효율 `spliterator`를 작성하기는 상당한 난이도를 요구한다.
##### 성능 측정이 필수
- 스트림을 잘못 병렬화하면 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.
- 결과가 잘못되거나 오동작하는 것은 **안전 실패(safety failure)** 라 한다.
- 안전 실패는 병렬화한 파이프라인이 사용하는 mappers, filters, 혹은 프로그래머가 제공한 다른 함수 객체가 명세대로 동작하지 않을 때 벌어질 수 있다.
##### 따라서.. 조건을 모두 만족할 때만 병렬화하라
1. 스트림의 소스가 효율적으로 나뉘고
2. 병렬화하기에 적합한 종단 연산을 사용하고
3. 함수 객체들도 간섭하지 않더라도
- **파이프라인이 수행하는 진짜 작업이 병렬화에 드는 추가 비용을 상쇄하지 못한다면 성능 향상은 미미할 수 있다.**

> [!tip] 추정하는 방법 
> 스트림 안의 원소 수와 원소당 수행되는 코드 줄 수를 곱해보자. 이 값이 최소 수십만은 되어야 성능 향상을 맛볼 수 있다.

- 스트림 병렬화는 오직 **성능 최적화 수단**임을 기억하자.
- 다른 최적화와 마찬가지로 변경 전후로 반드시 성능을 측정하여 병렬화를 사용할 가치가 있는지 확인해야 한다.

> [!important] 핵심 정리 
> 계산도 올바르게 수행하고 성능도 빨라질 거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말라. 스트림을 잘못 병렬화하면 프로그램을 오동작하게 하거나 성능을 급격히 떨어뜨린다. 병렬화하는 편이 낫다고 믿더라도, 수정 후의 코드가 여전히 정확한지 확인하고 운영 환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하라.

