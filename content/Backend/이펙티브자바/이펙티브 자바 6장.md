```table-of-contents
```
### 아이템 34 : int 상수 대신 열거 타입을 사용하라
```java
public static final int APPLE_FUJI = 0; 
public static final int APPLE_PIPPIN = 1; 
public static final int APPLE_GRAMMY_SMITH = 2; 
public static final int ORANGE_NAVEL = 0; 
public static final int ORANGEJBIPLE = 1; 
public static final int ORANGE_BLOOD = 2;
```
- 정수 열거 패턴의 문제점(과거 방식)
	- 타입 안전하지 않음: 사과 enum 자리에 오렌지가 들어가도 컴파일 에러 없음
	- 이름 공간 없음 → 접두어로 구분 (e.g., APPLE_, ORANGE_)
	- 정수 값이 하드코딩되어 클라이언트에 박힘 → 값 변경 시 클라이언트 재컴파일 필요
	- 순회 불가, 상수 개수 확인 불가, 디버깅 불편
	- 문자열 열거 패턴은 오타·성능 이슈 발생
- 자바의 열거 타입(enum type)
	- 각 enum 값은 클래스 인스턴스이며, `public static final` 필드로 제공됨
	- 외부에서 생성 불가 → 인스턴스 통제 (싱글턴의 일반화)
	- **타입 안전성 보장**: 잘못된 enum 전달 시 컴파일 에러
	- **고유 이름 공간 제공**: 이름 충돌 걱정 없음
	- **toString() 기본 제공** → 출력 용이
	- **열거 상수는 values() 배열로 순회 가능**
```java
public enum Planet {
    EARTH(5.975e+24, 6.378e6);
    private final double mass;
    private final double radius;
    private final double surfaceGravity;
    private static final double G = 6.67300E-11;

    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        this.surfaceGravity = G * mass / (radius * radius);
    }

    public double surfaceWeight(double mass) {
        return mass * surfaceGravity;
    }
}

```
- 열거 타입은 클래스이므로 필드/메서드 추가 가능
	- 각 enum 상수마다 **고유 데이터와 메서드 포함 가능**
	- 필드는 보통 `private final`로 선언 → 불변 보장
	- 생성자는 `private`이며 enum 선언부에 인수로 전달
```java
public enum Operation { 
	PLUS {publicdouble apply(double x, double y){return x + y;}}, 
	MINUS {publicdouble apply(double x, double y){return x - y;}}, 
	TIMES {publicdouble apply(double x, double y){return x *y;}}, 
	DIVIDE{public double apply(double x, double y){return x /y;}}; 
	
	public abstract double apply(double x, double y); 
}
```
- 상수별 메서드 구현(constant-specific method)
	- switch 문 대신 **enum 상수마다 동작 정의**
	- 추상 메서드를 반드시 구현해야 하므로, **누락 시 컴파일 에러 발생** → 안전
```java
public enum Operation { 
PLUS("+") { public double apply(double x, double y) { return x + y; } }, 
MINUS{ public double apply(double xf double y) { return x - y; } }, 
TIMES("*") { public double apply(double x, double y) { return x * y; }, 
DIVIDE{ public double apply(double x, double y) { return x / y; } }； 

private final String symbol; 

Operation(String symbol) { this.symbol = symbol; } 

@Override public String toString() { return symbol; } 
public abstract double apply(double x, double y); 
}
```
- 상수별 클래스 몸체(class body)와 데이터를 사용한 열거 타입
	- `toString()` 재정의로 출력 포맷 개선
	- 문자열 기호 → `Map<String, Operation>`으로 매핑하는 `fromString()` 메서드 구현 가능
```java
enum PayrollDay {
    MONDAY(WEEKDAY), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY), 
    THURSDAY(WEEKDAY), FRIDAY(WEEKDAY), 
    SATURDAY(WEEKBJD), SUNDAY(WEEKEND)；
    
    private final PayType payType;
    
    PayrollDay(PayType payType) { this.payType = payType; }

    int pay(int minsWorked, int payRate) {
        return payType.pay(minsWorked, payRate);
    }

    private enum PayType {
        WEEKDAY {
            int overtimePay(int mins, int rate) {
                return mins <= MINS_PER_SHIFT ? 0 : (mins - MINS_PER_SHIFT) * rate / 2;
            }
        },
        WEEKEND {
            int overtimePay(int mins, int rate) {
                return mins * rate / 2;
            }
        };

        private static final int MINS_PER_SHIFT = 8 * 60;

        int pay(int minsWorked, int payRate) {
            int basePay = minsWorked * payRate;
            return basePay + overtimePay(minsWorked, payRate);
        }

        abstract int overtimePay(int mins, int payRate);
    }
}

```
- 전략 열거 타입 패턴
	- 각 상수가 전략(enum PayType)을 선택 → switch 문 없이 상수별 로직 분리 가능
	- 안전하고 가독성 높음
- switch문은 열거 타입의 상수별 동작을 구현하는 데 적합하지 않지만 기존 열거 타입에 상수별 동작을 혼합해 넣을 때는 switch 문이 좋은 선택이 될 수 있음
	ex) 서드파티에서 가져온 Operation 열거 타입이 있는데, 각 연산의 반대 연산을 반환하는 메서드가 필요한 경우
```java
public static Operation inverse(Operation op) { 
	switch(op) { 
		case PLUS: return Operation.MINUS; 
		case MINUS: return Operation.PLUS; 
		case TIMES: return Operation.DIVIDE; 
		case DIVIDE: return Operation.TIMES; 
		default: throw new AssertionError("알 수 없는 연산: " + op); 
	} 
}
```
- valueOf vs fromString
	- `valueOf(String)` → 기본 제공되며 enum 이름 기준
	- `fromString(String)` → `toString()` 재정의 시 필요. Optional로 감싸면 안전
- 기타사항
	- switch 문은 **enum 외부 기능 추가 시 유용**
	- enum은 정수보다 메모리 사용량과 초기화 비용이 약간 더 크지만 무시해도 될 수준
	- 열거 타입은 **정적 상수 집합을 표현할 때 항상 우선 사용**할 것
	    - 사계절, 요일, 연산 종류, 메뉴 항목 등
### 아이템 35 : ordinal 메서드 대신 인스턴스 필드를 사용하라
- 대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응됨
- 모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공
	-> 열거 타입 상수와 연결된 정수값이 필요하면 ordinal 메서드를 이용하고 싶어짐
```java
/* ordinal을 잘못 사용한 예 */
public enum Ensemble {
	SOLO, DUET, TRIO, QUARTET, QUINTET,
	SEXTET, SEPTET, OCTET, NONET, DECTET;

	public int numberOfMusicians() { return ordinal() + 1; }
}
```
- ordinal() 사용의 문제점
	- 상수 선언 순서를 바꾸면 numberOfMusicians가 오동작
	- 이미 사용 중인 정수값과 같은 상수 추가 불가능
		-> 8중주(octet) 상수가 이미 있으니 똑같이 8명이 연주하는 복4중주(double quartet)는 추가할 수 없음
	- 값을 중간에 비워둘 수 없음
		-> 더미 상수를 추가해야 하는 상황이 발생하여 코드가 깔끔하지 못함
- 해결책 -> **열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고, 인스턴스 필드에 저장하자**
	- Enum API 문서의 ordinal 설명
		: 대부분 프로그래머 는 이 메서드를 쓸 일이 없다. 이 메서드는 EnumSet과 EnumMap 같이 열거 타입 기반의 범용 자료구조에 쓸 목적으로 설계되었다.
		-> 이런 용도가 아니라면 ordinal 메서드는 사용하지 말자
### 아이템 36 : 비트 필드 대신 EnumSet을 사용하라
- 열거한 값들이 주로 단독이 아닌 집합으로 사용될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴(아이템 34)을 사용
```java
public class Text { 
	public static final int STYLE_BOLD = 1 « 0; // 1 
	public static final int STYLE_ITALIC = 1 « 1; // 2 
	public static final int STYLE_UNDERLINE = 1 « 2; // 4 
	public static final int STYLE_STRIKETHROUGH = 1 « 3; // 8 
	
	// 매개변수 styles는 0개 이상의 STYLE, 상수를 비트별 OR한 값이다. 
	public void applyStyles（int styles） { ... } 
}
```
- 비트 필드(위의 방식)
	- 여러 상수를 비트 OR로 조합하여 하나의 집합으로 표현하는 방식
	- "비트 필드(bit field)" 기법으로 불림
		-> `text.applyStyles（STYLE_BOLD | STYLE_ITALIC）;`
	- 비트 필드를 사용하면 비트별 연산을 사용해 합집합과 교집합 같은 집합 연산을 효율적으로 수행 가능
	- 단점
		- - **타입 안전성 없음**: 정수 열거 상수와 같은 문제 (잘못된 상수 조합 가능)
		- **출력·디버깅 어려움**: 값이 정수로만 보임
		- **집합 순회 어려움**
		- 비트 수 제한 존재: `int`(32비트), `long`(64비트)  
		    → 상수 추가 시 API 수정 필요
- 대안 -> java.util 패키지으 EnumSet 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해줌
	- **타입 안전한 Set** 구현체
	- **내부적으로는 비트 벡터**로 동작 (64개 이하 열거 상수는 `long` 하나로 표현)
	- **고속 연산** 지원 (removeAll, retainAll 등) 
```java
public class Text {
    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }

    public void applyStyles(Set<Style> styles) { ... }
}

/* 사용 예시 */
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
```
- 사용 예시
	- `EnumSet.of(...)`로 여러 상수 집합 생성
	- 메서드는 `EnumSet<Style>`이 아닌 `Set<Style>`을 인자로 받음  
	    → 인터페이스 사용 원칙 (아이템 64)
- 장점 요약
	- **비트 필드 수준의 성능**
	- **Set 인터페이스 완전 지원**
	- **표현력 높고 안전**
	- **상수 추가 시 유연성 보장**

### 