```table-of-contents
```
## 아이템55. 옵셔널 반환은 신중히 하라
- 자바 8 전에는 메서드가 특정 조건에서 값을 반환할 수 없을 때 취할 수 있는 선택지가 두 가지 있었다.
	1. 예외를 던진다.
	2. (반환 타입이 객체 참조라면) null을 반환한다.
	-> 두 방법 모두 허점이 있음
	 : 예외는 진짜 예외적인 상황에 사용해야 하며, 예외를 생성할 때 스택 추적 전체를 캡쳐하므로 비용도 만만치 않음
	 null을 반환하면 이런 문제가 생기지 않지만, 이것 나름의 문제가 있음
> [!note] 예외 던지는 방식의 문제
> 1. 비용(성능 저하)
> 	- 예외를 생성하면 내부적으로 스택 트레이스(Stack Trace)를 캡처하게 되는데, 이는 꽤 무거운 연산에 해당
> 	- 즉, 예외가 자주 발생하면 애플리케이션 성능이 심각하게 저하될 수 있음
> 	  : 예외를 '정상적인 흐름의 일부'로 사용하면 안되는 이유
> 2. 가독성 저하
> 	- try-catch 블록이 남용되면 코드가 장황하고 읽기 어려워짐.
> 	- 특히, 단순히 '결과가 없음'을 표현하고 싶은 상황에서 예외를 사용하는 것은 과도함
> 3. 예외는 진짜 예외적인 상황에 사용해야 함
> 	- 예: 서버 장애, 파일이 물리적으로 없음, 데이터가 부정확함 등
> 	- 단순히 '조회 결과 없음' 같은 건 예외로 취급할 일이 아님

> [!note] NULL을 반환하는 방식의 문제점
> 1. NullPointerException의 위험
> 	- 메서드를 사용하는 쪽에서 null 체크를 하지 않으면 바로 NPE 
> 2. 호출자가 방어적 코드를 추가해야 함
> 	- 호출하는 쪽에서 항상 null 여부를 확인하는 코드를 추가해야 함
> 3. 명확하지 않은 의도
> 	- 메서드가 null을 반환할 수 있다는 걸 문서나 주석을 보지 않으면 직관적으로 알기 어려움
> 	- 실수로 null 반환을 예상하지 못하고 사용하면 버그로 이어지기 쉬움

- 자바 버전이 8로 올라가면서 Optional< T >라는 선택지가 생김
	-> null이 아닌 T 타입 참조를 하나 담거나(비었다), 혹은 아무것도 담지 않을 수 있음(비지 않았다)
- 옵셔널은 원소를 최대 1개 가질 수 있는 '불변' 컬렉션
	-> Collection< T > 를 구현하지는 않았지만, 원칙적으로 그렇다는 뜻
- T를 반환해야 하지만 특정 조건에서는 아무것도 반환하지 않아야 할 때 Optional< T > 를 반환하도록 선언
	-> 예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null을 반환하는 메서드보다 오류 가능성이 작음
- 예시 보면 최대값을 구하는 메서드인데 빈 컬렉션을 주면 IllegalArgumentException을 던짐
	-> 옵셔널을 반환하도록 수정(적절한 정적 팩터리를 사용해 옵셔널을 생성해주기만 하면 됨)
- Optional.of(value)에서 value에 null을 넣으면 NPE를 던짐
- **옵셔널을 반환하는 메서드에서는 절대 null을 반환하지 말자**
	-> 옵셔널을 도입한 취지를 완전히 무시하는 행위
##### 옵셔널 반환을 선택하는 기준
- 옵셔널은 검사 예외와 취지가 비슷(아이템 71)
	-> 반환값이 없을 수도 있음을 API 사용자에게 명확히 알려줌
		=> 비검사 예외를 던지거나 null을 반환한다면 API 사용자가 이를 인지하지 못해 큰 문제가 될 수 있음. 하지만 검사 예외를 던지면 클라이언트에서는 반드시 이에 대처하는 코드를 작성해야 함. 마찬가지로, 메서드가 옵셔널을 반환한다면 클라이언트는 값을 받지 못했을 때 취할 행동을 선택해야 함
##### 옵셔널 활용
1. 기본값을 정해둘 수 있음
	```java
String lastWordInLexicon = max(words).orElse("단어 없음...");
	```
2. 원하는 예외를 던질 수 있음
```java
Toy myToy = max(toys).orElseThrow(TemperTantrumException::new);
```
3. 항상 값이 채워져 있다고 가정함
	: 이를 확신한다면 곧바로 값을 꺼내 사용할 수 있지만 잘못 판단한 것이라면 NoSuchElementException이 발생
```java
Element lastNobelGas = max(Elements.NOBLE_GASES).get();
```

- 기본값을 설정하는 비용이 커서 부담되는 경우에는 Supplier< T >를 인수로 받는 orElseGet을 사용하면, 값이 처음 필요할 때 Supplier< T > 를 사용해 생성하므로 초기 설정 비용을 낮출 수 있음
```java
String result = optionalValue.orElseGet(() -> getExpensiveDefault());
```
- filter, map, flatMap, ifPresent 등 더 특별한 쓰임에 대비한 메서드도 있지만 이건 따로 찾아보시길..
##### 반환값으로 옵셔널을 사용한다고 해서 무조건 득이 되는 건 아님
- 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안됨
	ex) 빈 Optional<List< T >>를 반환하기보다는 빈 List< T > 를 반환하는 것이 좋음
		-> 빈 컨테이너를 그대로 반환하면 클라이언트에 옵셔널 처리 코드를 넣지 않아도 됨
- 결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 Optional< T >를 반환
- Optional도 엄연히 새로 할당하고 초기화해야 하는 객체이고, 그 안에서 값을 꺼내려면 메서드를 호출해야 하니 한 단계를 더 거치는 셈
	-> 성능이 중요한 상황에서는 맞지 않을 수 있음
	-> 이런 이유로 자바 API 설계자는 int, long, double 전용 옵셔널 클래스들을 준비함
     (OpionalInt, OptionalLong, OptionalDouble : Optional< T >가 제공하는 메서드 거의 다 제공)
	 -> 박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없도록 하자...
- 옵셔널은 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없음
- 클래스의 필드 중에 필수가 아닌 값들은 옵셔널로 선언하는 방법도 있음
##### 정리
- 값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메서드라면 옵셔널을 반환해야 할 상황일 수 있다. 하지만 옵셔널 반환에는 성능 저하가 뒤따르니, 성능에 민감한 메서드라면 null을 반환하거나 예외를 던지는 편이 나을 수 있다. 그리고 옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드물다.

## 아이템 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라
- API를 쓸모 있게 하려면 잘 작성된 문서도 필요
- 전통적으로는 API 문서는 사람이 직접 작성해서 코드 변경 시 매번 수정해야 했는데, 자바에서는 자바독(Javadoc)이라는 유틸리티가 이 작업을 도와줌
	-> 자바독은 소스코드 파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API 문서로 변환해줌
##### API를 올바르게 문서화하려면 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 함
  (직렬화 할 수 있으면 클래스라면 직렬화 형태에 관해서도 적어야 함)
- 문서화 주석이 없다면 자바독도 그저 공개 API 요소들의 '선언'만 나열해주는 것이 전부
- 기본 생성자에는 문서화 주석을 달 방법이 없기 때문에 공개 클래스는 절대 기본 생성자를 사용하면 안됨
	-> 유지보수를 고려하면 공개되지 않은 것들에도 문서화 주석을 달아주는 것이 좋음(간단하게라도)
##### 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 함
- 상속용으로 설계된 클래스의 메서드가 아니라면 무엇을 하는지를 기술해야 함
  (HOW가 아닌 WHAT)
- 문서화 주석에는 클라이언트가 해당 메서드를 호출하기 위한 전제조건(precondition)을 모두 나열해야 하며, 성공적으로 수행된 후에 만족해야 하는 사후조건(postcondition)도 모두 나열해야 함
  (부작용에 대해서도 문서화해야 함)

- 처음 부분에서 설명한 것을 적용한 예시
```java
/** * 이 리스트에서 지정한 위치의 원소륧 반환한다. 
* 
* 이 메서드는 상수 시간에 수행됨을 보장하지 _않는다_. 구현에 따라 
* 원소의 위치에 비례해 시간이 걸릴 수도 있다. 
* 
* @param index 반환할 원소의 인덱스; 0 이상이고 리스트 크기보다 작아야 한다. 
* @return 이 리스트에서 지정한 위치의 원소 水 @throws IndexOutOfBoundsException index가 범위를 벗어나면, 
* 즉, ({@code index < 0 11 index >= this.sizef)})이면 발생한다. 
*/ 
E get(int index);
```

- 한 클래스(혹은 인터페이스) 안에서 요약 설명이 똑같은 멤버(혹은 생성자)가 둘 이상이면 안 된다.
- 제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다.
- 열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.
- 애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다.
- 클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API 설명에 포함해야 한다.
- 만들어진 문서가 잘 쓰인 문서인지 확인하는 유일한 방법은 자바독 유틸리티가 생성한 웹페이지를 읽어보는 길 뿐
- 일단 중요한 문장들만 나열해뒀는데 결국 쭉 읽어보고 위에서 언급한 대로 문서를 찾아서 보는것이 좋을듯
