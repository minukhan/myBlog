```table-of-contents
```
## 아이템 57. 지역변수의 범위를 최소화하라
- 지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.
- 지역변수의 범위를 줄이는 가장 강력한 기법 : 가장 처음 쓰일 때 선언하기
	-> 미리 선언부터 해두면 코드가 가독성이 떨어질 수 있음
- 거의 모든 지역변수는 선언과 동시에 초기화해야 한다
	-> 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미룬다.
	-> try-catch문은 이 규칙에서 예외
	 : 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화
- 반복문에서는 반복 변수의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한됨
	-> 반복 변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 while문보다는 for문을 쓰는 편이 낫다.
	(while문보다 짧아서 가독성이 좋기도 함)
- 마지막으로 메서드를 작게 유지하고 한 가지 기능에 집중하는 방법이 있다.
	-> 단순히 메서드를 기능별로 쪼개면 된다.

## 아이템 58. 전통적인 for문보다는 for-each문을 사용하라
- 기존의 Iterator 및 for문의 경우 while문보다는 낫지만 반복자와 인덱스 변수는 모두 코드를 지저분하게 하고 이렇게 쓰이는 요소들이 늘어나면 오류가 생길 가능성이 높아짐
  (이뿐만 아니라 다양한 문제가 있음)
- 위의 문제는 for-each문을 사용하면 모두 해결됨
  (정식 이름은 '향상된 for 문(enhanced for statement))'이다.)
	1. 반복자와 인덱스 변수를 사용하지 않아 코드가 깔끔해지고 오류가 확률이 낮아짐
	2. 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지는 신경쓰지 않아도 됨
- : 은 "안의(in)"라고 읽으면 됨
- 반복 대상이 컬렉션이든 배열이든 for-each 문을 사용해도 속도는 그대로
  (사람이 손으로 최적화한 것과 사실상 같음)
- 예시는 기존의 방식으로 구현했을 때 보기 좋지 않거나 오류가 발생하는 경우를 보여주고 여기에 for-each문을 중첩해서 적용하면 이런 문제들을 해결할 수 있다고 알려줌
- for-each문은 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있음
##### for-each문을 사용할 수 없는 상황
1. 파괴적인 필터링(destructive filtering) : 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다. 자바 8부터는 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있음
2. 변형(transforming) : 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.
3. 병렬 반복(parallel interation) : 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.
##### 정리
- 전통적인 for 문과 비교했을 때 for-each 문은 명료하고, 유연하고, 버그를 예방해준다. 성능 저하도 없다. 가능한 모든 곳에서 for 문이 아닌 for-each 문을 사용하자

## 라이브러리를 익히고 사용하라
##### 표준 라이브러리 사용의 이점
1. 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
	-> 자바 7부터는 Random을 사용하지 말고 ThreadLocalRandom으로 대체하면 대부분 잘 동작하고 더 고품질의 무작위 수를 생성하고 속도도 더 빠르다.
2. 표준 라이브러리를 사용하면 핵심적인 일과 크게 관련 없는 문제에 시간을 허비하지 않아도 된다.
3. 따로 노력하지 않아도 성능이 지속해서 개선된다.
4. 기능이 점점 많아진다.
5. 작성한 코드가 많은 사람들에게 낯익은 코드가 된다.
- 메이즈 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가됨
- 자바 프로그래머라면 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 함.
##### 정리
- 특별한 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크므로, 찾아보고 그런 라이브러리를 쓰면 된다.

## 아이템 60. 정확한 답이 필요하다면 float과 double은 피하라.
- float과 double 타입은 과학과 공학 계산용으로 설계되었다.
	-> 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 세심하게 설계됨
	=> 따라서 정확한 결과가 필요할 때는 사용하면 안 됨
	=> 특히, 금융 관련 계산과는 맞지 않음(0.1 혹은 10의 음의 거듭 제곱 수를 표현할 수 없음)
- 예시로 연산값이 이상하게 나오는게 나옴(여기선 어설픈 코드라고 지칭함)
- 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 함 -> 결과가 정상적으로 나옴
##### BigDecimal의 단점
- 기본 타입보다 훨씬 쓰기 불편하고, 느림(성능 저하)
##### 대안으로 int 혹은 long을 쓴다면?
- 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야 함(예시에서는 모든 계산을 달러 대신 센트로 수행)

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라.
- 기본 타입 : int, double, boolean 등
- 박싱된 기본 타입(기본 타입에 대응됨) : Integer, Double, Boolean 등
##### 차이점
1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 가짐
	-> 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있음
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있음
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.
-> 이런 차이에 주의하지 않고 사용하면 진짜로 문제가 발생할 수 있음

- 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어남
- 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀림
##### 박싱된 기본 타입은 언제 써야 하는가?
1. 컬렉션의 원소, 키, 값으로 쓴다.
	: 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야 함.
2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다.
3. 리플렉션을 통해 메서드를 호출할 떄도 박싱된 기본 타입을 사용해야 한다.
##### 정리
- 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라. 기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야 한다면 주의를 기울이자. 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다. 두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄지는 데, 이는 여러분이 원한 게 아닐 가능성이 크다. 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 NullPointerException을 던질 수 있다. 마지막으로, 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용 을 나을 수 있다.

## 아이템 62. 다른 타입이 적절하다면  문자열 사용을 피하라
- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
	-> 데이터가 진짜 문자열일 때만 문자열을 사용하는 것이 좋고 수치형이라면 int, float, BigInteger등 적당한 수치 타입으로 변환해야 함
- 문자열은 열거 타입을 대신하기에 적합하지 않다.
- 문자열은 혼합 타입을 대신하기에 적합하지 않다.
- 문자열은 권한을 표현하기에 적합하지 않다.
##### 정리
- 더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 싶은 유혹을 뿌리쳐라. 문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다. 문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.


## 아이템 63. 문자열 연결은 느리니 주의하라
- 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다.
	-> 문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로, 성능 저하는 피할 수 없음
- 성능을 포기하고 싶지 않다면 String 대신 StringBuilder를 사용
##### 정리
- 원칙은 간단하다. 성능에 신경 써야 한다면 많은 문자열을 연결할 때는 문자열 연결 연산 자(+)를 피하자. 대신 StringBuilder의 append 메서드를 사용하라. 문자 배열을 사용 하거나, 문자열을 (연결하지 않고) 하나씩 처리하는 방법도 있다.

## 아이템 64 객체는 인터페이스를 사용해 참조하라

- 아이템 51에서 매개변수 타입으로 클래스가 아니라 인터페이스를 사용하라고 함. 
- 이 조언을 더 나아가서 객체는 클래스가 아닌 인터페이스로 참조하라고 확장된다 함. 


> [!note] 핵심
> - **가능한 한 인터페이스를 타입으로 사용하라.**
> - 매개변수, 반환값, 지역변수, 필드 등 모든 곳에 적용.
> - **구현 클래스는 오직 객체를 생성할 때만 사용**하라.

```
// 좋은 예
Set<Son> sonSet = new LinkedHashSet<>();

// 나쁜 예
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

- LinkedHashSet 은 class, Set 은 인터페이스 

##### 왜 ? 인터페이스를 사용?

- 유연성 증가 
	- 구현체 교체가 쉬워진다. 
	- 다른 코드에 영향을 주지 않는다. 
- 캡슐화 향상
	- 사용자는 객체의 구제적인 구현을 몰라도 됨. 
	- 유지보수가 쉬워진다. 

##### 예외적으로 클래스 타입 사용을 허용한다!

- 값 클래스 (Value class)
	- String, BigInteger
	- 보통 final 이고 인터페이스가 없기때문
- 클래스 기반 프레임워크 객체.
	- OutputStream 등 추상클래스를 기반으로 한 구조
- 특정 기능이 필요한경우 
	- 예: `PriorityQueue`의 `comparator()`는 `Queue` 인터페이스에 없음.
	- 이럴 때에 클래스 타입을 사용하고 앵간하면 인터페이스 써라! 

## 아이템 65 리플렉션보다는 인터페이스를 사용하라 

> [!note] 핵심
> - 리플렉션(reflection) 은 필요한 경우에만 제한적으로 사용하라.
> - 객체 생성 이후에는 항상 인터페이스나 상위 클래스로 참조해라.
> 

##### 리플렉션을 왜 사용할까?

- 컴파일 시점에 알 수 없는 클래스, 메서드, 필드에도 런타임에 접근을 할 수 있음. 

##### 사용하면 생기는 문제? 

- 컴파일 타임 타입 안정성이 상실된다.
	- 당연히 컴파일 이후에 런타임에 접근하는데 여기서 
	- 존재하지 않는 메서드, 필드, 클래스를 참조하면 런타임 오류가 발생한다. 

- 복잡하고 코드가 장황해진다. 
	- 예외처리 및 접근 로직으로 코드가 길고 이해하기 어려워진다. 

- 성능 저하. 
	- 리플렉션을 통한 호출은 일반 메서드보다 훨씬 느리다. (테스트했을때 11배정도 느리다고 함. )

##### 그럼 어떻게 사용해?

- 정말 필요한 경우에만, 객체 생성에만 제한적으로 사용해라.
- 생성한 객체는 반드시 인터페이스나 상위 타입으로 참조해라. 

```
// 리플렉션으로 Set 인스턴스 생성, 이후에는 Set 인터페이스로 사용
Class<? extends Set<String>> cl = Class.forName(args[0]);
Constructor<? extends Set<String>> cons = cl.getDeclaredConstructor();
Set<String> set = cons.newInstance();  // 생성만 리플렉션 사용
set.add("hello");                      // 이후는 인터페이스로 처리
```


##### 정리 

- 리플렉션은 강력하지만 위험한 도구다. 
- 가능하면 사용하지말고 사용한다면 객체 생성에만 사용해라.
- 생성 후에는 적절한 인터페이스로 참조해라.
- 더 유연한 코드를 위해 리플렉션 대신 인터페이스 기반 설계를 우선고려 해라. 


## 아이템 66 네이티브 메서드는 신중시 사용하라

> [!note] 핵심
> - 자바 네이티브 인터페이스 (JNI) 를 사용할때는 정말 필요한 경우에만, 신중하게, 최소한으로 사용해라. 
> 

##### 네이티브 인터페이스가 뭐야?

- C, C++ 등 자바 외부 언어로 작성된 메서드를 자바에서 호출할 수 있게 해주는 기능을 말함.

##### 사용 목적이 뭔데?

- 플랫폼 특화 기능 사용
	- Windows 레지스트리, OS프로세스등 
- 레거시 네이티브 라이브러리 사용
	- 오래된 C 라이브러리, 기존 시스템과의 연동
- 성능 최적화
	- 자바보다 빠른 처리를 기대하고 특정 연산을 네이티브로 구현.
##### 근데 요즘은 이제 안써.. 

- 대부분의 필요한건 순수 자바로 대체 가능. 
	- 자바 표준 API 가 발전해서 다 커버 가능
	- JVM 의 성능 향상.
	- 순수 자바로 작성한 코드가 네이티브보다 더 빠르기도 한다.
		-  BigInteger 가 순수 자바 구현이 초기 네이티브 버전보다 빠르다고 함. 

##### 네이티브 메서드의 단점

- 안정성 저하 : 메모리 훼손될 수 있다함.
- 이식성 저하 : 플랫폼 의존적이므로 다른 OS에서 실행 불가능할 가능성이 높음
- 디버깅이 어려움 : 자바보다 디버깅 환경이 열악함.
- 관리복잡도 : 네이티브 메모리 관리를 직접해야한다함. 

##### 그러면 언제 사용해?

- 플랫폼 특화 기능이 필요할 때
- 자바에서 접근할 수 없는 기존 네이티브 라이브러리를 사용해야할 때 
- 자바로 도저히 성능이 안나올때
	- GMP 같은 고성능 수학연산같은것. 


##### 생각보다 성능 개선도 많이 안되고 만약 사용한다면 철저히 테스트 해야한다. 그래서 이것도 꼭 필요할때만 쓰고 앵간하면 쓰지마라 


## 아이템 67 최적화는 신중히 하라

> [!note] 핵심
> - 성능보다 구조가 먼저임을 잊지마라
> - 성능 최적화는 신중히, 그리고 반드시 측정과 함께 해라.
> 

#### 최적화에 대한 3가지 격언을 말한다.

- 효율성이라는 이름 아래 행해진 죄악이 가장 많다. 
- 조기 최적화는 만악의 근원이다.
- 최적화 규칙
	- 1. 하지마라
	- 2. (전문가 한정) 아직 하지마라

#### 잘못된 최적화는 심각한 오류를 발생시킴

- 구조 붕괴 : 성능을 위해 정보 은닉, 모듈성 등 좋은 설계 원칙을 희생
- 예측 실패 : 느릴 거라고 생각한 부분이 실제 병목이 아닐 수 있음
- 유지보수 악화 : 읽기 어려운 코드 + 변경하기 어려워짐
- 최적화 실패 : 실제로 성능이 개선되지 않거나 더 느려짐. 

#### 어떻게 해야 최적화를 올바르게 할까?

- 1. 설계단계
	- 성능 고려가 필수인 요소
		- API 설계, 네트워크 프로토콜, 데이터 포맷
- 2. 구현단계
	- 성능보다는 명확하고 깨끗한 구조에 집중해라. 
	- 좋은 아키텍처를 선택하면 최적화는 뒤에 따라온다. 
- 3. 완성후 
	- 프로그램이 느릴 때만 최적화를 고려해라. 

#### 반드시 측정 한 뒤에 최적화를 진행해라.

- 최적화 도구를 이용해서 성능을 비교
- 책에서는 프로파일러라는 도구를 이야기함.
- 추측 대신 데이터로 병목 구간을 정확하게 파악하고 시작해라.

#### 왜 측정을 해야해?

- 자바에서는 최적화가 더 어렵다고 한다. 
- 추상화 격차 : 자바 코드와 실제 CPU 실행 간의 거리가 크다고 함. 
- 플랫폼 다양성 : JVM, 하드웨어, 운영체제 등 변수가 많음
- 성능 미신 : JVM 동작 이해 부족으로 잘못된 최적화를 시도할 수 있음. 

-> 자바는 측정 없이는 예측도 하지 말아라!!!


#### 정리

- 좋은 구조를 설계하고 구현하면 성능은 따라온다.
- API, 데이터 포맷등은 설계때 성능을 고려 해라.
- 최적화는 필요할 때만, 반드시 측정하고 진행해라. 예측은 금지

## 아이템 68 일반적으로 통용되는 명명 규칙을 따르라 

> [!note] 정리 
> - 자바에서 통용되는 명명 규칙을 따르지 않으면 코드를 이해하기 힘듬
> - 사용과 유지보수가 어려워짐.


#### 철자 규칙

- 패키지, 모듈 
	- 모두 소문자, 점 '.' 으로 구분, 도메인은 역순으로
- 클래스/ 인터페이스
	- 단어마다 첫 글자 대문자 (UpperCamelCase)
- 메서드/ 필드 
	- 첫 단어 소문자, 이후 단어 시작은 대문자. (LowerCamelCase)
- 상수 필드 
	- 모두 대문자, 단어 사이는 밑줄
- 지역변수/ 매개변수
	- 소문자, 짧고 의미 유추 가능하게 
- 타입 매개변수 
	- 대문자 1~2자로

#### 문법 규칙 

- 클래스/ 인터페이스 : 명사, 형용사로!

| 용도              | 예시                                                     |
| --------------- | ------------------------------------------------------ |
| 생성 가능한 클래스      | **단수 명사/명사구**: `Thread`, `PriorityQueue`, `ChessPiece` |
| 유틸리티/정적 메서드 클래스 | **복수 명사**: `Collections`, `Collectors`                 |
| 인터페이스           | **명사/형용사**: `Collection`, `Runnable`, `Comparable`     |
| 애너테이션           | **자유로운 명명**: `Inject`, `Singleton`, `ImplementedBy`    |

- 메서드 이름 : 보통 동사로! 

|형태|용도|예시|
|---|---|---|
|동사 / 동사구|동작 수행|`append`, `drawImage`|
|`is` / `has` + 명사/형용사|boolean 반환|`isEmpty`, `isEnabled`, `hasSiblings`|
|명사 / 명사구|속성 조회|`size`, `hashCode`|
|`get` + 속성|자바빈즈 스타일|`getName`, `getTime`|
|`toType`|형 변환|`toString`, `toArray`|
|`asType`|뷰 반환|`asList`|
|`typeValue`|기본값 반환|`intValue`|
|정적 팩터리 메서드|다양함|`of`, `from`, `valueOf`, `getInstance`, `newType`|

- 필드 / 지역변수 
	- 보통 명사, 명사구로 표현한다. 
	- 지역변수는 좀 더 자유롭게, 문맥으로 의미 파악 가능하면 약어도 많이 사용한다. 
	- boolean 필드는 관련 메서드 이름에서 is 를 제거한 형태.


- 정리된 표

| 식별자 유형     | 규칙               | 예시                           |
| ---------- | ---------------- | ---------------------------- |
| 패키지/모듈     | 소문자 + 점으로 계층화    | `com.example.project.module` |
| 클래스/인터페이스  | UpperCamelCase   | `HashMap`, `HttpClient`      |
| 메서드/필드     | lowerCamelCase   | `getSize`, `ensureCapacity`  |
| 상수 필드      | UPPER_CASE + `_` | `MAX_VALUE`                  |
| 지역 변수/매개변수 | 소문자, 약어 허용       | `i`, `buf`, `userId`         |
| 타입 매개변수    | 대문자 1~2자         | `T`, `E`, `K`, `V`           |

#### 참고할만한 것

- IDE 자동 완성도 명명 규칙을 기반으로 작동하기에 일관된 명명규칙은 생산성과 연결됨
- 라이브러리 API 설계자는 더더욱 철저히 지켜야한다. 
- 모호하거나 헷갈릴 땐 상식을 따라야한다. 

#### 정리 

 - 철자 규칙은 무조껀 지켜야 직관적이고 명확하게 파악가능
 - 문법 규칙은 상황에 따라 유연하게 가능, 그러나 일관성을 유지해라. 