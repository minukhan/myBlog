## 제네릭

> [!error] 제네릭
> 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 된다. 그래서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여 더 안전하고 명확한 프로그램을 만들어 준다.

이번 장에서는 제네릭의 이점을 최대로 살리고 단점을 최소화하는 방법을 이야기한다.

---
### Item 26. 로 타입은 사용하지 말라

- **제네릭 클래스 / 제네릭 인터페이스** : 클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰이는 경우
	- e.g. `List` 인터페이스는 원소 타입을 나타내는 타입 매개변수 `E`를 받는다.
		- 따라서 이 인터페이스의 완전한 이름은 `List<E>`지만, 짧게 그냥 `List`라고도 쓴다.
- **제네릭 타입** : 제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입(generic type)이라 한다.
- 각각의 제네릭 타입은 **일련의 매개변수화 타입(parameterized type)을 정의**한다.
- 마지막으로 제네릭 타입을 하나 정의하면 **그에 딸린 로 타입(raw type)도 함께 정의**된다.
	- 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
	- 예컨대 `List<E>`의 로 타입은 `List`다.
	- 로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이라 할 수 있다.

- 로 타입(타입 매개변수가 없는 제네릭 타입)을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안된다.
	- **로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.**
	- [?] 그렇다면 절대 써서는 안되는 로 타입을 애초에 왜 만들어놓은 걸까?
		- 제네릭 없이 짠 기존 코드를 모두 수용하면서 제네릭을 사용하는 새로운 코드와도 맞물려 돌아가게 하기 위해 만들어둔 것이다.(호환성)
- `List`와 같은 로 타입은 사용해서는 안되나, **`List<Object>`처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.**
	- 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이지, 제네릭 타입에서 완전히 발을 뺀 것이 아니기 때문이다.
	- 제네릭의 하위 타입 규칙 때문에 매개변수로 `List`를 받는 메서드에 `List<String>`을 넘길 수는 있지만, `List<Object>`를 받는 메서드에는 넘길 수 없다.
		- 즉, `List<String>`은 로 타입인 `List`의 하위 타입이지만 `List<Object>`의 하위 타입은 아니다.
	- 그 결과 `List<Object>` 같은 매개변수화 타입을 사용할 때와 달리 **`List` 같은 로 타입을 사용하면 타입 안전성을 잃게 된다.**
- 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 **물음표(?)를 사용**하자.
	- 예컨대 제네릭 타입인 `Set<E>`의 비한정적 와일드카드 타입은 `Set<?>`이다.
	- 이것이 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 `Set` 타입이다.

- 로 타입을 쓰지 말라는 규칙에도 *소소한 예외*가 몇 가지 있다.
	1. class 리터럴에는 로 타입을 써야 한다.
		- `List.class`는 허용하지만, `List<?>.class`는 허용하지 않는다.
	2. 런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
```java
if(o instanceof Set<?>)
// 또는
if(o instanceof Set)
// 만 허용한다.
```
- 비한정적 와일드 카드 타입과 로 타입 모두 허용하지만, 비한정적 와일드카드 타입의 꺾쇠괄호와 물음표는 아무런 역할 없이 코드만 지저분하게 만드므로, **차라리 로 타입을 쓰는 편이 깔끔하다.**

###### 5장 전반에서 사용할 용어 정리
| **한글 용어**     | **영문 용어**               | **예**                              | **아이템**     |
| ------------- | ----------------------- | ---------------------------------- | ----------- |
| 매개변수화 타입      | parameterized type      | `List<String>`                     | Item 26     |
| 실제 타입 매개변수    | actual type parameter   | `String`                           | Item 26     |
| 제네릭 타입        | generic type            | `List<E>`                          | Item 26, 29 |
| 정규 타입 매개변수    | formal type parameter   | `E`                                | Item 26     |
| 비한정적 와일드카드 타입 | unbounded wildcard type | `List<?>`                          | Item 26     |
| 로 타입          | raw type                | `List`                             | Item 26     |
| 한정적 타입 매개변수   | bounded type parameter  | `<E extends Number>`               | Item 29     |
| 재귀적 타입 한정     | recursive type bound    | `<T extends Comparable<T>>`        | Item 30     |
| 한정적 와일드카드 타입  | bounded wildcard type   | `List<? extends Number>`           | Item 31     |
| 제네릭 메서드       | generic method          | `static <E> List<E> asList(E[] a)` | Item 30     |
| 타입 토큰         | type token              | `String.class`                     | Item 33     |

---
### Item 27. 비검사 경고를 제거하라

- 제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 될 것이다.
	- 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매게변수화 가변인수 타입 경고, 비검사 변환 경고 등이다.

- [9] 할 수 있는 한 **모든 비검사 경고를 제거**해야 한다.
	- 모두 제거한다면 그 코드는 타입 안정성이 보장된다.
	- 런타임에 `ClassCastException`이 발생할 일이 없고, 의도한 대로 잘 동작하리라 확신할 수 있다.
- **대부분의 비검사 경고는 쉽게 제거할 수 있다.**
	- javac 명령줄 인수에 `-Xlint:uncheck` 옵션을 추가하면, 컴파일러가 무엇이 잘못됐는지 친절히 설명해준다.
- **제거하기 훨씬 어려운 경고도 있다.** 이번 장(5장)은 그러한 경고를 내는 예제들로 채워져 있다.
- 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 `@SuppressWarnings("unchecked")` 어노테이션을 달아 경고를 숨기자.
	- 타입 안전함을 검증하지 않은 채 경고를 숨기면 안된다.
	- `@SuppressWarnings` 어노테이션은 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있으나, **항상 가능한 한 좁은 범위에 적용**하자.
	- `@SuppressWarnings("unchecked")` 어노테이션을 사용할 때면 그 경고를 **무시해도 안전한 이유를 항상 주석으로 남겨야 한다.**

---