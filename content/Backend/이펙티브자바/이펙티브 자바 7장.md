
### 아이템 42 : 익명 클래스보다는 람다를 사용하라

람다 이전에는 익명클래스를 사용해서 인스턴스에 함수 객체를 넣어 사용하는 방법으로 많이 사용했었음

익명 클래스
```
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});

```

치명적인 단점 -> 코드가 너무 길고 복잡해보임, 가독성 떨어짐

그래서 나온게 람다 표현식 (Java 8부터)

```
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

장점 
- 코드가 훨씬 짧고 읽기 쉽다
- 타입도 컴파일러가 대부분 **자동 추론**해준다

>[!important] 주의할점
>- **제네릭 타입**이 명확해야 컴파일러가 람다의 타입을 제대로 추론할 수 있음
>- **로 타입(raw type)을 쓰면 추론이 깨짐**
    
##### 개선된 Enum Operation

```
public enum Operation {
    PLUS("+", (x, y) -> x + y),
    MINUS("-", (x, y) -> x - y),
    TIMES("*", (x, y) -> x * y),
    DIVIDE("/", (x, y) -> x / y);

    private final String symbol;
    private final DoubleBinaryOperator op;

    Operation(String symbol, DoubleBinaryOperator op) {
        this.symbol = symbol;
        this.op = op;
    }

    public double apply(double x, double y) {
        return op.applyAsDouble(x, y);
    }

    @Override
    public String toString() {
        return symbol;
    }
}

```
이전에 비하면 확실히 가독성 좋은걸 볼 수 있음 


람다 표현식의 한계가 있음

1. **설명이 필요한 복잡한 코드** → 람다는 부적합
    - 람다는 **짧고 단순한 표현**에 적합 (3줄 이내 권장)
2. **람다는 자신을 참조할 수 없음**
    - `this`는 바깥 클래스 인스턴스를 가리킴
    - 익명 클래스에서는 `this`가 자기 자신을 가리킴
3. **람다는 인스턴스 필드에 접근 불가**
    - 생성자에서 넘겨진 람다는 아직 인스턴스가 생성되지 않았기 때문
4. **람다/익명 클래스는 직렬화하기 부적절**
    - 구현마다 직렬화 형태가 다름 → 직렬화하려면 **private static nested class** 사용


>[!note] 42 핵심정리
>자바가 8로 판올림되면서 작은 함수 객체를 구현하는 데 적합한 람다가 도입되었다. 익 명 클래스는 （함수형 인터페이스가 아닌） 타입의 인스턴스를 만들 때만 사용하라. 람다 는 작은 함수 객체를 아주 쉽게 표현할 수 있어 （이전 자바에서는 실용적이지 않던） 함수 형 프로그래밍의 지평을 열었다.


### 아이템 43 : 람다보다는 메서드 참조를 사용하라

람다가 익명 클래스보다 나은 점 중에서 가장 큰 특징은 간결함이다. 
-> 그런데 자바에는 함수 객체를 심지어 람다보다도 더 간결하게 만드는 방법이 있음
-> 바로 메서드 참조(method reference)다.

메서드 참조 = 더 간단하고 읽기 쉬운 람다 표현

```
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println(name));
```

```
names.forEach(System.out::println);
```

참조를 사용하는 편이 보통은 더 짧고 간결하므로, 람다로 구현했을 때 너무 길거나 복잡하다면 메서드 참조가 좋은 대안이 되어준다


###### 람다가 메서드 참조보다 더 나은 경우

> 어떤 람다에서는 **매개변수의 이름 자체**가 의미를 전달해줘서 **람다가 메서드 참조보다 더 읽기 쉽다**.

```
map.merge(key, 1, (count, incr) -> count + incr);  // 람다: 이름이 의미 있음
map.merge(key, 1, Integer::sum);                   // 메서드 참조: 더 짧지만 이름 없음
```

첫 번째는 **count**, **incr**라는 이름으로 뭘 더하는지 명확히 보임
두 번째는 짧지만, **sum이 무엇을 더하는지 코드를 모르면 감이 안 올 수 있다.

>[!note] 43 핵심정리
>메서드 참조는 람다의 간단명료한 대안이 될 수 있다. 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.


### 아이템 44 : 표준 함수형 인터페이스를 사용하라


과거 : 템플릿 메서드 패턴
- 옛날엔 상속해서 어떤 **기본 메서드**를 오버라이드(재정의)하는 방식으로 동작을 바꿨음.

현대적 방식: **함수 객체 (람다)를 인자로 받는 생성자 또는 팩터리 메서드**
- 상속 대신, 함수형 인터페이스를 인자로 넘겨서 원하는 동작을 정의함.
- 그래서 요즘은 **람다**를 인자로 받는 API를 만드는 게 더 모던한 방식.

책에서는 이런 함수를 위해 아래와 같은 **커스텀 인터페이스**를 만든 예시를 보여준다 한번 읽어보면 좋을듯.

```
@FunctionalInterface
interface EldestEntryRemovalFunction<K, V> {
    boolean remove(Map<K,V> map, Map.Entry<K,V> eldest);
}
```

하지만 이런건 굳이 우리가 만들 필요가 없음. 

이미 자바에서는 이런 걸 위해 이미 표준 인터페이스들을 제공하고 있다. 그거 그냥 가져다가 쓰라고 함.
**직접 함수형 인터페이스 만들지 말고**, `java.util.function`에 있는 걸 쓰자!

그러면서 근데 정의해야할 때가 있긴하다고 소개함

##### 표준 함수형 인터페이스로 부족할 때 정의해서 사용하기

| 상황             | 예시                                                                     |
| -------------- | ---------------------------------------------------------------------- |
| 매개변수 3개 이상     | `TriFunction<T,U,V,R>` (직접 만들어야 함)                                     |
| 예외를 던지는 함수     | `ThrowingFunction<T,R>` 같은 커스텀 필요                                      |
| 규약이 있는 경우      | `Comparator<T>`처럼 별도 인터페이스 필요                                          |
| API 표현력이 중요할 때 | `Comparator`는 `ToIntBiFunction`으로 대체할 수 있지만 의미와 규약, 조합 메서드 때문에 별도로 유지됨 |

##### Comparator는 왜 따로 존재할까?

- 자주 보아온 Comparator 인터페이스를 떠올려보자. 구조적으로는 기존에 있는 인터페이스로 사용할 수 있는데 왜 굳이 따로 만들어서 살아남아있을까? 라고 의문을 던짐

첫번째 이유 : API에서 굉장히 자주 사용되는데, 지금의 이름이 그 용도를 아주 훌륭히 설명해주기 때문
두번째 이유 : 구현하는 쪽에서 반드시 지켜야 할 규약을 담고 있기 때문 
세번째 이유 : 비교자들을 변환하고 조합해주는 유용한 디폴트 메서드들을 듬뿍 담고 있기 때문

>[!note] 44 핵심정리
>여러분도 지금부터는 API를 설계할 때 람다도 염두에 두 어야 한다는 뜻이다. 입력값과 반환값에 함수형 인터페이스 타입을 활용하라. 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선 택이다. 단, 흔치는 않지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 수 도 있음을 잊지 말자


### 아이템 45 : 스트림은 주의해서 사용하라

##### 스트림(Stream)이란?
- 데이터 원소의 **유한 또는 무한 시퀀스(연속된 흐름)**.
- 데이터 출처: **컬렉션, 배열, 파일, 정규표현식, 난수 생성기 등**.

### 스트림 파이프라인(Stream Pipeline)

- 스트림 연산의 조합을 뜻하며, 3단계로 구성됨:

| 단계        | 설명                                                      |
| --------- | ------------------------------------------------------- |
| **소스**    | 스트림을 만드는 출발점 (예: `List.stream()` 등)                     |
| **중간 연산** | 원소들을 가공/필터링 (`map`, `filter`, `sorted`, `distinct`, 등)  |
| **종단 연산** | 최종 결과 도출 (`collect`, `forEach`, `count`, `anyMatch`, 등) |
중간연산은 종단 연산이 실행될 때까지 실제 작업은 수행되지 않음.
**종단 연산이 없으면 아무 일도 일어나지 않는다**.


책에서는 철자는 같지만 **순서만 다른 단어**(아나그램) 그룹 찾기 API 를 만들어보며 설명하고있음
```
Map<String, Set<String>> anagrams =
    Files.lines(Paths.get("dictionary.txt"))
         .collect(Collectors.groupingBy(
             word -> alphabetize(word),
             Collectors.toSet()));

anagrams.values().stream()
        .filter(group -> group.size() >= threshold)
        .forEach(System.out::println);

```

## 스트림 API의 장점

| 장점           | 설명                                   |
| ------------ | ------------------------------------ |
| **간결성**      | 데이터 흐름을 코드에 자연스럽게 표현                 |
| **지연 평가**    | 불필요한 연산 방지, 무한 스트림 처리 가능             |
| **조합 가능성**   | 중간 연산들을 자유롭게 조합                      |
| **병렬 처리 지원** | `.parallel()`을 호출하면 병렬 처리 가능 (주의 필요) |

## 주의할 점

- 스트림은 **단발성**이다: 한 번 종단 연산을 하면 재사용 불가.
- 무리한 스트림 사용은 코드 가독성을 해칠 수 있다.
- **병렬 스트림**은 성능 개선을 보장하지 않으며 상황에 따라 역효과 가능 

- 스트림을 너무 복잡하게 한 줄로 쓰면 **가독성이 떨어지고 유지보수가 어려움**.
- 예를 들어, 문자 하나하나를 `chars()`로 변환해 정렬하고 다시 문자열로 조립하는 부분이 복잡하게 표현됨.
```
words.collect(
    groupingBy(word -> word.chars().sorted()
        .collect(StringBuilder::new,
                 (sb, c) -> sb.append((char) c),
                 StringBuilder::append).toString()))

```

약간 무슨코드인지 한눈에 보기 힘들다 이런뜻.


##### 스트림으로 처리하기 어려운 경우:

**파이프라인 여러 단계에서 동일 데이터의 각 단계 값에 동시에 접근하기 어렵다**

- 스트림은 한 값이 다른 값으로 변환되면 원래 값은 잃는 구조
- 원래 값과 변환된 값을 함께 다뤄야 할 때는 복잡한 매핑 객체를 써야 하지만, 코드가 길고 지저분해진다
- 이럴 때는 매핑을 거꾸로 수행하는 게 낫다

메르센 소수 예제

```
static Stream<BigInteger> primes() {
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}

public static void main(String[] args) {
    primes()
        .map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
        .filter(mersenne -> mersenne.isProbablePrime(50))
        .limit(20)
        .forEach(System.out::println);
}

```

스트림 vs 반복문: 데카르트 곱(모든 조합) 예제

반복문 방법 
```
private static List<Card> newDeck() {
    List<Card> result = new ArrayList<>();
    for (Suit suit : Suit.values())
        for (Rank rank : Rank.values())
            result.add(new Card(suit, rank));
    return result;
}

```

스트림 방법
```
private static List<Card> newDeck() {
    return Stream.of(Suit.values())
        .flatMap(suit ->
            Stream.of(Rank.values())
                .map(rank -> new Card(suit, rank)))
        .collect(Collectors.toList());
}

```


>[!note] 45 핵심정리
>- 스트림은 매우 유용하지만 모든 문제에 적합한 건 아니다.
>- 여러 단계의 값들을 동시에 다뤄야 하거나, 복잡한 상태 관리가 필요할 때는 스트림이 불편할 수 있다.
>- 이런 경우 반복문이나 다른 구조가 더 직관적이고 유지보수에 유리하다.
>- 함수형 스타일에 익숙하다면 스트림을, 그렇지 않으면 전통적 반복문을 택해도 무방하다.

    