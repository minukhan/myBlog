
### 아이템 37 : ordinal 인덱싱 대신 EnumMap을 사용하라

```
Set<Plant>[] plantsByLifeCycle =
    (Set<Plant>[]) new Set[Plant.LifeCycle.values().length]; // 강제 형변환
for (int i = 0; i < plantsByLifeCycle.length; i++)
    plantsByLifeCycle[i] = new HashSet<>();

for (Plant p : garden)
    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);
    
```

이 코드의 문제?

- 앞에서 한번 나온 내용인데 `ordinal()`을 배열 인덱스로 쓰는 건 위험하다. 라고 말하고있음.
- - `ordinal()`은 열거형 상수의 "정수 위치"를 반환하는데 만약 enum 순서가 바뀌거나 수정되면 버그 발생 가능.
- 배열은 타입 안정성이 없다.
	- `Set<Plant>[]`는 제네릭 배열이 아니므로 `(Set<Plant>[])`처럼 강제 형변환을 해야 함.
- 코드 가독성이 떨어짐.

그래서 이러이러한 단점들이 있으니까 ordinal 을 사용하지말고 EnumMap을 사용하라고 말하고있음. 

### EnumMap 이란?

`EnumMap`은 Java의 `java.util` 패키지에 있는 `Map` 구현체.  
`enum`을 키로 사용할 때 **빠르고 안전한 방법**을 제공하는 자료구조임.

--> 그냥 Map 인데 Key 값을 Enum 으로 설정했을때의 Map 을 말함
ex) 

```
Map<LifeCycle, Set<Plant>> map = new EnumMap<>(LifeCycle.class);
```


```
Map<Plant.LifeCycle, Set<Plant>> plantsByLifeCycle =
    new EnumMap<>(Plant.LifeCycle.class);

for (Plant.LifeCycle lc : Plant.LifeCycle.values())
    plantsByLifeCycle.put(lc, new HashSet<>());

for (Plant p : garden)
    plantsByLifeCycle.get(p.lifeCycle).add(p);

System.out.println(plantsByLifeCycle);
```

EnumMap 장점
1. **타입 안전하다.**
    - 잘못된 인덱스를 쓰거나 강제 형변환할 필요 없음.
2. **가독성이 좋고 유지보수가 쉽다.**
    - 어떤 생애주기에 어떤 식물이 들어가는지 명확하게 보임.
3. **`EnumMap`은 매우 빠르다.**
    - 내부적으로 배열로 동작하지만 타입 안전성과 가독성을 보장함.


스트림(아이템 45)을 사용해 맵을 관리하면 코드를 더 줄일 수 있다 

#### 스트림에서 `EnumMap` 쓰는 법

```

Map<LifeCycle, Set<Plant>> result =
    Arrays.stream(garden)
          .collect(Collectors.groupingBy(
              p -> p.lifeCycle,
              () -> new EnumMap<>(LifeCycle.class),
              Collectors.toSet()));


```
- `groupingBy()`는 기본적으로 `HashMap`을 쓰는데
- `() -> new EnumMap<>(LifeCycle.class)`를 지정하면 성능 향상 + 메모리 절약


> [!note ] 37 핵심정리
> 배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니, 대신 Enum Map을 사용하라. 다차원 관계는 EnumMap<..., EnumMap<...»으로 표현하라. “애플리 케이션 프로그래머는 Enum.ordinal을 (웬만해서는) 사용하지 말아야 한다
> 


### 아이템 38 : 확장할 수 있는 열거 타입 이 필요하면 인터 페이스를 사용하라

**Java의 `enum`은 상속(확장)이 불가능하다.**

이유 
- `enum`은 사실상 **final 클래스**이기 때문.
- 또, 확장하면 원래 열거한 값들과 새 값들이 섞여버려 혼란이 생긴다.

하지만 연산(opcode)처럼 **확장 가능한 동작이 필요한 상황**도 있다. (코드 38-1)
    
이런 경우, **인터페이스를 정의해서 `enum`이 그것을 구현하게 하면** 확장 가능해진다!
### 기본 연산
```
public enum BasicOperation implements Operation {
    PLUS("+") { public double apply(double x, double y) { return x + y; } },
    MINUS("-") { public double apply(double x, double y) { return x - y; } };
    
    private final String symbol;
    BasicOperation(String symbol) { this.symbol = symbol; }
    public String toString() { return symbol; }
}

```
### 확장 연산
```
public enum ExtendedOperation implements Operation {
    EXP("^") { public double apply(double x, double y) { return Math.pow(x, y); } },
    REMAINDER("%") { public double apply(double x, double y) { return x % y; } };
    
    private final String symbol;
    ExtendedOperation(String symbol) { this.symbol = symbol; }
    public String toString() { return symbol; }
}

```

>[!note ] 38 핵심정리
> 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다. 
> 이렇게 하면 클라이언트는 이 인터페이스 를 구현해 자신만의 열거 타입（혹은 다른 타입）을 만들 수 있다. 그리고 API가  인터페이스 기반으로 작성되었다면 기본 열거 타입의 인스 턴스가 쓰이는 모든 곳을 새로 확장한 열거 타입의 인스턴스로 대체해 사용할 수 있다.



### 아이템 39 : 명명 패턴보다 애너테이션을 사용하라

### 명명 패턴 (이름으로 구분하는 방식)의 단점

**오타 실수**에 취약
- `testSafetyOverride` → `tsetSafetyOverride` 이렇게 잘못 쓰면 테스트가 누락됨    
- JUnit 3처럼 이름이 `test`로 시작해야만 테스트라고 인식하는 방식은 불안정함

잘못된 요소에 적용될 수 있음
테스트가 어떤 예외를 기대하는지 이름만 봐선 알 수 없음 추가적인 정보를 줄 수 없음.

그래서 명명패턴을 사용하지말고 애너테이션 사용을 해라 라고 말하고있음. 

```
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {}
```

- `@Retention(RetentionPolicy.RUNTIME)`  
    → 애너테이션 정보가 **런타임까지 살아있도록** 설정. 반대로 하면 실행 시 읽을 수 없음
- `@Target(ElementType.METHOD)`  
    → 이 애너테이션은 **메서드에만 붙일 수 있음**. 필드, 클래스엔 못 붙이게 막음
    
이렇게 설정을 붙인 애너테이션 선언 자체를 **메타애너테이션**이라고 한다.

### 직접 만든 간단한 테스트 러너 (`RunTests`)

- 명령줄로 테스트 대상 클래스 이름을 받고,
- 그 클래스에서 `@Test` 붙은 메서드를 실행함
- 예외가 발생하면 실패로 처리,
- 잘못 애너테이션 붙인 경우(인스턴스 메서드 등)도 잡아내서 알려준다.

### 특정 예외가 발생해야 성공하는 테스트를 위한 애너테이션

- `@ExceptionTest`를 만들어서,
- 매개변수로 "기대하는 예외 클래스"를 받게 했다.
- 테스트 메서드가 그 예외를 던져야만 성공 처리됨.

더 나아가서 여러 예외를 지정할 수 있도록 배열 매개변수도 지원한다는 내용이 쭉 나온다.

  어노테이션을 구현하는 방법들과 특정 예외처리할때를 지원해주고 배열 매개변수도 지원해준다 라고 설명하면서 쭉 설명하고있다.


### 명명패턴의 단점 및 애너테이션의 장점

| 명명 패턴        | 애너테이션              |
| ------------ | ------------------ |
| 오타에 취약       | 컴파일러가 체크해줌         |
| 의도 전달 불분명    | 의미가 명확함            |
| 정적 분석 어려움    | 도구가 쉽게 분석 가능       |
| 추가 정보 전달 어려움 | 애너테이션에 매개변수도 전달 가능 |


>[!note ] 39 핵심정리
>명명패턴의 단점들이 있으니까 되도록이면 명명패턴보단 어노테이션을 사용해라

### 아이템 40 : @Override 애너테이션을 일관되게 사용하라

이 애너테이션이 달렸다는 것은 상위 타입의 메서드를 재정의했음을 뜻한다. 
이 애너테이션을 일관되게 잘 사용하면 각종 버그들을 예방해준다. 
**`
 ###### @Override가 중요한 이유
- **상위 타입의 메서드를 재정의했음을 명확히 표현**.
- 실수로 **매개변수나 이름을 틀리거나**, 재정의가 아닌 **오버로딩이 되어버리는** 버그를 **컴파일 타임에 잡아준다**.

```
import java.util.HashSet;
import java.util.Set;
import java.util.Objects;

public class Bigram {
    private final char first;
    private final char second;

    public Bigram(char first, char second) {
        this.first = first;
        this.second = second;
    }

	public boolean equals(Bigram b) { // 오버로딩!
	    return b.first == first && b.second == second;
	}

    public int hashCode() {
        return 31 * first + second;
    }

    public static void main(String[] args) {
        Set<Bigram> s = new HashSet<>();
        for (int i = 0; i < 10; i++) {
            for (char ch = 'a'; ch <= 'z'; ch++) {
                s.add(new Bigram(ch, ch));
            }
        }
        System.out.println(s.size());  // 올바르게 26 출력됨
    }
}


```

- main 메서드를 보면 똑같은 소문자 2개로 구성된 바이그램 26개를 10번 반복해 집합에 추가한 다음, 그 집합의 크기를 출력한다. Set은 중복을 허용하지 않으니 26이 출력될 거 같지만, 실제로는 260이 출력된다

- 뭐가 문제일까? 하면서 얘기를 함

```
public boolean equals(Bigram b) { // 오버로딩!
	return b.first == first && b.second == second;
}
	
```
- `equals(Object)`가 아닌 `equals(Bigram)`으로 정의되어 오버라이딩이 아니라 오버로딩이 되어버린것
- Object의 equals를 재정의하려면 매개변수 타입을 Object로 해야만 하는데, 그렇게 하지 않은 것.
- 그래서 Object에서 상속한 equals와는 별개인 equals를 새로 정의한 꼴이 되어버려서 그랬다.
- 그래서 `HashSet`이 `equals()`를 무시하고 **모두 다른 객체로 판단**, 중복 제거 실패.

이러한 경우가 생길 수 있으므로 Override 애너테이션을 다는것!


```
@Override
public boolean equals(Bigram b) {
	return b.first == first && b.second == second;
}
```
- 이렇게 @Override 를 붙이고 컴파일하면 컴파일 오류가 발생한다. 
- 이렇게 오류를 쉽게 알아차리기 좋음. 

>[!note] 40 핵심정리
>재정의한 모든 메서드에 QOverride 애너테이션을 의식적으로 달면 여러분이 실수했을 때 컴파일러가 바로 알려줄 것이다. 예외는 한 가지뿐이다. 구체 클래스에서 상위 클래스 의 추상 메서드를 재정의한 경우엔 이 애너테이션을 달지 않아도 된다



### 아이템 41 : 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

- 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 마커 인터페이스(marker interface)라 한다.
```

public interface Serializable {
    // 아무 메서드도 없다. 단지 "이 객체는 직렬화 가능하다"는 의미만 있음.
}

```

 마커 애너테이션(marker annotation)란?

> 역시 의미 부여용이지만, **인터페이스 대신 애너테이션(@)** 으로 표현하는 것.

```
@interface Testable {}  // 메서드에 "테스트 가능"하다는 의미를 부여
@Testable
public void runTest() {}

```

#### 마커 인터페이스 장점

-  **컴파일타임 타입 체크 가능**
    - 예: `void save(Serializable obj)` 처럼 해당 마커를 매개변수 타입으로 사용할 수 있음.
    - `@Serializable` 같은 애너테이션을 쓰면 타입 제한이 불가능해서 런타임까지 오류를 모르고 갈 수 있음.
        
-  **더 정밀한 대상 지정 가능**
    - 인터페이스를 특정 타입에만 `implements` 하게 만들어 적용 범위를 제어할 수 있음.
    - 반면, 애너테이션은 `@Target(TYPE)`이라면 **모든 타입(클래스/인터페이스/enum 등)** 에 붙일 수 있어 제약이 약함.

>[!note] 41 핵심정리 
>객체에 특정 **속성**을 부여하면서, 그 속성을 **타입처럼 활용**하고 싶다면 마커 인터페이스.  
  다양한 코드 요소에 **광범위하게 적용**하거나 프레임워크 통합이 필요하다면 마커 애너테이션

