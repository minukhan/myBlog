
비교기반 정렬 : 대부분 비교기반 정렬이다. 

> [!note] 아닌것들
> 기수정렬 

> [!note] 비교기반의 정렬의 하한
> N Log N

### 버블정렬 

> N 제곱

![](https://postfiles.pstatic.net/MjAyNTAxMjVfMTA5/MDAxNzM3NzkxNTQ5Nzk4.Dh0sGm3SuaYBBgJjd0xKoLvmHyxMcwD7Ys31GKErRWgg.jqcuKoxc4-5fKEODJz5WG7wn3efIh5uiOHgzXvKuTfMg.PNG/image.png?type=w966)

### 삽입정렬 

> N제곱

![](https://postfiles.pstatic.net/MjAyNTAyMDVfMTUx/MDAxNzM4NzU5OTk5Mzk4.zNMuQiQunKpO9cHB3YBo7x_BJsmK7zS_RDJZGT9rn5wg.VuD-95tNJv9ANxf1XPsS6NRqEWvvl4CXtKcpd_lvvmQg.PNG/image.png?type=w966)


### 병합정렬 (분할정렬) (MergeSort)

> N LogN (안정적임 이유는 길이에대해서 결정적인데 변하지 않음.)

- 빠른데 단점은 메모리가 더 사용됨. 새로운 배열에 저장하는거니까. 
![](https://i.imgur.com/qwqiHis.png)


### 퀵정렬

> N LogN  인데 최악의 경우에는 N 제곱


병합정렬보다 퀵정렬이 보통 빠르다고 하는데 지역성 때문에 그렇다. 

![](https://i.imgur.com/6XobJ19.png)

### 힙소트

> N LogN 이다. 안정적임. 

병합정렬보다는 조금 오래걸린다. 

- min 힙이면 모든 부모노드는 자식보다 작다.
- 완전 이진 트리다.

![](https://i.imgur.com/RhtDIAg.png)


메모리가 적게든다. -> 메모리를 적게쓰는 임베디드에서 많이 사용


> [!important] 각각 사용되는 경우
> 퀵 : 보통은 가장 빠르다. 
> 
> 안정적으로 정렬을 하는것이 필요하다면 : 힙, 병합
> 
> 여기서 메모리가 여유가 있다면 :병합 

> [!note] 알아두면 좋은점
> 
> 1. 이미 정렬이 조금 되어있다면 삽입정렬이 더 빠르다!!
> 2. N의 갯수가 200개 정도보다 작으면 삽입정렬이 빠르다!!











