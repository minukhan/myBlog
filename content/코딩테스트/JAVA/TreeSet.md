
## TreeSet 이란?

- **`TreeSet`은 `Set` 인터페이스를 구현한 자료구조**예요.
- 내부적으로 **이진 탐색 트리(Binary Search Tree)** 구조를 사용해요.
- 그래서 **데이터가 항상 정렬된 상태로 저장**돼요.
- 중복된 값은 허용하지 않아요 (`Set`의 특징).

| 메서드                    | 설명                                    |
| ---------------------- | ------------------------------------- |
| `add(E e)`             | 요소 추가 (중복이면 무시)                       |
| `remove(Object o)`     | 요소 제거                                 |
| `contains(Object o)`   | 특정 요소 존재 여부 확인                        |
| `first()`              | 가장 작은 값 반환                            |
| `last()`               | 가장 큰 값 반환                             |
| `higher(E e)`          | e보다 **큰** 값 중 가장 작은 값 반환 (`> e`)      |
| `lower(E e)`           | e보다 **작은** 값 중 가장 큰 값 반환 (`< e`)      |
| `ceiling(E e)`         | e보다 **크거나 같은** 값 중 가장 작은 값 반환 (`≥ e`) |
| `floor(E e)`           | e보다 **작거나 같은** 값 중 가장 큰 값 반환 (`≤ e`)  |
| `iterator()`           | 오름차순 순회                               |
| `descendingIterator()` | 내림차순 순회                               |

### PriorityQueue vs TreeSet

|구분|PriorityQueue|TreeSet|
|---|---|---|
|내부구조|힙(Heap)|이진 탐색 트리 (균형 이진 트리)|
|정렬 상태|루트 노드만 최우선순위 보장|항상 전체가 정렬된 상태 유지|
|중복 원소|허용|허용하지 않음 (Set이라 중복 불가)|
|삽입/삭제 시간|O(log N)|O(log N)|
|임의 원소 삭제|직접 불가능 (재구성 필요)|O(log N) 직접 가능|
|메모리 사용|상대적으로 적음|상대적으로 많음|
|최고/최저 찾기|O(1) (peek()가 루트 접근)|O(log N) (first(), last())|
|중간값 접근|불가능|직접 접근 불가능 (순회 필요)|
|구현 단순성|상대적으로 간단|비교적 복잡 (특히 복합키인 경우)|


|특징|설명|
|---|---|
|**자동 정렬**|오름차순(기본 `Comparable` 기준)으로 정렬됨|
|**중복 제거**|`Set`이므로 중복된 값은 하나만 유지|
|**시간 복잡도**|삽입, 삭제, 탐색: 모두 `O(log N)`|
|**내부 구조**|Red-Black Tree 기반|
